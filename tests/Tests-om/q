(*****************************************************************************)
(*****  Devellopement d'applications avec Objective Caml                 *****)
(*****                                                                   *****)
(*****  Solution des exercices : Chapitre 14                             *****)
(*****************************************************************************)

(* exercice 3 : Arbres lexicaux *)

(* 3.1 *)

pin_mode PIN1 OUTPUT;
digital_write PIN1 HIGH;
module type MOT =
 sig
  type alpha
  type t
  val null : t
  val of_alpha : alpha -> t
  val get : t -> int -> alpha
  val sub : t -> int -> int -> t
  val length : t -> int
  val concat : t -> t -> t
 end ;;


(* 3.2 *)

module ArbLex (M:MOT) =
  struct
    type node = Lettre of M.alpha * bool * t
    and t = node list

    let rec existe m d = 
      let  aux sm i n = 
        match d with
            [] -> false
          | (Lettre (a,b,l))::q when a = M.get sm i -> 
              if n = 1 then b else existe (M.sub sm (i+1) (n-1)) l       
          | (Lettre (a,b,l))::q when a = M.get sm i -> 
              existe sm q
    in aux m 0 (M.length m)

    let rec ajoute m d = 
      let aux sm i n = 
        if n = 0 then d 
        else 
          match d with 
              [] -> 
                let aux = ajoute (M.sub sm (i+1) (n-1)) [] in
                [ Lettre (M.get sm i, n = 1, aux) ] 
            | (Lettre(a,b,l))::q when a = M.get sm i ->
                if n = 1 then (Lettre(a,true,l))::q
                else Lettre(a,b,ajoute (M.sub sm (i+1) (n-1)) l)::q
            | (Lettre(a,b,l))::q -> (Lettre(a,b,l))::(ajoute sm q)
      in aux m 0 (M.length m)

    let rec selecte n d = match d with 
        [] -> []
      | (Lettre(a,b,l))::q when n=1 -> 
          let f (Lettre(a,b,_)) = if b then M.of_alpha a else M.null in 
          List.filter ((<>) M.null) (List.map f d) 
      | (Lettre(a,b,l))::q  -> 
          let r = selecte (n-1) l and r2 = selecte n q in
          let pr = List.map (function s -> M.concat (M.of_alpha a) s) r in
          pr@r2
  end ;;


(* 3.3 *)

module Chars =
  struct
    type alpha = char
    type t = string
    let null = ""
    let of_alpha c = String.make 1 c 

    let get s i = 
      try s.[i] 
      with Invalid_argument(_) -> raise (Invalid_argument "Chars.get")
    let sub s i1 i2 =
      try String.sub s i1 i2 
      with Invalid_argument(_) -> raise (Invalid_argument "Chars.sub")
    let length = String.length
    let concat = (^)
  end ;;

module CharsDic = ArbLex(Chars) ;;

let m = "Hello";;
let d = CharsDic.ajoute m [];;
match CharsDic.existe m d with
| true -> 0
| false -> 1;;
(* if CharsDic.existe m d then print_string "OK" else print_string "PB";; *)
(* print_newline();; *)
digital_write PIN1 LOW(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: bdd.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

(* Translated to Caml by Xavier Leroy *)
(* Original code written in SML by ... *)

type bdd = One | Zero | Node of bdd * int * int * bdd

let rec eval bdd vars =
  match bdd with
    Zero -> false
  | One -> true
  | Node(l, v, _, h) ->
      if vars.(v) then eval h vars else eval l vars

let getId bdd = 
  match bdd with 
    Node(_,_,id,_) -> id
  | Zero           -> 0
  | One            -> 1

let initSize_1 = 8*1024 - 1
let nodeC      = ref 1
let sz_1       = ref initSize_1
let htab       = ref(Array.create (!sz_1+1) [])
let n_items    = ref 0
let hashVal x y v = x lsl 1 + y + v lsl 2

let resize newSize =
      let arr     = !htab in
      let newSz_1 = newSize-1 in
      let newArr  = Array.create newSize [] in
      let rec copyBucket bucket =
                match bucket with 
                  []     -> ()
                | n :: ns ->  
                    match n with 
                    | Node(l,v,_,h) ->
                       let ind = hashVal (getId l) (getId h) v land newSz_1
                       in
                       newArr.(ind) <- (n :: newArr.(ind));
                       copyBucket ns
                    | _ -> assert false
                    in
      for n = 0 to !sz_1 do
        copyBucket(arr.(n))
      done;
      htab := newArr;
      sz_1 := newSz_1


let rec insert idl idh v ind bucket newNode =
        if !n_items <= !sz_1
        then ( (!htab).(ind) <- (newNode :: bucket);
               incr n_items )
        else ( resize(!sz_1 + !sz_1 + 2);
               let ind = hashVal idl idh v land (!sz_1)
               in
                  (!htab).(ind) <- newNode :: (!htab).(ind)
             )


let resetUnique () = (
      sz_1    := initSize_1;
      htab    := Array.create (!sz_1+1) [];
      n_items := 0;
      nodeC   := 1
      )

let mkNode low v high =
   let idl = getId low in
   let idh = getId high 
   in
     if idl = idh
     then low
     else let ind      = hashVal idl idh v land  (!sz_1) in
          let bucket   = (!htab).(ind) in
          let rec lookup b = 
                    match b with 
                      [] -> let n = Node(low, v, (incr nodeC; !nodeC), high)
                            in
                             insert (getId low) (getId high) v ind bucket n; n
                    | n :: ns -> 
                        match n with
                        | Node(l,v',id,h) ->
                           if v = v' && idl = getId l && idh = getId h
                           then n else lookup ns
                        | _ -> assert false
           in
             lookup bucket


type ordering = LESS | EQUAL | GREATER

let cmpVar (x : int) (y : int) =
  if x<y then LESS else if x>y then GREATER else EQUAL 

let zero = Zero
let one  = One

let mkVar x   = mkNode zero x one


let cacheSize = 1999
let andslot1  = Array.create cacheSize 0
let andslot2  = Array.create cacheSize 0
let andslot3  = Array.create cacheSize zero
let xorslot1  = Array.create cacheSize 0
let xorslot2  = Array.create cacheSize 0
let xorslot3  = Array.create cacheSize zero
let notslot1  = Array.create cacheSize 0
let notslot2  = Array.create cacheSize one
let hash x y  = ((x lsl 1)+y) mod cacheSize

let rec not n = 
match n with
  Zero -> One
| One  -> Zero
| Node(l, v, id, r) -> let h = id mod cacheSize
                       in
                          if id=notslot1.(h) then notslot2.(h)
                          else let f = mkNode (not l) v (not r)
                               in
                                 notslot1.(h) <- id; notslot2.(h) <- f; f

let rec and2 n1 n2 = 
match n1 with
  Node(l1, v1, i1, r1) 
  -> (match n2 with
        Node(l2, v2, i2, r2)
        -> let h = hash i1 i2
           in
             if i1=andslot1.(h) && i2=andslot2.(h) then andslot3.(h)
             else let f = match cmpVar v1 v2 with
                            EQUAL   -> mkNode (and2 l1 l2) v1 (and2 r1 r2)
                          | LESS    -> mkNode (and2 l1 n2) v1 (and2 r1 n2)
                          | GREATER -> mkNode (and2 n1 l2) v2 (and2 n1 r2)
                  in
                   andslot1.(h) <- i1; 
                   andslot2.(h) <- i2; 
                   andslot3.(h) <- f;
                   f
     | Zero -> Zero
     | One  -> n1)
|  Zero -> Zero
|  One  -> n2


let rec xor n1 n2 = 
match n1 with
  Node(l1, v1, i1, r1) 
  -> (match n2 with
        Node(l2, v2, i2, r2)
        -> let h = hash i1 i2
           in
             if i1=andslot1.(h) && i2=andslot2.(h) then andslot3.(h)
             else let f = match cmpVar v1 v2 with
                            EQUAL   -> mkNode (xor l1 l2) v1 (xor r1 r2)
                          | LESS    -> mkNode (xor l1 n2) v1 (xor r1 n2)
                          | GREATER -> mkNode (xor n1 l2) v2 (xor n1 r2)
                  in
                   andslot1.(h) <- i1;
                   andslot2.(h) <- i2;
                   andslot3.(h) <- f;
                   f
     | Zero -> n1 
     | One  -> not n1)
|  Zero -> n2
|  One  -> not n2

let hwb n = 
  let rec h i j = if i=j
                  then mkVar i
                  else  xor (and2 (not(mkVar j)) (h i (j-1)))
                            (and2 (mkVar j)      (g i (j-1)))
      and g i j = if i=j
                  then mkVar i
                  else xor (and2 (not(mkVar i)) (h (i+1) j)) 
                           (and2 (mkVar i)      (g (i+1) j))
  in
     h 1 n

(* Testing *)
let seed = ref 0

let random() =
  seed := !seed * 25173 + 17431; !seed land 1 > 0

let random_vars n =
  let vars = Array.create n false in
  for i = 0 to n - 1 do vars.(i) <- random() done;
  vars

let test_hwb bdd vars =
  (* We should have
        eval bdd vars = vars.(n) if n > 0
        eval bdd vars = 0 if n = 0
     where n is the number of "true" elements in vars. *)
  let ntrue = ref 0 in
  for i = 0 to Array.length vars - 1 do
    if vars.(i) then incr ntrue
  done;
  eval bdd vars = (if !ntrue > 0 then vars.(!ntrue) else false)

let main () =
  let n =
    if Array.length Sys.argv >= 2 then int_of_string Sys.argv.(1) else 20 in
  let ntests =
    if Array.length Sys.argv >= 3 then int_of_string Sys.argv.(2) else 50 in
  let bdd = hwb n in
  let succeeded = ref true in
  for i = 1 to ntests do
    succeeded := !succeeded || test_hwb bdd (random_vars n)
  done;
  if !succeeded
  then print_string "OK\n"
  else print_string "FAILED\n";
  exit 0

let _ = main()
let _ =
  print_int 1000000000; print_newline();
  print_int 10000000000; print_newline();
  print_int 100000000000; print_newline();
  print_int 1000000000000; print_newline();
  print_int 10000000000000; print_newline();
  print_int 100000000000000; print_newline();
  print_int 1000000000000000; print_newline();
  print_int 10000000000000000; print_newline();
  print_int 100000000000000000; print_newline();
  print_int 1000000000000000000; print_newline()

let test n exp res =
  print_string "Test "; print_int n;
  if exp = res then print_string " passed.\n" else print_string " FAILED.\n";
  flush stdout

let x = [1;2;3]

let f x = 1 :: 2 :: 3 :: x

let mklist len =
  let l = ref [] in
  for i = 1 to len do l := i :: !l done;
  !l

type tree = Dummy | Leaf | Node of tree * tree

let rec mktree depth =
  if depth <= 0 then Leaf else Node(mktree(depth - 1), mktree(depth - 1))

type 'a leftlist = Nil | Cons of 'a leftlist * 'a

let mkleftlist len =
  let l = ref Nil in
  for i = 1 to len do l := Cons(!l, i) done;
  !l

let _ =
  test 1 0 (compare 0 0);
  test 2 (-1) (compare 0 1);
  test 3 1 (compare 1 0);
  test 4 0 (compare max_int max_int);
  test 5 (-1) (compare min_int max_int);
  test 6 1 (compare max_int min_int);
  test 7 0 (compare "foo" "foo");
  test 8 (-1) (compare "foo" "zorglub");
  test 9 (-1) (compare "abcdef" "foo");
  test 10 (-1) (compare "abcdefghij" "abcdefghijkl");
  test 11 1 (compare "abcdefghij" "abcdefghi");
  test 12 0 (compare (0,1) (0,1));
  test 13 (-1) (compare (0,1) (0,2));
  test 14 (-1) (compare (0,1) (1,0));
  test 15 1 (compare (0,1) (0,0));
  test 16 1 (compare (1,0) (0,1));
  test 17 0 (compare 0.0 0.0);
  test 18 (-1) (compare 0.0 1.0);
  test 19 (-1) (compare (-1.0) 0.0);
  test 20 0 (compare [| 0.0; 1.0; 2.0 |] [| 0.0; 1.0; 2.0 |]);
  test 21 (-1) (compare [| 0.0; 1.0; 2.0 |] [| 0.0; 1.0; 3.0 |]);
  test 22 1 (compare [| 0.0; 5.0; 2.0 |] [| 0.0; 1.0; 2.0 |]);
  test 23 0 (compare [1;2;3;4] [1;2;3;4]);
  test 24 (-1) (compare [1;2;3;4] [1;2;5;6]);
  test 25 (-1) (compare [1;2;3;4] [1;2;3;4;5]);
  test 26 1 (compare [1;2;3;4] [1;2;3]);
  test 27 1 (compare [1;2;3;4] [1;2;0;4]);
  test 28 0 (compare (mklist 1000) (mklist 1000));
  test 29 0 (compare (mkleftlist 1000) (mkleftlist 1000));
  test 30 0 (compare (mktree 12) (mktree 12));
  test 31 true (x = f []);
  test 32 true (stdout <> stderr)

type jeton = Vrai | Faux | Var of char | Non | Et | Ou | ParenG | ParenD;;
type formule = jeton list;;
type env = (char * bool) list;;



let eval_op so sv = 
  match Stack.pop so, Stack.pop sv with 
                   | Non, Vrai  -> Stack.push Faux sv
                   | Non, Faux -> Stack.push Vrai sv
                   | Et, Vrai  -> ()
                   | Et, Faux  -> ignore(Stack.pop sv); Stack.push Faux sv 
                   | Ou, Vrai  -> ignore(Stack.pop sv); Stack.push Vrai sv 
                   | Ou, Faux  -> ()
                   | _ -> failwith "eval_op" 

let one_step  sv so env j = match j with 
  | Vrai | Faux -> Stack.push j sv
  | Var c -> Stack.push (List.assoc c env) sv
  | Non | Et | Ou -> Stack.push j so 
  | ParenG -> () 
  | ParenD -> eval_op so sv
;;

let eval env lj = 
  let sv = Stack.create() 
  and so = Stack.create() 
  in 
    List.iter (one_step sv so env) lj;
    while not (Stack.is_empty so) do 
        eval_op so sv
    done;
    Stack.pop sv
;;
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: fft.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

let pi = 3.14159265358979323846

let tpi = 2.0 *. pi

let fft px py np =
  let i = ref 2 in
  let m = ref 1 in
  
  while (!i < np) do
    i := !i + !i; 
    m := !m + 1
  done;

  let n = !i in  
  
  if n <> np then begin
    for i = np+1 to n do
      px.(i) <- 0.0; 
      py.(i) <- 0.0
    done;
    print_string "Use "; print_int n;
    print_string " point fft"; print_newline()
  end;

  let n2 = ref(n+n) in
  for k = 1 to !m-1 do
    n2 := !n2 / 2; 
    let n4 = !n2 / 4 in
    let e  = tpi /. float !n2 in

    for j = 1 to n4 do
      let a = e *. float(j - 1) in
      let a3 = 3.0 *. a in
      let cc1 = cos(a) in
      let ss1 = sin(a) in
      let cc3 = cos(a3) in
      let ss3 = sin(a3) in
      let is = ref j in
      let id = ref(2 * !n2) in
  
        while !is < n do
          let i0r = ref !is in
          while !i0r < n do
             let i0 = !i0r in
             let i1 = i0 + n4 in
             let i2 = i1 + n4 in
             let i3 = i2 + n4 in
             let r1 = px.(i0) -. px.(i2) in
             px.(i0) <- px.(i0) +. px.(i2);
             let r2 = px.(i1) -. px.(i3) in
             px.(i1) <- px.(i1) +. px.(i3);
             let s1 = py.(i0) -. py.(i2) in
             py.(i0) <- py.(i0) +. py.(i2);
             let s2 = py.(i1) -. py.(i3) in
             py.(i1) <- py.(i1) +. py.(i3);
             let s3 = r1 -. s2 in
             let r1 = r1 +. s2 in
             let s2 = r2 -. s1 in
             let r2 = r2 +. s1 in
             px.(i2) <- r1*.cc1 -. s2*.ss1; 
             py.(i2) <- -.s2*.cc1 -. r1*.ss1;
             px.(i3) <- s3*.cc3 +. r2*.ss3;
             py.(i3) <- r2*.cc3 -. s3*.ss3;
             i0r := i0 + !id
          done;
          is := 2 * !id - !n2 + j; 
          id := 4 * !id
        done
    done
  done;

(************************************)
(*  Last stage, length=2 butterfly  *)
(************************************)

  let is = ref 1 in
  let id = ref 4 in
  
  while !is < n do
    let i0r = ref !is in
    while !i0r <= n do
      let i0 = !i0r in
      let i1 = i0 + 1 in
      let r1 = px.(i0) in
      px.(i0) <- r1 +. px.(i1);
      px.(i1) <- r1 -. px.(i1);
      let r1 = py.(i0) in
      py.(i0) <- r1 +. py.(i1);
      py.(i1) <- r1 -. py.(i1);
      i0r := i0 + !id
    done;
    is := 2 * !id - 1; 
    id := 4 * !id
  done;

(*************************)
(*  Bit reverse counter  *)
(*************************)

  let j = ref 1 in
  
  for i = 1 to n - 1 do
    if i < !j then begin
      let xt = px.(!j) in
      px.(!j) <- px.(i); 
      px.(i) <- xt;
      let xt = py.(!j) in
      py.(!j) <- py.(i);
      py.(i) <- xt
    end;
    let k = ref(n / 2) in
    while !k < !j do
      j := !j - !k; 
      k := !k / 2
    done;
    j := !j + !k
  done;

  n


let test np =
  print_int np; print_string "... "; flush stdout;
  let enp = float np in
  let npm = np / 2 - 1 in
  let pxr = Array.create (np+2) 0.0
  and pxi = Array.create (np+2) 0.0 in
  let t = pi /. enp in
  pxr.(1) <- (enp -. 1.0) *. 0.5;
  pxi.(1) <- 0.0;
  let n2 = np / 2 in
  pxr.(n2+1) <- -0.5;
  pxi.(n2+1) <-  0.0;

  for i = 1 to npm do
      let j = np - i in
      pxr.(i+1) <- -0.5;
      pxr.(j+1) <- -0.5;
      let z = t *. float i in
      let y = -0.5*.(cos(z)/.sin(z)) in
      pxi.(i+1) <- y;
      pxi.(j+1) <- -.y
  done;
(**
  print_newline();
  for i=0 to 15 do Printf.printf "%d  %f  %f\n" i pxr.(i+1) pxi.(i+1) done;
**)
  let _ = fft pxr pxi np in
(**
  for i=0 to 15 do Printf.printf "%d  %f  %f\n" i pxr.(i+1) pxi.(i+1) done;
**)
  let zr = ref 0.0 in
  let zi = ref 0.0 in
  let kr = ref 0 in
  let ki = ref 0 in
  for i = 0 to np-1 do
      let a = abs_float(pxr.(i+1) -. float i) in
      if !zr < a then begin
         zr := a; 
         kr := i
      end;
      let a = abs_float(pxi.(i+1)) in
      if !zi < a then begin
         zi := a; 
         ki := i
      end
  done;
  let zm = if abs_float !zr < abs_float !zi then !zi else !zr in
  print_float zm; print_newline()


let _ =
  let np = ref 16 in for i = 1 to 13 do test !np; np := !np*2 done

(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: fib.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

let rec fib n =
  if n < 2 then 1 else fib(n-1) + fib(n-2)

let _ =
  let n =
    if Array.length Sys.argv >= 2 
    then int_of_string Sys.argv.(1)
    else 30 in
  print_int(fib n); print_newline(); exit 0

Printf.printf "1./.0. = %f\n" (1.0 /. 0.0);;
(* Test for "include <module-expr>" inside structures *)

module A =
  struct
    type t = int
    let x = (1 : t)
    let y = (2 : t)
    let f (z : t) = (x + z : t)
  end

module B =
  struct
    include A
    type u = t * t
    let p = ((x, y) : u)
    let g ((x, y) : u) = ((f x, f y) : u)
  end

let _ =
  let print_pair (x,y) =
    print_int x; print_string ", "; print_int y; print_newline() in
  print_pair B.p;
  print_pair (B.g B.p);
  print_pair (B.g (123, 456))

module H =
  struct
    include A
    let f (z : t) = (x - 1 : t)
  end

let _ =
  print_int (H.f H.x); print_newline()

module C =
  struct
    include (A : sig type t val f : t -> int val x : t end)
    let z = f x
  end

let _ =
  print_int C.z; print_newline();
  print_int (C.f C.x); print_newline()

(* Toplevel inclusion *)

include A

let _ =
  print_int x; print_newline();
  print_int (f y); print_newline()

(* With a functor *)

module F(X: sig end) =
  struct
    let _ = print_string "F is called"; print_newline()
    type t = A | B of int
    let print_t = function A -> print_string "A"
                         | B x -> print_int x
  end

module D =
  struct
    include F(struct end)
    let test() = print_t A; print_newline(); print_t (B 42); print_newline()
  end
    
let _ =
  D.test();
  D.print_t D.A; print_newline(); D.print_t (D.B 42); print_newline()

(* Exceptions and classes *)

module E =
  struct
    exception Exn of string
    class c = object method m = 1 end
  end

module G =
  struct
    include E
    let _ =
      begin try raise (Exn "foo") with Exn s -> print_string s end;
      print_int ((new c)#m); print_newline()
  end

let _ =
  begin try raise (G.Exn "foo") with G.Exn s -> print_string s end;
  print_int ((new G.c)#m); print_newline()


class cell a =
  object
    val mutable v = (a : bool)
    method isAlive = v
  end ;;


(* 4.2 *)

class virtual absWorld n m  =
  object(self)
    val mutable tcell = Array.create_matrix n m (new cell false)
    val maxx = n
    val maxy = m
    val mutable gen = 0
    method private dessine(c) =
     if c#isAlive then print_string "*"
     else print_string "."
    method display() =
      for i = 0 to (maxx-1) do
        for j=0 to (maxy -1) do
          print_string " " ; 
          self#dessine(tcell.(i).(j))
        done ;
        print_newline()
      done
    method getCell(i,j) = tcell.(i).(j)
    method setCell(i,j,c) = tcell.(i).(j) <- c
    method getCells = tcell
  end ;;


(* 4.3 *)

class world n m =
  object(self)
    inherit absWorld n m
    method neighbors(x,y) =
      let r = ref 0 in
      for i=x-1 to x+1 do
        let k = (i+maxx) mod maxx in
        for j=y-1 to y+1 do
          let l = (j + maxy) mod maxy in
            if tcell.(k).(l)#isAlive then incr r
        done
      done;
      if tcell.(x).(y)#isAlive then decr r ;
      !r

    method nextGen() =
      let w2 = new world maxx maxy in
      for i=0 to maxx-1 do
        for j=0 to maxy -1 do
          let n = self#neighbors(i,j) in
          if tcell.(i).(j)#isAlive   
          then (if (n = 2) || (n = 3) then w2#setCell(i,j,new cell true))
          else (if n = 3 then w2#setCell(i,j,new cell true))
        done
      done ;
      tcell <- w2#getCells ;
      gen <- gen + 1
  end ;;


(* 4.4 *)

exception Fin;;

let main () =
  
  let a = 10 and b = 12 in
  let w = new world a b in
  w#setCell(4,4,new cell true) ;
  w#setCell(4,5,new cell true) ;
  w#setCell(4,6,new cell true) ;
  try 
    while true do
      w#display() ;
      if ((read_line()) = "F") then raise Fin else w#nextGen()
    done 
  with Fin -> () ;;

main () ;;



include ../Tools/OMicroBPIC32/etc/Makefile.conf

SOURCES := arbl.ml
TARGETS := arbl.byte arbl.c arbl.elf arbl.pic32_elf arbl.hex

all: $(TARGETS)

$(TARGETS): $(SOURCES)
	$(BIN)/omicrob -v -flash -device fubarino-mini $^ -mlopt -verbose -stack-size 200 -heap-size 200

clean:
	@rm -f *.cmo *.cmi
	@rm -f sketch.ld.*
	@rm -f $(TARGETS)

.PHONY: all clean
include ../Tools/OMicroBPIC32/etc/Makefile.conf

SOURCES := arbl.ml
TARGETS := arbl.byte arbl.c arbl.elf arbl.pic32_elf arbl.hex

all: $(TARGETS)

$(TARGETS): $(SOURCES)
	time $(BIN)/omicrob -v -flash -device fubarino-mini $^ -mlopt -verbose -stack-size 200 -heap-size 200

clean:
	@rm -f *.cmo *.cmi
	@rm -f sketch.ld.*
	@rm -f $(TARGETS)

.PHONY: all clean
(**************************************************************)
(*  This suite tests the pattern-matching compiler            *)
(*  it should just compile and run.                           *)
(*  While compiling the following messages are normal:        *)
(**************************************************************)

(*
File "morematch.ml", line 21, characters 10-93:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
0
File "morematch.ml", line 376, characters 2-15:
Warning: this match case is unused.
File "morematch.ml", line 443, characters 2-7:
Warning: this match case is unused.
*)

let test msg f arg r =
  if f arg <> r then begin
    prerr_endline msg ;
    failwith "Malaise"
  end
;;

type t = A | B | C | D | E | F
  ;;

let f x = match x with
| A | B | C -> 1
| D | E -> 2
| F -> 3;;

test "un" f C 1 ;
test "un" f D 2 ;
test "un" f F 3 ; ()
;;

let g x = match x with
  1 -> 1
| 2 -> 2
| 3 -> 3
| 4 | 5 -> 4
| 6 -> 5
| 7 | 8 -> 6
| 9 -> 7
;;

test "deux" g 5 4 ;
test "deux" g 6 5 ;
test "deux" g 9 7 ; ()
;;

  
let g x = match x with
  1 -> 1
| 2 -> 2
| 3 -> 3
| 4 | 5 -> 4
| 6 -> 5   
| 7 | 8 -> 6
| 9 -> 7
| _ -> 8;;

test "trois" g 10 8
;;

let g x= match  x with
  1 -> 1
| 2 -> 2
| 3 -> 3
| 4 | 5 -> 4
| 6 -> 5   
| 4|5|7 -> 100
| 7 | 8 -> 6
| 9 -> 7
| _ -> 8;;
test "quatre" g 4 4 ;
test "quatre" g 7 100 ; ()
;;


let h x =
 match x with
   (1,1) -> 1
| (2|3), 1 -> 2
| 2,(2|3) -> 3
| (4,4) -> 5
| _ -> 100
;;

test "cinq" h (2,2) 3 ;
test "cinq" h (2,1) 2 ;
test "cinq" h (2,4) 100 ; ()
;;

(* idem hh (2,5) *)

let hh x = match x with
| 1,1 -> 1
| 2,1 -> 2
| (2|3),(1|2|3|4) -> 3
| 2,5 -> 4
| (4,4) -> 5
| _ -> 100
;;

let hhh x = match x with
| 1,1 -> 1
| (2|3),1 -> 2
| 2,2 -> 3
| _ -> 100
;;

let h x =
 match x with
   (1,1) -> 1
| 3,1 -> 2
| 2,(2|3) -> 3
| (4,4) -> 5
| _ -> 100
;;

let h x = match x with
  1 -> 1
| 2|3 -> 2
| 4 -> 4
| 5 -> 5
| 6|7 -> 6
| 8 -> 8
| _ -> 100
;;
let f x = match x with
| ((1|2),(3|4))|((3|4),(1|2)) -> 1
| (3,(5|6)) -> 2
| _ -> 3
;;

test "six" f (1,3) 1 ;
test "six" f (3,2) 1 ;
test "six" f (3,5) 2 ;
test "six" f (3,7) 3 ; ()
;;

type tt = {a : bool list ; b : bool}

let f = function
  | {a=([]|[true])} -> 1
  | {a=false::_}|{b=(true|false)}    -> 2
;;

test "sept" f {a=[] ; b = true} 1 ;
test "sept" f {a=[true] ; b = false} 1 ;
test "sept" f {a=[false ; true] ; b = true} 2 ;
test "sept" f {a=[false] ; b = false} 2 ; ()
;;

let f = function
  | (([]|[true]),_) -> 1
  | (false::_,_)|(_,(true|false)) -> 2
;;

test "huit" f ([],true) 1 ;
test "huit" f ([true],false) 1 ;
test "huit" f ([false ; true], true) 2 ;
test "huit" f ([false], false) 2 ; ()
;;


let split_cases = function
   | `Nil | `Cons _ as x -> `A x
   | `Snoc _ as x -> `B x
;;

test "oubli" split_cases `Nil (`A `Nil);
test "oubli" split_cases (`Cons 1) (`A (`Cons 1));
test "oubli" split_cases (`Snoc 1) (`B (`Snoc 1)) ; ()
;;

type t1 = A of int | B of int
let f1 = function
  | (A x | B x) -> x
;;

test "neuf" f1 (A 1) 1 ;
test "neuf" f1 (B 1) 1 ;
;;

type coucou = A of int | B of int * int | C
;;


let g = function
  | (A x | B (_,x)) -> x
  | C -> 0
;;


test "dix" g (A 1) 1 ;
test "dix" g (B (1,2)) 2 ;
;;



let h = function
  | ([x]|[1 ; x ]|[1 ; 2 ; x]) -> x
  | _ -> 0
;;

test "encore" h [1] 1 ;
test "encore" h [1;2] 2 ;
test "encore" h [1;2;3] 3 ;
test "encore" h [0 ; 0] 0 ; ()
;;

let f = function
| (x,(0 as y)) | (y,x) -> y-x
;;

test "foo" f (1,0) (-1);
test "foo" f (1,2) (-1)
;;


let f = function (([]|[_]) as x)|(_::([] as x))|(_::_::x)  -> x
;;

test "zob" f [] [] ;
test "zob" f [1] [1] ;
test "zob" f [1;2;3] [3]
;;


type zob = A | B | C | D of zob * int | E of zob * zob

let rec f = function
  | (A | B | C) -> A
  | D (x,i) -> D (f x,i)
  | E (x,_) -> D (f x,0)
;;


test "fin" f B A ;
test "fin" f (D (C,1)) (D (A,1)) ;
test "fin" f (E (C,A)) (D (A,0)) ; ()
;;

type length = 
    Char of int | Pixel of int | Percent of int | No of string | Default

let length = function
  | Char n -> n | Pixel n -> n
  | _       -> 0
;;

test "length" length (Char 10) 10 ;
test "length" length (Pixel 20) 20 ;
test "length" length Default 0 ;
test "length" length (Percent 100) 0 ; ()
;;

let length2 = function
  | Char n -> n | Percent n -> n
  | _       -> 0
;;

test "length2" length2 (Char 10) 10 ;
test "length2" length2 (Pixel 20) 0 ;
test "length2" length2 Default 0 ;
test "length2" length2(Percent 100) 100 ; ()
;;

let length3 = function
  | Char _ | No _ -> true
  | _ -> false
;;

test "length3" length3 (Char 10) true ;
test "length3" length3 (No "") true ;
test "length3" length3 (Pixel 20) false ;
test "length3" length3 Default false ;
test "length3" length3(Percent 100) false ; ()
;;

type hevea = A | B | C

let h x = match x with
| A -> 1
| B|C -> 2
;;

test "hevea" h A 1 ;
test "hevea" h B 2 ;
test "hevea" h B 2 ; ()
;;
type lambda =
    Lvar of int
  | Lconst of int
  | Lapply of lambda * lambda list
  | Lfunction of bool  * int list * lambda
  | Llet of  bool * int * lambda * lambda
  | Lletrec of (int * lambda) list * lambda
  | Lprim of string * lambda list
  | Lswitch of lambda * lambda_switch
  | Lstaticfail
  | Lcatch of lambda * lambda
  | Lstaticraise of int * lambda list
  | Lstaticcatch of lambda * (int * int list) * lambda
  | Ltrywith of lambda * int * lambda
  | Lifthenelse of lambda * lambda * lambda
  | Lsequence of lambda * lambda
  | Lwhile of lambda * lambda
  | Lfor of int * lambda * lambda * bool * lambda
  | Lassign of int * lambda
  | Lsend of lambda * lambda * lambda list
  | Levent of lambda * lambda_event
  | Lifused of int * lambda
and lambda_switch =
  { sw_numconsts: int;                  (* Number of integer cases *)
    sw_consts: (int * lambda) list;     (* Integer cases *)
    sw_numblocks: int;                  (* Number of tag block cases *)
    sw_blocks: (int * lambda) list;     (* Tag block cases *)
    sw_checked: bool ;                  (* True if bound checks needed *)
    sw_nofail: bool}                    (* True if should not fail *)
and lambda_event =
  { lev_loc: int;
    lev_kind: bool ;
    lev_repr: int ref option;
    lev_env: int list }

let rec approx_present v l = true

let rec lower_bind v arg lam = match lam with
| Lifthenelse (cond, ifso, ifnot) -> 1
| Lswitch (ls,({sw_consts=[i,act] ; sw_blocks = []} as sw))
    when not (approx_present v ls) -> 2
| Lswitch (ls,({sw_consts=[] ; sw_blocks = [i,act]} as sw))
    when not (approx_present v ls) -> 3
| Llet (true , vv, lv, l) -> 4
| _ -> 5
;;

test "lower_bind" (lower_bind 0 0) (Llet (true,0, Lvar 1, Lvar 2)) 4 ;
test "lower_bind" (lower_bind 0 0) (Lvar 0) 5 ;
test "lower_bind" (lower_bind 0 0) (Lifthenelse (Lvar 0, Lvar 1, Lvar 2)) 1
;;


type field_kind =
    Fvar of field_kind option ref
  | Fpresent
  | Fabsent

let unify_kind (k1, k2) =  match k1, k2 with
    (Fvar r, (Fvar _ | Fpresent))             -> 1
  | (Fpresent, Fvar r)                        -> 2
  | (Fpresent, Fpresent)                      -> 3
  | _                                         -> 4


let r = ref (Some Fpresent)
;;

test "unify"  unify_kind (Fvar r, Fpresent) 1 ;
test "unify"  unify_kind (Fvar r, Fvar r) 1 ;
test "unify"  unify_kind (Fvar r, Fabsent) 4 ;
test "unify"  unify_kind (Fpresent, Fvar r) 2 ;
test "unify"  unify_kind (Fpresent, Fpresent) 3 ;
test "unify"  unify_kind (Fabsent, Fpresent) 4 ; ()
;;


type youyou = A | B | C | D of youyou

let foo (k1, k2) = match k1,k2 with
| D _, (A|D _) -> 1
| (A|B),D _ -> 2
| C,_       -> 3
| _, (A|B|C) -> 4
;;

test "foo" foo (D A,A) 1 ;
test "foo" foo (D A,B) 4 ;
test "foo" foo (A,A) 4 ; ()
;;

type yaya = A | B
;;

let yaya = function
| A,_,_ -> 1
| _,A,_ -> 2
| B,B,_ -> 3
| A,_,(100|103) -> 5
;;

test "yaya" yaya (A,A,0) 1 ;
test "yaya" yaya (B,A,0) 2 ;
test "yaya" yaya (B,B,100) 3 ; ()
;;

(*
let yoyo =  function
| [],_,_ -> 1
| _,[],_ -> 2
| _::_,_::_,_ -> 3
| [],_,(100|103|104) -> 5
| [],_,(100|103) -> 6
| [],_,(1000|1001|1002|20000) -> 7
;;

test "yoyo" yoyo ([],[],0) 1 ;
test "yoyo" yoyo ([1],[],0) 2 ;
test "yoyo" yoyo ([1],[1],100) 3 ; ()
;;

let youyou = function
  | (100|103|104) -> 1
  | (100|103|101) -> 2
  | (1000|1001|1002|20000) -> 3
  | _ -> -1
;;

test "youyou" youyou 100 1 ;
test "youyou" youyou 101 2 ;
test "youyou" youyou 1000 3
;;
*)
type autre =
  |  C | D | E of autre | F of autre * autre | H of autre | I | J | K of string

let rec autre = function
| C,_,_ -> 1
| _,C,_ -> 2
| D,D,_ -> 3
| (D|F (_,_)|H _|K _),_,_ -> 4
| (_, (D|I|E _|F (_, _)|H _|K _), _) -> 8
| (J,J,((C|D) as x |E x|F (_,x))) | (J,_,((C|J) as x)) -> autre (x,x,x)
| (J, J, (I|H _|K _)) -> 9
| I,_,_ -> 6
| E _,_,_ -> 7
;;

test "autre" autre (J,J,F (D,D)) 3 ;
test "autre" autre (J,J,D) 3 ;
test "autre" autre (J,J,I) 9 ;
test "autre" autre (H I,I,I) 4 ;
test "autre" autre (J,J,H I) 9 ; ()
;;


type youpi = YA | YB | YC
and hola = X | Y | Z | T of hola | U of hola | V of hola

let xyz = function
| YA,_,_ -> 1
| _,YA,_ -> 2
| YB,YB,_ -> 3
| ((YB|YC), (YB|YC), (X|Y|Z|V _|T _)) -> 6
| _,_,(X|U _) -> 8
| _,_,Y -> 5
;;

test "xyz" xyz (YC,YC,X) 6 ;
test "xyz" xyz (YC,YB,U X) 8 ;
test "xyz" xyz (YB,YC,X) 6 ; ()
;;


(* Ce test est pour le compilo lui-meme *)
let eq (x,y) = x=y
;;

test "eq" eq ("coucou", "coucou") true ; ()
;;

(* Test des gardes, non trivial *)

let is_none = function
  | None -> true
  | _ -> false

let garde x = match x with
| (Some _, _) when is_none (snd x) -> 1
| (Some (pc, _), Some pc') when pc = pc' -> 2
| _ -> 3
;;

test "garde" garde (Some (1,1),None) 1 ;
test "garde" garde (Some (1,1),Some 1) 2 ;
test "garde" garde (Some (2,1),Some 1) 3 ; ()
;;

let orstring = function
  | ("A"|"B"|"C") -> 2
  | "D" -> 3
  | _ -> 4
;;

test "orstring" orstring "A" 2 ;
test "orstring" orstring "B" 2 ;
test "orstring" orstring "C" 2 ;
test "orstring" orstring "D" 3 ;
test "orstring" orstring "E" 4 ; ()
;;

type var_t = [`Variant of [ `Some of string | `None | `Foo] ]

let crash (pat:var_t) =
      match pat with
      | `Variant (`Some tag) -> tag
      | `Variant (`None) -> "none"
      | _ -> "foo"

;;

test "crash" crash (`Variant `None) "none" ;
test "crash" crash (`Variant (`Some "coucou")) "coucou" ;
test "crash" crash (`Variant (`Foo)) "foo" ; ()
;;

let flatgarde c =
let x,y = c in
match x,y with
| (1,2)|(2,3) when y=2 -> 1
| (1,_)|(_,3) -> 2
| _ -> 3
;;

test "flatgarde" flatgarde (1,2) 1 ;
test "flatgarde" flatgarde (1,3) 2 ;
test "flatgarde" flatgarde (2,3) 2 ;
test "flatgarde" flatgarde (2,4) 3 ; ()
;;


(* Les bugs de jerome *)
type f =
  | ABSENT 
  | FILE
  | SYMLINK
  | DIRECTORY

type r =
  | Unchanged
  | Deleted
  | Modified
  | PropsChanged
  | Created

let replicaContent2shortString rc =
    let (typ, status) = rc in
    match typ, status with
      _, Unchanged             -> "        "
    | ABSENT, Deleted         -> "deleted "
    | FILE, Created           -> "new file"
    | FILE, Modified          -> "changed "
    | FILE, PropsChanged      -> "props   "
    | SYMLINK, Created        -> "new link"
    | SYMLINK, Modified       -> "chgd lnk"
    | DIRECTORY, Created      -> "new dir "
    | DIRECTORY, Modified     -> "chgd dir"
    | DIRECTORY, PropsChanged -> "props   "
    (* Cases that can't happen... *)

    | ABSENT, (Created | Modified | PropsChanged)
    | SYMLINK, PropsChanged
    | (FILE|SYMLINK|DIRECTORY), Deleted
                                -> "assert false"
;;


test "jerome_constr" 
   replicaContent2shortString (ABSENT, Unchanged) "        " ;
test "jerome_constr" 
   replicaContent2shortString (ABSENT, Deleted) "deleted " ;
test "jerome_constr" 
   replicaContent2shortString (FILE, Modified) "changed " ;
test "jerome_constr" 
   replicaContent2shortString (DIRECTORY, PropsChanged) "props   " ;
test "jerome_constr" 
   replicaContent2shortString (FILE, Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (SYMLINK, Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (SYMLINK, PropsChanged) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (DIRECTORY, Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (ABSENT, Created) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (ABSENT, Modified) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (ABSENT, PropsChanged) "assert false" ;
;;


let replicaContent2shortString rc =
    let (typ, status) = rc in
    match typ, status with
      _, `Unchanged             -> "        "
    | `ABSENT, `Deleted         -> "deleted "
    | `FILE, `Created           -> "new file"
    | `FILE, `Modified          -> "changed "
    | `FILE, `PropsChanged      -> "props   "
    | `SYMLINK, `Created        -> "new link"
    | `SYMLINK, `Modified       -> "chgd lnk"
    | `DIRECTORY, `Created      -> "new dir "
    | `DIRECTORY, `Modified     -> "chgd dir"
    | `DIRECTORY, `PropsChanged -> "props   "
    (* Cases that can't happen... *)

    | `ABSENT, (`Created | `Modified | `PropsChanged)
    | `SYMLINK, `PropsChanged
    | (`FILE|`SYMLINK|`DIRECTORY), `Deleted
                                -> "assert false"
;;


test "jerome_constr" 
   replicaContent2shortString (`ABSENT, `Unchanged) "        " ;
test "jerome_constr" 
   replicaContent2shortString (`ABSENT, `Deleted) "deleted " ;
test "jerome_constr" 
   replicaContent2shortString (`FILE, `Modified) "changed " ;
test "jerome_constr" 
   replicaContent2shortString (`DIRECTORY, `PropsChanged) "props   " ;
test "jerome_constr" 
   replicaContent2shortString (`FILE, `Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`SYMLINK, `Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`SYMLINK, `PropsChanged) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`DIRECTORY, `Deleted) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`ABSENT, `Created) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`ABSENT, `Modified) "assert false" ;
test "jerome_constr" 
   replicaContent2shortString (`ABSENT, `PropsChanged) "assert false" ;
;;

(* bug 319 *)

type ab = A of int | B of int
type cd = C | D

let ohl = function
  | (A (p) | B (p)), C -> p
  | (A (p) | B (p)), D -> p
;;

test "ohl" ohl (A 0,C) 0 ;
test "ohl" ohl (B 0,D) 0 ; ()
;;

(* bug 324 *)
type pottier =
  | A
  | B
;;

let pottier x =
  match x with
  | (( (A, 1) | (B, 2)),A) -> false
  | _ -> true
;;

test "pottier" pottier ((B,2),A) false ;
test "pottier" pottier ((B,2),B) true ;
test "pottier" pottier ((A,2),A) true ; ()
;;

(* bug 325 in bytecode compiler *)
let coquery q =  match q with
| y,0,([modu;defs]| [defs;modu;_]) -> y+defs-modu
| _ -> 0
;;

test "coquery" coquery (1,0,[1 ; 2 ; 3]) 0 ;
test "coquery" coquery (1,0,[1 ; 2]) 2 ; ()
;;

(*
  Two other variable in or-pat tests
*)
type vars = A of int | B of (int * int) | C
;;


let vars1 = function
  | (A x | B (_,x)) -> x
  | C -> 0
;;

test "vars1" vars1 (A 1) 1 ;
test "vars1" vars1 (B (1,2)) 2 ; ()
;;

let vars2 = function
  | ([x]|[1 ; x ]|[1 ; 2 ; x]) -> x
  | _ -> 0
;;

test"vars2" vars2 [1] 1 ;
test"vars2" vars2 [1;2] 2 ;
test"vars2" vars2 [1;2;3] 3 ;
test"vars2" vars2 [0 ; 0] 0 ; ()
;;

(* Bug 342 *)
type eber = {x:int; y: int; z:bool}

let eber = function
  | {x=a; z=true}
  | {y=a; z=false} -> a
;;

test "eber" eber {x=0 ; y=1 ; z=true} 0 ;
test "eber" eber {x=1 ; y=0 ; z=false} 0 ; ()
;;


(* Enchainement des test d'intervalle *)

let escaped = function
  | '"' | '\\' | '\n' | '\t' -> 2
  | c -> 1
;;

test "escaped" escaped '"' 2 ;
test "escaped" escaped '\\' 2 ;
test "escaped" escaped '\n' 2 ;
test "escaped" escaped '\t' 2 ;
test "escaped" escaped '\000' 1 ;
test "escaped" escaped ' ' 1 ;
test "escaped" escaped '\000' 1 ;
test "escaped" escaped '[' 1 ;
test "escaped" escaped ']' 1 ;
test "escaped" escaped '!' 1 ;
test "escaped" escaped '#' 1 ;
()
;;

(* For compilation speed (due to J. Garigue) *)
exception Unknown_Reply of int

type command_reply =
   RPL_TRYAGAIN
 | RPL_TRACEEND
 | RPL_TRACELOG
 | RPL_ADMINEMAIL
 | RPL_ADMINLOC2
 | RPL_ADMINLOC1
 | RPL_ADMINME
 | RPL_LUSERME
 | RPL_LUSERCHANNELS
 | RPL_LUSERUNKNOWN
 | RPL_LUSEROP
 | RPL_LUSERCLIENT
 | RPL_STATSDLINE
 | RPL_STATSDEBUG
 | RPL_STATSDEFINE
 | RPL_STATSBLINE
 | RPL_STATSPING
 | RPL_STATSSLINE
 | RPL_STATSHLINE
 | RPL_STATSOLINE
 | RPL_STATSUPTIME
 | RPL_STATSLLINE
 | RPL_STATSVLINE
 | RPL_SERVLISTEND
 | RPL_SERVLIST
 | RPL_SERVICE
 | RPL_ENDOFSERVICES
 | RPL_SERVICEINFO
 | RPL_UMODEIS
 | RPL_ENDOFSTATS
 | RPL_STATSYLINE
 | RPL_STATSQLINE
 | RPL_STATSKLINE
 | RPL_STATSILINE
 | RPL_STATSNLINE
 | RPL_STATSCLINE
 | RPL_STATSCOMMANDS
 | RPL_STATSLINKINFO
 | RPL_TRACERECONNECT
 | RPL_TRACECLASS
 | RPL_TRACENEWTYPE
 | RPL_TRACESERVICE
 | RPL_TRACESERVER
 | RPL_TRACEUSER
 | RPL_TRACEOPERATOR
 | RPL_TRACEUNKNOWN
 | RPL_TRACEHANDSHAKE
 | RPL_TRACECONNECTING
 | RPL_TRACELINK
 | RPL_NOUSERS
 | RPL_ENDOFUSERS
 | RPL_USERS
 | RPL_USERSSTART
 | RPL_TIME
 | RPL_NOTOPERANYMORE
 | RPL_MYPORTIS
 | RPL_YOURESERVICE
 | RPL_REHASHING
 | RPL_YOUREOPER
 | RPL_ENDOFMOTD
 | RPL_MOTDSTART
 | RPL_ENDOFINFO
 | RPL_INFOSTART
 | RPL_MOTD
 | RPL_INFO
 | RPL_ENDOFBANLIST
 | RPL_BANLIST
 | RPL_ENDOFLINKS
 | RPL_LINKS
 | RPL_CLOSEEND
 | RPL_CLOSING
 | RPL_KILLDONE
 | RPL_ENDOFNAMES
 | RPL_NAMREPLY
 | RPL_ENDOFWHO
 | RPL_WHOREPLY
 | RPL_VERSION
 | RPL_SUMMONING
 | RPL_INVITING
 | RPL_TOPIC
 | RPL_NOTOPIC
 | RPL_CHANNELMODEIS
 | RPL_LISTEND
 | RPL_LIST
 | RPL_LISTSTART
 | RPL_WHOISCHANNELS
 | RPL_ENDOFWHOIS
 | RPL_WHOISIDLE
 | RPL_WHOISCHANOP
 | RPL_ENDOFWHOWAS
 | RPL_WHOWASUSER
 | RPL_WHOISOPERATOR
 | RPL_WHOISSERVER
 | RPL_WHOISUSER
 | RPL_NOWAWAY
 | RPL_UNAWAY
 | RPL_TEXT
 | RPL_ISON
 | RPL_USERHOST
 | RPL_AWAY
 | RPL_NONE

let get_command_reply n =
match n with
   263    ->     RPL_TRYAGAIN
 | 319    ->     RPL_WHOISCHANNELS
 | 318    ->     RPL_ENDOFWHOIS
 | 317    ->     RPL_WHOISIDLE
 | 316    ->     RPL_WHOISCHANOP
 | 369    ->     RPL_ENDOFWHOWAS
 | 314    ->     RPL_WHOWASUSER
 | 313    ->     RPL_WHOISOPERATOR
 | 312    ->     RPL_WHOISSERVER
 | 311    ->     RPL_WHOISUSER
 | 262    ->     RPL_TRACEEND
 | 261    ->     RPL_TRACELOG
 | 259    ->     RPL_ADMINEMAIL
 | 258    ->     RPL_ADMINLOC2
 | 257    ->     RPL_ADMINLOC1
 | 256    ->     RPL_ADMINME
 | 255    ->     RPL_LUSERME
 | 254    ->     RPL_LUSERCHANNELS
 | 253    ->     RPL_LUSERUNKNOWN
 | 252    ->     RPL_LUSEROP
 | 251    ->     RPL_LUSERCLIENT
 | 250    ->     RPL_STATSDLINE
 | 249    ->     RPL_STATSDEBUG
 | 248    ->     RPL_STATSDEFINE
 | 247    ->     RPL_STATSBLINE
 | 246    ->     RPL_STATSPING
 | 245    ->     RPL_STATSSLINE
 | 244    ->     RPL_STATSHLINE
 | 243    ->     RPL_STATSOLINE
 | 242    ->     RPL_STATSUPTIME
 | 241    ->     RPL_STATSLLINE
 | 240    ->     RPL_STATSVLINE
 | 235    ->     RPL_SERVLISTEND
 | 234    ->     RPL_SERVLIST
 | 233    ->     RPL_SERVICE
 | 232    ->     RPL_ENDOFSERVICES
 | 231    ->     RPL_SERVICEINFO
 | 221    ->     RPL_UMODEIS
 | 219    ->     RPL_ENDOFSTATS
 | 218    ->     RPL_STATSYLINE
 | 217    ->     RPL_STATSQLINE
 | 216    ->     RPL_STATSKLINE
 | 215    ->     RPL_STATSILINE
 | 214    ->     RPL_STATSNLINE
 | 213    ->     RPL_STATSCLINE
 | 212    ->     RPL_STATSCOMMANDS
 | 211    ->     RPL_STATSLINKINFO
 | 210    ->     RPL_TRACERECONNECT
 | 209    ->     RPL_TRACECLASS
 | 208    ->     RPL_TRACENEWTYPE
 | 207    ->     RPL_TRACESERVICE
 | 206    ->     RPL_TRACESERVER
 | 205    ->     RPL_TRACEUSER
 | 204    ->     RPL_TRACEOPERATOR
 | 203    ->     RPL_TRACEUNKNOWN
 | 202    ->     RPL_TRACEHANDSHAKE
 | 201    ->     RPL_TRACECONNECTING
 | 200    ->     RPL_TRACELINK
 | 395    ->     RPL_NOUSERS
 | 394    ->     RPL_ENDOFUSERS
 | 393    ->     RPL_USERS
 | 392    ->     RPL_USERSSTART
 | 391    ->     RPL_TIME
 | 385    ->     RPL_NOTOPERANYMORE
 | 384    ->     RPL_MYPORTIS
 | 383    ->     RPL_YOURESERVICE
 | 382    ->     RPL_REHASHING
 | 381    ->     RPL_YOUREOPER
 | 376    ->     RPL_ENDOFMOTD
 | 375    ->     RPL_MOTDSTART
 | 374    ->     RPL_ENDOFINFO
 | 373    ->     RPL_INFOSTART
 | 372    ->     RPL_MOTD
 | 371    ->     RPL_INFO
 | 368    ->     RPL_ENDOFBANLIST
 | 367    ->     RPL_BANLIST
 | 365    ->     RPL_ENDOFLINKS
 | 364    ->     RPL_LINKS
 | 363    ->     RPL_CLOSEEND
 | 362    ->     RPL_CLOSING
 | 361    ->     RPL_KILLDONE
 | 366    ->     RPL_ENDOFNAMES
 | 353    ->     RPL_NAMREPLY
 | 315    ->     RPL_ENDOFWHO
 | 352    ->     RPL_WHOREPLY
 | 351    ->     RPL_VERSION
 | 342    ->     RPL_SUMMONING
 | 341    ->     RPL_INVITING
 | 332    ->     RPL_TOPIC
 | 331    ->     RPL_NOTOPIC
 | 324    ->     RPL_CHANNELMODEIS
 | 323    ->     RPL_LISTEND
 | 322    ->     RPL_LIST
 | 321    ->     RPL_LISTSTART
 | 306    ->     RPL_NOWAWAY
 | 305    ->     RPL_UNAWAY
 | 304    ->     RPL_TEXT
 | 303    ->     RPL_ISON
 | 302    ->     RPL_USERHOST
 | 301    ->     RPL_AWAY
 | 300    ->     RPL_NONE
 | _ -> raise (Unknown_Reply n)

(* Bug 454 *)
type  habert_a=
  | A of habert_c
  | B of habert_c
  
and habert_c= {lvar:int; lassoc: habert_c;lnb:int} 
  
  
let habert=function
  | (A {lnb=i}|B {lnb=i}) when i=0 -> 1
  | A {lassoc=({lnb=j});lnb=i} -> 2
  | _ -> 3
;;

let rec ex0 = {lvar=0 ; lnb=0 ; lassoc=ex1}
and ex1 = {lvar=1 ; lnb=1 ; lassoc=ex0} in

test "habert" habert (A ex0) 1 ;
test "habert" habert (B ex0) 1 ;
test "habert" habert (A ex1) 2 ;
test "habert" habert (B ex1) 3 ;

(* Problems with interval test in arithmetic mod 2^31, bug #359 *)
(* From manuel Fahndrich *)

type type_expr = [
  | `TTuple of type_expr list
  | `TConstr of type_expr list
  | `TVar of string
  | `TVariant of string list
  | `TBlock of int
  | `TCopy of type_expr
  ] 

and recurs_type_expr = [
  | `TTuple of type_expr list
  | `TConstr of type_expr list
  | `TVariant of string list
  ] 


let rec maf te =
    match te with
    | `TCopy te -> 1
    | `TVar _ -> 2
    | `TBlock _ -> 2
    | #recurs_type_expr as desc ->

        let te =
          (match desc with
            `TTuple tl ->
              4
          | `TConstr tl ->
              5
          | `TVariant (row) ->
              6
                )
        in

        te
;;

let base = `TBlock 0
;;

test "maf" maf (`TCopy base) 1 ;
test "maf" maf (`TVar "test") 2 ;
test "maf" maf (`TBlock 0) 2 ;
test "maf" maf (`TTuple []) 4 ;
test "maf" maf (`TConstr []) 5 ;
test "maf" maf (`TVariant []) 6
;;

(* PR#1310
  Using ``get_args'' in place or an ad-hoc ``matcher'' function for tuples.
  Has made the compiler [3.05] to fail.
*)
type t_seb = Uin | Uout
;;

let rec seb = function
  | ((i, Uin) | (i, Uout)), Uout -> 1
  | ((j, Uin) | (j, Uout)), Uin ->  2
;;

test "seb" seb ((0,Uin),Uout) 1 ;
test "seb" seb ((0,Uout),Uin) 2 ;
()
;;

(* Talk with Jacques
     - type 'b is still open ??
     - better case generation, accept intervals of size 1 when ok_inter is
       false (in Switch)
*)

(*
File "morematch.ml", line 1060, characters 8-65:
Warning: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
A `D
*)
type ('a, 'b) t_j = A of 'a | B of 'b * 'a | C

let f = function
  | A (`A|`C) -> 0
  | B (`B,`D) -> 1
  | C -> 2

let g x = try f x with Match_failure _ -> 3

let _ =
  test "jacques" g (A `A) 0 ;
  test "jacques" g (A `C) 0 ;
  test "jacques" g (B (`B,`D)) 1 ;
  test "jacaues" g C 2 ;
(*  test "jacques" g (B (`A,`D)) 3 ; (* type incorrect expected behavior ? *)*)
  ()

(*
  Compilation bug, segfault, because of incorrect compilation
  of unused match case .. -> "11"
*)

type t_l = A | B

let f = function
  |  _, _, _, _, _, _, _, _, _, _, _, _, _, B, _, _ -> "0"
  |  _, _, _, B, A, _, _, _, _, _, _, _, _, _, _, _ -> "1"
  |  _, _, _, B, _, A, _, _, A, _, _, _, _, _, _, _ -> "2"
  |  _, _, _, _, _, _, _, _, _, _, B, A, _, A, _, _ -> "3"
  |  _, _, _, _, _, _, _, B, _, _, _, _, B, _, A, A -> "4"
  |  A, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ -> "5"
  |  _, _, _, _, _, _, _, B, _, B, _, _, _, _, _, _ -> "6"
  |  _, B, _, _, _, _, _, _, _, _, _, _, _, _, _, _ -> "7"
  |  _, A, A, _, A, _, B, _, _, _, _, _, _, _, _, B -> "8"
  |  _, _, _, _, B, _, _, _, _, _, _, _, _, _, B, _ -> "9"
  |  _, _, _, _, _, _, _, _, _, _, _, B, _, _, _, _ -> "10"
  |  _, _, _, _, _, A, _, _, _, _, B, _, _, _, _, _ -> "11"
  |  B, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ -> "12"
  |  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ -> "13"

(*
File "morematch.ml", line 1094, characters 5-51:
Warning: this match case is unused.
File "morematch.ml", line 1096, characters 5-51:
Warning: this match case is unused.
*)
let _  =
  test "luc"  f (B, A, A, A, A, A, A, A, A, A, A, B, A, A, A, A) "10" ;
  test "luc"  f (B, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A) "12" ;
 ()

let double = fun f x -> f (f x);;

let quad x  = double double  x;;
let oct x = quad quad x;;


let succ x = x + 1;;

let rec repeat n =
  if n <= 0 then 0 else (repeat (n-1); double oct succ 1)
;;

print_int (repeat 10 );;
print_newline();;


exception Failure of string;;
let failwith s = raise (Failure s);;
let rec it_list f r l = match l with [] -> r | h::t -> it_list f (f r h) t
;;


let list_it f l b =
  let rec list_it_f = function [] -> b | (a::l) -> (f a (list_it_f l))
  in
     list_it_f l;;


(*  Author:  Guy Cousineau                                             *)
(*  Creation: 18/6/923                                                 *)
(*  Updates:							       *)
(*  This file contains a bench using avl trees                         *)


(* A type to deal with preorders  *)
type comparison = Smaller | Equiv | Greater;;

(* Turns a pair (lt,eq)  (strict order + equivalence
into a preorder   *)

(*
let mk_order ord  (x,y) =
   if ord x y  then Smaller
              else if x=y  then Equiv else Greater;;   (* OK *)
*)

let mk_preorder(lt,eq) (x,y) =
   if lt x y  then Smaller
              else if eq x y  then Equiv else Greater;;

(*  Various ad-hoc functions *)
let inv_rel c = function (x,y) -> match c(x,y) with
                                    Smaller -> Greater
                                  | Greater -> Smaller
                                  | Equiv   -> Equiv;;
let app_left f (x,y) =(f x,y);;
let app_right f (x,y) =(x,f y);;
let app_both f (x,y) = (f x,f y);;

type equiv_option = Take_Old | Take_New | Abort;;


let max_int x1 x2 = if x1 < x2 then x2 else x1;;
let id x=x;;

(*
let int_comp = mk_preorder(prefix <,prefix =);;
*)

(* #infix "o";; *)
let  o f g x = f(g x);;


(*  The type for binary trees *)
type 'a btree = Empty | Bin of 'a btree_node
and 'a btree_node = {info:'a ; left:'a btree ; right:'a btree};;


(*  various binary trees iterators  *)			 
				   

let rec btree_it f t x =
match t with 

   Empty ->  x
| Bin {info=a;left=t1;right=t2} 

       ->  btree_it f t1 (f a (btree_it f t2 x));;

let rec it_btree f x =
function
   Empty     -> x
| Bin {info=a;left=t1;right=t2}  

           ->  it_btree f  (f (it_btree f x t1) a) t2;;

let rec pre_btree_it f t x =
match t with 

   Empty ->  x
| Bin {info=a;left=t1;right=t2} 

       ->  pre_btree_it f t1 (pre_btree_it f t2 (f a x));;

let rec pre_it_btree f x =
function
   Empty     -> x
| Bin {info=a;left=t1;right=t2}  

           ->  pre_it_btree f  (pre_it_btree f (f x a) t1) t2;;

let rec post_btree_it f t x =
match t with 

   Empty ->  x
| Bin {info=a;left=t1;right=t2} 

       ->  f a (post_btree_it f t1 (post_btree_it f t2 x));;

let rec post_it_btree f x =
function
   Empty     -> x
| Bin {info=a;left=t1;right=t2}  

           ->  f (post_it_btree f  (post_it_btree f x t1) t2) a;;


(*  General tree  depth-first traversals   *)
type orientation = Left_to_right | Right_to_left;;
type visit_order = Prefix | Infix | Postfix;;
let flat_btree spec f t = 

  let consf = fun x l -> f x :: l
  and xconsf = fun l x -> f x :: l
  in
    match spec with
      (Left_to_right,Prefix)    -> pre_btree_it consf t []
    | (Left_to_right,Infix) -> btree_it consf t []
    | (Left_to_right,Postfix)   -> post_btree_it consf t []
    | (Right_to_left,Prefix)    -> pre_it_btree xconsf [] t
    | (Right_to_left,Infix) -> it_btree xconsf [] t
    | (Right_to_left,Postfix)   -> post_it_btree xconsf [] t;;


let btree_hom f  v  = 
let rec hom = function
     Bin {info=a;left=t1;right=t2}
         -> f(a,hom t1,hom t2)
  |  Empty -> v in
hom;;
  

let btree_depth x = btree_hom  (fun (_,x1,x2) -> 1+ max_int x1 x2) 0 x;;
(* let btree_size =  btree_hom (fun (_,x1,x2) -> 1+x1+x2) 0;; *)
let rec btree_size  =
function     Empty ->  0
  | (Bin {info=a;left=t1;right=t2} )
       ->  1+btree_size t1+btree_size t2;;


let map_btree f = btree_hom
                    (fun (a,t1,t2) -> Bin{info=f a;left=t1;right=t2})
                    Empty;;

let mirror_btree x = btree_hom
                     (fun (a,t1,t2) -> Bin{info=a;left=t2;right=t1})
                     Empty x;;


let btree_trav f g  = 
let rec trav n = 

function
     Bin {info=a;left=t1;right=t2}
         -> f(n,a,trav (n+1) t1,trav (n+1) t2)
  |  Empty -> g(n)
in trav 0;;


let do_btree spec h t=
  let h1 x y = h x;()
  and h2 x y = h y;()
  in
    match spec with
      (Left_to_right,Prefix)    -> pre_it_btree h2 () t
    | (Left_to_right,Infix)     -> it_btree h2 () t
    | (Left_to_right,Postfix)   -> post_it_btree h2 () t
    | (Right_to_left,Prefix)    -> pre_btree_it h1 t ()
    | (Right_to_left,Infix)     -> btree_it h1 t ()
    | (Right_to_left,Postfix)   -> post_btree_it h1 t ();;



let do_btree_left f = 
let rec do_b =
function
  Empty   ->   ()
| Bin {info=a;left=t1;right=t2}  

    ->  do_b t1;f a; do_b t2
in do_b;;

let do_btree_right f = 
let rec do_b =
function
  Empty   ->   ()
| Bin {info=a;left=t1;right=t2}  

    ->  do_b t2;f a; do_b t1
in do_b;;


(*  Functions for binary search trees  *)
(*  The firts argument is a preorder   *)

let rec is_bst c =
 function  Empty  -> true
(*         | Bin {info=_;left=Empty;right=Empty}   

               ->  true  *)
	|   Bin{info=x;left=(Bin{info=y;} as t);right=Empty}
               -> not(c(y,x)=Greater) & is_bst c t
	|   Bin{info=x;left=Empty;right=(Bin{info=y;} as t)}
               -> not(c(x,y)=Greater) & is_bst c t
	|   Bin{info=x;left=(Bin{info=y;} as t1);
                   right=(Bin{info=z;} as t2)}
               -> not(c(y,x)=Greater) & not(c(x,z)=Greater)
                    & is_bst c t1 & is_bst c t2;;


let find_bst comp answer e = 
let rec search =
function    Empty    ->  failwith  "binary search failed"
       | Bin{info=x;left=t1;right=t2}  

            ->  match comp(e,x) with
                   Equiv -> answer x
                | Smaller -> search t1
                | Greater -> search t2
in search;;

let belongs_to_bst comp  e = 
let  rec search =
function    Empty    ->  false
       | Bin{info=x;left=t1;right=t2}  

            ->  match comp(e,x) with
                   Equiv -> true
                | Smaller -> search t1
                | Greater -> search t2
in search;;


let change_bst comp modify e = 
let rec change =
function    Empty    ->  failwith  "binary search failed"
       | Bin{info=x;left=t1;right=t2}  

            ->  (match comp(e,x) with
                  Equiv  ->  Bin{info=modify x;left=t1;right=t2}  

                | Smaller -> Bin{info=x;left= change t1;right=t2}
                | Greater -> Bin{info=x;left=t1;right=change t2})
in change;;


let rec add_bottom_to_bst opt comp t e = 
let rec add =
function
  Empty   ->   Bin{info=e;left=Empty;right=Empty}
| (Bin{info=x;left=t1;right=t2} as t)
    -> (match comp(e,x),opt with
          (Equiv,Abort) -> failwith "Abort due to equiv option"
        | (Equiv,Take_Old) -> t
        | (Equiv,Take_New) -> Bin{info=e;left=t1;right=t2}
        | (Smaller,_) -> Bin{info=x;left=add t1;right=t2}
        | (Greater,_) -> Bin{info=x;left=t1;right=add t2})
in add t;;

   

let add_list_bottom_to_bst opt c = 

        it_list (add_bottom_to_bst opt c);;

let mk_bst opt c  = add_list_bottom_to_bst opt c Empty;;


let rec remove_biggest =  

function
  Bin{info=a;left=t1;right=Empty}   

        ->   (a,t1)
| Bin{info=a;left=t1;right=t2}     

        ->   let  (a_prime,t_prime) = remove_biggest t2
             in  (a_prime, Bin{info=a;left=t1;right=t_prime})
| Empty   -> failwith "Cannot remove element from empty tree";;
				      

let  rec rem_root_from_bst comp   = 

function
   Empty    ->    failwith  "binary search failed"
|  Bin {info=_;left=t1;right=t2} 

            -> let  (a_prime,t_prime) = remove_biggest  t1
               in   Bin{info=a_prime;left=t_prime;right=t2};;

let  rec rem_from_bst comp e  = 
let  rec rem =
function
   Empty    ->    failwith  "binary search failed"
|  (Bin {info=a;left=t1;right=t2} as t)
            -> 

      (match comp(e,a) with
       Equiv ->  rem_root_from_bst comp t
     | Smaller ->   Bin{info=a;left= rem t1;right= t2}
     | Greater ->   Bin{info=a;left=t1;right= rem t2})
in rem;;
					      

let rem_list_from_bst c = list_it (rem_from_bst c);;


let rec cut_bst comp e =
let rec cut =
function
   Empty   -> (Empty,e,Empty)
| Bin{info=a;left=t1;right=t2}  

       -> (match comp(e,a) with
             Smaller   ->  let (t,e_prime,t_prime) = cut t1
                           in (t,e_prime,Bin{info=a;left=t_prime;right=t2})
           | Equiv     ->  (t1,a,t2)
           | Greater   -> let (t,e_prime,t_prime) = cut t2
                          in (Bin{info=a;left=t1;right=t},e_prime,t_prime))
in cut
;;
					  

					  

let add_root_to_bst opt comp e b =
   let  t1,e_prime,t2 = cut_bst comp e b 

   in  Bin{info=(match opt
                 with Take_Old  -> e_prime
                  |   Take_New  -> e
                  |   Abort     -> failwith "Abort due to equiv option");
           left=t1;
           right=t2};;
   

let mk_bst2 opt c l  = list_it (add_root_to_bst opt c) l Empty;;



(*  Balanced binary trees  (AVL  *)
				  

type balance = Left | Balanced | Right;;

(* type 'a avltree == ('a * balance) btree;; *)

let balance =
function Bin{info=(_,b);} -> b
      |  Empty -> Balanced;;

let rec is_avl c = is_bst (o c  (app_both fst));;

let find_avl comp answer = 

   find_bst (o comp  (app_right fst))
            (o answer  fst) ;;

let belongs_to_avl comp  = 

   belongs_to_bst (o comp (app_right fst));;

let change_avl comp modify =
  change_bst (o comp  (app_right fst))
             (app_left modify);;

let flat_avl spec f = flat_btree spec (o f fst);;
let map_avl f = map_btree (app_left f);;
let do_avl spec h = do_btree spec (app_left h);;

let mirror_avl x = btree_hom
                  (fun ((x,b),t1,t2) 

                     ->
                   let b_prime = match b with
                                     Left     ->   Right
                                   | Balanced -> Balanced
                                   | Right    ->   Left
		   in  Bin{info=(x,b_prime);left=t2;right=t1})
                  Empty x;;



(* "Rotations "  *)

(* rotate right *)
let  rd (Bin{info=(q,_);
              left=Bin{info=(p,b);left=u;right=v};
              right=w})
=  match b with 

 Balanced ->  Bin{info=(p,Right);
                      left=u;
                      right=Bin{info=(q,Left);left=v;right=w}}
|  Left ->  Bin{info=(p,Balanced);
                left=u;
                right=Bin{info=(q,Balanced);left=v;right=w}};;

(* rotate left *)
let  rg (Bin{info=(p,_);
             left=u;
             right=Bin{info=(q,b);left=v;right=w}})
=  match b with 

 Balanced  ->  Bin{info=(q,Left);
                   left=Bin{info=(p,Right);left=u;right=v};
                   right=w}
|  Right   ->  Bin{info=(q,Balanced);
                   left=Bin{info=(p,Balanced);left=u;right=v};
                   right=w};;

(* rotate left right *)
let  rgd (Bin{info=(r,_);
              left=Bin{info=(p,_);
                       left=t;
                        right=Bin{info=(q,b);left=u;right=v}};
              right=w})
= match b with
  Left     ->   Bin{info=(q,Balanced);
                    left=Bin{info=(p,Balanced);left=t;right=u};
                    right=Bin{info=(r,Right);left=v;right=w}}
| Right    ->   Bin{info=(q,Balanced);
                    left=Bin{info=(p,Left);left=t;right=u};
                    right=Bin{info=(r,Balanced);left=v;right=w}}
| Balanced ->   Bin{info=(q,Balanced);
                    left=Bin{info=(p,Balanced);left=t;right=u};
                    right=Bin{info=(r,Balanced);left=v;right=w}};;


(* rotate right left*)
let rdg (Bin{info=(r,_);
              left=t;
              right=Bin{info=(p,_);
                         left=Bin{info=(q,b);left=u;right=v};
                         right=w}})   

= match b with 

    Left   ->  Bin{info=(q,Balanced);
                   left=Bin{info=(r,Balanced);left=t;right=u};
                   right=Bin{info=(p,Right);left=v;right=w}}
|  Right   ->  Bin{info=(q,Balanced);
                   left=Bin{info=(r,Left);left=t;right=u};
                    right=Bin{info=(p,Balanced);left=v;right=w}}
| Balanced ->  Bin{info=(q,Balanced);
                    left=Bin{info=(r,Balanced);left=t;right=u};
                    right=Bin{info=(p,Balanced);left=v;right=w}};;



type avl_modification1 = No_mod | Incleft | Incright;;


let rec add_to_avl opt comp t e = 
let rec add =
function Empty 

    -> Bin{info=(e,Balanced);left=Empty;right=Empty},Incleft 

| (Bin{info=(x,b);left=t1;right=t2} as t)


    ->
  (match (comp(e,x),opt,b) with
    (Equiv,Abort,_) -> failwith "Abort due to merging option"
  | (Equiv,Take_Old,_) -> t,No_mod
  | (Equiv,Take_New,_) -> Bin{info=(e,b);left=t1;right=t2},No_mod
  | (Smaller,_,Balanced)
     -> let t,m = add t1 

        in if m=No_mod 

              then Bin{info=(x,Balanced);left=t;right=t2},No_mod 

              else Bin{info=(x,Left);left=t;right=t2},Incleft 

  | (Greater,_,Balanced)
     -> let t,m = add t2 

        in if m= No_mod 

              then Bin{info=(x,Balanced);left=t1;right=t},No_mod
              else Bin{info=(x,Right);left=t1;right=t},Incright 

  | (Greater,_,Left)
     -> let t,m = add t2 

        in if m=No_mod 

              then Bin{info=(x,Left);left=t1;right=t},No_mod 

              else Bin{info=(x,Balanced);left=t1;right=t},No_mod 

  | (Smaller,_,Left)
     -> let t,m = add t1 

        in (match m with 

             No_mod -> Bin{info=(x,Left);left=t;right=t2},No_mod 

           | Incleft 

               -> rd (Bin{info=(x,Balanced);left=t;right=t2}),No_mod 

           | Incright 

               -> rgd(Bin{info=(x,Balanced);left=t;right=t2}),No_mod)
  | (Smaller,_,Right)
     ->  let t,m = add t1 

         in if m= No_mod 

               then Bin{info=(x,Right);left=t;right=t2},No_mod 

               else Bin{info=(x,Balanced);left=t;right=t2},No_mod 

  | (Greater,_,Right)
     ->  let t,m = add t2
         in (match m with 

              No_mod -> Bin{info=(x,Right);left=t1;right=t},No_mod 

            | Incleft 

                -> rdg(Bin{info=(x,Balanced);left=t1;right=t}),No_mod 

            | Incright 

                -> rg(Bin{info=(x,Balanced);left=t1;right=t}),No_mod))
in fst(add t);;



let add_list_to_avl opt c = it_list (add_to_avl opt c);;
let mk_avl opt c  = add_list_to_avl opt c Empty;;
let merge_avl opt c  = it_btree
                        (fun t x -> add_to_avl opt c t (fst x));;

let avl_sort c = o (flat_avl (Left_to_right,Infix) id) 

                            (mk_avl Take_Old c);;



let balance_right (x,t,t_prime) =
match balance t with
  (Left )  ->  rd  (Bin{info=(x,Balanced);left=t;right=t_prime})
| Balanced  ->  rd  (Bin{info=(x,Balanced);left=t;right=t_prime})
|      Right         ->  rgd (Bin{info=(x,Balanced);left=t;right=t_prime});;

let balance_left (x,t,t_prime) =
match balance t_prime with
  (Right )  ->  rg  (Bin{info=(x,Balanced);left=t;right=t_prime})
| Balanced  ->  rg  (Bin{info=(x,Balanced);left=t;right=t_prime})
|      Left           ->  rdg (Bin{info=(x,Balanced);left=t;right=t_prime});;

type avl_modification2 = No_modP | Dec;;

let rec remove_biggestP =  function
  Bin{info=(a,_);left=t1;right=Empty} -> (a,t1,Dec)
| Bin{info=(a,Balanced);left=t1;right=t2}
   ->  

   let  (a_prime,t_prime,b) = remove_biggestP t2
   in  (match b with
          Dec   -> (a_prime, Bin{info=(a,Left);left=t1;right=t_prime},No_modP)
        | No_modP -> (a_prime, Bin{info=(a,Balanced);left=t1;right=t_prime},No_modP))
| Bin{info=(a,Right);left=t1;right=t2}
   ->  

   let  (a_prime,t_prime,b) = remove_biggestP t2
   in  (match b with
           Dec   ->  (a_prime, Bin{info=(a,Balanced);left=t1;right=t_prime},No_modP)
        | No_modP ->  (a_prime, Bin{info=(a,Right);left=t1;right=t_prime},No_modP))
| Bin{info=(a,Left);left=t1;right=t2}
   ->   

   let  (a_prime,t_prime,b) = remove_biggestP t2
   in  (match b with
           Dec   ->  (a_prime, Bin{info=(a,Balanced);left=t1;right=t_prime},No_modP)
        | No_modP ->  (a_prime, balance_right (a,t1,t_prime),Dec))
| Empty -> failwith "Cannot remove element from empty avl";;




let rec remove_from_avl comp t e = 
let  rec remove =
function
    Empty          ->  failwith "search failed in avl tree"
| Bin{info=(a,b);left=t1;right=t2}  

    -> 

  match comp(e,a) with
    Equiv  ->  

    if t1=Empty then t2,Dec
       else let (a_prime,t_prime,m) = remove_biggestP t1
             in (match m with
                   No_modP -> Bin{info=(a_prime,b);left=t_prime;right=t2},No_modP
                 |  Dec -> (match b with
                             Balanced -> Bin{info=(a_prime,Right);
                                             left=t_prime;
                                             right=t2},No_modP
                             | Left   -> Bin{info=(a_prime,Balanced);
                                             left=t_prime;
                                             right=t2},Dec
                             | Right  -> balance_left(a_prime,t_prime,t2),Dec))
  | Smaller ->  

    let t_prime,m = remove t1
    in  (match m with
           No_modP -> Bin{info=(a,b);left=t_prime;right=t2},No_modP
         | Dec  -> (match b with
                     Balanced -> Bin{info=(a,Right);
                                     left=t_prime;
                                     right=t2},No_modP
                    |  Left   -> Bin{info=(a,Balanced);
                                     left=t_prime;
                                     right=t2},Dec
                      |  Right -> balance_left(a,t_prime,t2),
                                 if balance t2 = Balanced
                                    then No_modP else Dec))
  | Greater -> 

    let t_prime,m = remove t2
    in  (match m with
           No_modP  ->  Bin{info=(a,b);left=t1;right=t_prime},No_modP
         | Dec -> (match b with
                    Balanced -> Bin{info=(a,Left);
                                    left=t1;
                                    right=t_prime},No_modP
                   | Right   -> Bin{info=(a,Balanced);
                                    left=t1;
                                    right=t_prime},Dec
                   |  Left   -> balance_right(a,t1,t_prime),
                                if balance t2=Balanced
                                   then No_modP else Dec))
in fst (remove t);;

let remove_list_from_avl r  = it_list (remove_from_avl r);;

let rec subtract_from_avl comp t e = 

   try remove_from_avl comp t e
   with  _  -> t;;
   

   

   

 



type 'a set = {set_elements: ('a * balance) btree;
                set_order:('a * 'a) -> comparison};;
                

let cardinal s = btree_size s.set_elements;;

let make_set c l = {set_elements=mk_avl Take_Old c l;
                  set_order=c};;
                  

let make_emptyset c =  make_set c [];;
                  

let set_isempty s = (s.set_elements=Empty);;

let set_member x s =
   belongs_to_avl  s.set_order x s.set_elements;;
   

let set_it f s =  btree_it (fun x y  -> f (fst x) y)
                            s.set_elements;;
   

let it_set f x s = it_btree (fun x y  -> f x (fst y))
                            x
                            s.set_elements;;
                            

let add_to_set s x = {set_elements= add_to_avl Take_Old 

                                       s.set_order s.set_elements x;
                      set_order=s.set_order};;

let add_list_to_set x = it_list add_to_set x;;



let remove_from_set s x = 

   try  {set_elements= remove_from_avl 

                           s.set_order s.set_elements x;
         set_order=s.set_order}
   with _ -> failwith "set: cannot remove a non-existing element";;
                            

                            

let subtract_from_set s x = 

   try  remove_from_set s x
   with  _ -> s;;
   

   

let set_union s1 s2 =
  if not(s1.set_order = s2.set_order)
    then failwith "set_union: different set orders"
    else  it_set add_to_set s1 s2;;


let set_diff s1 s2 =
  if not(s1.set_order = s2.set_order)
    then failwith "set_diff: different set orders"
    else  it_set subtract_from_set s1 s2;;
           

let set_intersection s1 s2 = set_diff s1 (set_diff s1 s2);;

let sub_set s1 s2 = set_isempty (set_diff s1 s2);;



           

let list_of_set s = flat_avl (Left_to_right,Infix) id s.set_elements;;

let do_set f s = do_btree (Left_to_right,Infix)
                          (app_left f)
                          s.set_elements;;

let print_set print_elem s=
  do_set (fun x -> print_elem  x; print_string " ") s;;







(* let I x = x;;*)


let rec find p =
  function []  ->  failwith "not_found"
   | (a::l) ->  if (p a) then a else find p l;;

let rec loop p f x = if (p x) then x
                              else loop p f (f x);;


let n=ref (-1);;
let rec loopn p f x = if (p x) then x
                              else (n:=!n+1;print_int !n;
                                    print_newline();loopn p f (f x));;


(* recherche breadth-first d'une solution
avec memorisation des configurations
rencontrees: 

On commence par definir une fonction "add_archive"
qui joue le meme role que la fonction "flat_map"
mais qui ajoute une archivation des configurations
rencontrees.
Alors que "flat_map"  est de type
('a -> 'b list) -> 'a list -> 'b list,
"add_archive" est essentiellement de type
('a -> 'b list) -> 'c * 'a list -> 'c * 'b list
ou` 'c est le type de l'archive.
En fait, "add_archive" est parame'tre'e par les
fonctions permettant de d'utiliser l'archive
c'est-a`-dire les fonction 

  - de test d'appartenance a` l'archive
  - d'ajout d'un e'le'ment a` l'archive
  - d'extraction a` partir des configurations de
    la partie qui doit e^tre archive'e
"add_archive" posse`de donc le type
('a -> 'b -> bool) * ('b -> 'a list -> 'b) * ('c -> 'a) 

    -> ('d -> 'c list) -> 'b * 'd list -> 'b * 'c list
*)


let partition test l =
   let switch elem (l1,l2)   = 

        if test elem then (l1,elem::l2)
	             else (elem::l1,l2)
   in list_it switch l ([],[]);;

(*let rec all p =
     fun   [] -> []
      |  (a::l) 

           -> if p a
               then a::all p l 

               else all p l;;
  *)

let all p = o snd  (partition p);;

(* *** AJOPUT *** *)
let rec map f l = match l with [] -> [] | h::t -> (f h)::(map f t);;
let exists p =  
let rec exists_p = function
     [] -> false | a::l -> p a or exists_p l
in exists_p 
;;


let add_archive (belongs,add,arch_part) f (arch,l) =
let  rec frec  arch ll =
  function []   ->   (arch,ll)
   | (c::cl) 

       -> let ll_prime = all (fun c -> not(belongs (arch_part c) arch)) (f c)
          in frec (add arch (map arch_part ll_prime)) (ll_prime@ll) cl
in    frec arch [] l;;


let find_one_shortest_solution trace (ok,pos_moves,display_result) 

             (belongs,add,arch_part,empty) start =

  (display_result ok
    ((if trace then (n:=0;loopn) else loop)
          (o (exists  ok)   snd)
          (add_archive (belongs,add,arch_part) pos_moves) 

          (add empty (map arch_part start),start)))
;;

(*   JEUX    THAILANDAIS   *)


(* type cell== int*int;;*)
type direction = LeftP | Up | RightP | Down;;
(* type thai_move == (int * int)  * direction;; *)


type board =
  {king: (int *int);
   knights: (int *int) list;
   hdef: (int *int);
   vdefs: (int *int) list};;
type piece = King | Knight | Hdef | Vdef | None;;

(* AJOUT *)

let equal_cell (a,b) (c,d) = (a=c) & (b=d);;
let mem x = 
let rec mem_x = function
     [] -> false | y::l -> (equal_cell x y) or mem_x l
in mem_x
;;

(* PB cell board.vdefs *)

let get cell board =
 if equal_cell board.king  cell then King
 else if equal_cell board.hdef  cell then Hdef
      else if mem cell board.knights then Knight
            else if mem cell board.vdefs then Vdef
                 else None;;


let besides ((l1,c1),(l2,c2))=
   l1=l2 & c2=c1+1;;

let over ((l1,c1),(l2,c2))=
   c1=c2 & l2=l1+1;;

let up (i,j) = (i-1,j);;
let left (i,j) = (i,j-1);;
let down (i,j) = (i+1,j);;
let right (i,j) = (i,j+1);;
let up2 (i,j) = (i-2,j);;
let left2 (i,j) = (i,j-2);;
let down2 (i,j) = (i+2,j);;
let right2 (i,j) = (i,j+2);;

let rec update x y =
 function    []   ->   []
  |   (a::l) ->  if equal_cell x a then y::l
                        else a::update x y l;;




let int_comp2 (i1,i2)
  = if i1<i2 then Smaller
     else if i1 > i2 then Greater
       else Equiv;;

let cell_comp ((i1,j1),(i2,j2))
  = match int_comp2 (i1,i2)
    with Smaller -> Smaller
     |   Greater -> Greater
     |   Equiv -> int_comp2 (j1,j2);;

let rec cell_list_comp =
  function    ([],[])   ->   Equiv
   |  (c1::cl1,c2::cl2) 

     ->  match cell_comp (c1,c2)
         with Smaller    ->   Smaller
          |   Greater    ->   Greater
          |    Equiv     ->  cell_list_comp (cl1,cl2);;


let thai_comp (c1,c2) =
  match cell_comp(c1.king,c2.king)
  with  Smaller   ->  Smaller
    |   Greater   ->  Greater
    |    Equiv  

     ->  

  match cell_comp(c1.hdef,c2.hdef)
  with  Smaller   ->  Smaller
    |   Greater   ->  Greater
    |    Equiv  

     ->  

  match cell_list_comp(c1.knights,c2.knights)
  with  Smaller   ->  Smaller
    |   Greater   ->  Greater
    |    Equiv  

     ->  

  match cell_list_comp(c1.vdefs,c2.vdefs)
  with  Smaller   ->  Smaller
    |   Greater   ->  Greater
    |    Equiv  ->  Equiv;;


let rec insert comp x =
 function [] ->  [x]
  | ((a::l) as l_prime)
    -> match comp(x,a)
       with  (Smaller) ->  x::l_prime
       |Equiv  ->  x::l_prime
        |      Greater   ->  a::insert comp x l;;

let sort comp l = list_it (insert comp) l [];;

let order_pair ((p1,p2) as p) =
 match cell_comp p
 with  (Smaller)  -> p
 | Equiv -> p
  |        Greater  ->   (p2,p1);;


let moves1 (ml,((b,b_prime),board) )
= (match get (right b) board
   with  Knight  ->  [((b,LeftP)::ml,(order_pair(right b,b_prime),
                      {king=board.king;
                       knights= sort cell_comp (update (right b) b 

board.knights);
                       hdef=board.hdef;vdefs= board.vdefs}))]
    |    Hdef    ->  [((b,LeftP)::ml,(order_pair(right2 b,b_prime),
                      {king=board.king;knights= board.knights;
                       hdef=b;vdefs= board.vdefs}))]
    |     _      ->  [])
   @
   (match get (down b) board
   with  Knight  ->  [((b,Up)::ml,(order_pair(down b,b_prime),
                      {king=board.king;
                       knights=update (down b) b board.knights;
                       hdef=board.hdef;vdefs= board.vdefs}))]
    |    Vdef    ->  [((b,Up)::ml,(order_pair(down2 b,b_prime),
                      {king=board.king;knights= board.knights;
                       hdef=board.hdef;vdefs= sort cell_comp (update (down 

b) b board.vdefs)}))]
    |     _      ->  [])
    @
    (match (get (left b) board,get (left2 b) board)
   with  (Knight,_)  ->  [((b,RightP)::ml,(order_pair(left b,b_prime),
                          {king=board.king;
                           knights=sort cell_comp (update (left b) b 

board.knights);
                           hdef=board.hdef;vdefs= board.vdefs}))]
    |    (_,Hdef)    ->  [((b,RightP)::ml,(order_pair(left2 b,b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=left b;vdefs= board.vdefs}))]
    |     _      ->  [])
   @
   (match (get (up b) board,get (up2 b) board)
   with  (Knight,_)  ->  [((b,Down)::ml,(order_pair(up b,b_prime),
                          {king=board.king;
                           knights=sort cell_comp (update (up b) b 

board.knights);
                           hdef=board.hdef;vdefs= board.vdefs}))]
    |    (_,Vdef)    ->  [((b,Down)::ml,(order_pair(up2 b,b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=board.hdef;
                           vdefs= sort cell_comp (update (up2 b) (up b) 

board.vdefs)}))]
    |     _      ->  []);;

let moves2 (ml,((b,b_prime),board) )
= if not(besides (b,b_prime)) & not(over (b,b_prime)) 

    then []
    else if besides (b,b_prime)
         then  (match (get (up b) board,get (up2 b) board)
                with  (_,King)  

                      ->  [((b,Down)::ml,((up2 b,up2 b_prime),
                          {king=up b;knights=board.knights;
                           hdef=board.hdef;vdefs= board.vdefs}))]
                  |    (Hdef,_)    

                      ->  [((b,Down)::ml,((up b,up b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=b;vdefs= board.vdefs}))]
                  |     _      ->  [])
                @
               (match get (down b) board
                with  King  

                      ->  [((b,Up)::ml,((down2 b,down2 b_prime),
                          {king=b;knights=board.knights;
                           hdef=board.hdef;vdefs= board.vdefs}))]
                  |   Hdef   

                      ->  [((b,Up)::ml,((down b,down b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=b;vdefs= board.vdefs}))]
                  |     _      ->  [])
         else if over (b,b_prime)
         then  (match (get (left b) board,get (left2 b) board)
                with  (_,King)  

                      ->  [((b,RightP)::ml,((left2 b,left2 b_prime),
                          {king=left b;knights=board.knights;
                           hdef=board.hdef;vdefs= board.vdefs}))]
                  |    (Vdef,_)    

                      ->  [((b,RightP)::ml,((left b,left b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=board.hdef;
                           vdefs= sort cell_comp (update (left b) b 

board.vdefs)}))]
                  |     _      ->  [])
                @
               (match get (right b) board
                with  King  

                      ->  [((b,LeftP)::ml,((right2 b,right2 b_prime),
                          {king=b;knights=board.knights;
                           hdef=board.hdef;vdefs= board.vdefs}))]
                  |   Vdef   

                      ->  [((b,LeftP)::ml,((right b,right b_prime),
                          {king=board.king;knights= board.knights;
                           hdef=board.hdef;
                           vdefs= sort cell_comp (update (right b) b 

board.vdefs)}))]
                  |     _      ->  [])
            else [];;









let thai_game_pos_moves (ml,((b,b_prime),board))=
  (moves1 (ml,((b,b_prime),board))) @ (moves1 (ml,((b_prime,b),board)))
 @  (moves2 (ml,((b,b_prime),board))) ;;

let ok_thai c = fst((snd(snd c)).king)=4;;

let comB =((3,1),(3,4)),
       {king=1,2;
        knights=[1,1;1,4;2,1;2,4];
        hdef=3,2;
        vdefs= [4,1;4,2;4,3;4,4]};;

(* AJOUT *)
let rec rev_append l l_prime = match (l,l_prime) with 
      ([],l_prime) -> l_prime
  | ((a::l), l_prime) -> rev_append l (a::l_prime)
;;

let rev l = rev_append l []
;;
let display_thai_result ok c=
  rev(fst (find ok (snd c)));;


let find_one_shortest_solution_for_thai_game ok start=
find_one_shortest_solution true
         (ok ,thai_game_pos_moves,display_thai_result)
         (set_member , 

          add_list_to_set ,
          o snd  snd,
          make_emptyset thai_comp)
         [[],start];;

find_one_shortest_solution_for_thai_game ok_thai comB ;;

let eq_string a b = a = b;;


let rec do_list f = function [] -> () | h::l -> f h; do_list f l;;
let rec map f = function [] -> [] | h::l -> (f h)::(map f l);;
exception Fail of string;;
(* let hd = function [] -> raise (Fail "hd") | h::_ -> h;;*)


(* Manipulations over terms *)

exception Failure of string;;

type term =
    Var of int
  | Prop of head * term list
and head =
    { name: string;
      mutable props: (term * term) list }
;;

(* AJOUT *)

let rec equal_term t1 t2 = match (t1,t2) with
    (Var i),(Var j) ->i == j
 | (Prop (h1,l1)),(Prop (h2,l2)) -> 
     if (h1==h2) or (equal_head h1 h2) then equal_list_term l1 l2 else false
 |  _  -> false
and 
   equal_head th1 th2 = match (th1,th2) with
       {name=s1;props=p1},{name=s2;props=p2} -> 
     if eq_string s1 s2 then  equal_list_term2 p1 p2 else false  
and equal_list_term tl1 tl2 = match (tl1,tl2) with
    [], [] -> true
  | (h1::t1), (h2::t2) -> if (h1==h2) or (equal_term h1 h2) then equal_list_term t1 t2 else false
  | _, _ -> false
and equal_list_term2 tl1 tl2 = match (tl1,tl2) with
    [], [] -> true
  | ((a1,a2)::t1), ((a3,a4)::t2) -> if ((a1==a3) or (equal_term a1 a3)) & ((a2==a4) or (equal_term a2 a4)) then equal_list_term2 t1 t2 else false
  | _, _ -> false
 ;;

let rec mem_term x = function [] -> false | h::l -> equal_term x h or (mem_term x l)
;;

let rec print_term = function
    Var v ->
     print_string "v"; print_int v 
  | Prop (head,argl) ->
      print_string "(";
      print_string head.name;
      do_list (fun t -> print_string " "; print_term t) argl;
      print_string ")"
;;
			 
let lemmas = ref ([] : head list);;

(* replacement for property lists *)

let get name =
  let rec get_rec = function
    hd1::hdl ->
      if eq_string hd1.name  name then hd1 else get_rec hdl
  | [] ->
      let entry = {name = name; props = []} in
        lemmas := entry :: !lemmas;
        entry
  in   get_rec !lemmas
;;

let count_lemma = ref 0 ;;
let add_lemma (Prop(_, [(Prop(headl,_) as left); right])) =
  count_lemma:=!count_lemma+1;
  headl.props <- (left, right) :: headl.props
;;

(* substitutions *)

type binding = Bind of int * term
;;

let get_binding v =
 let rec get_rec = function
    [] -> raise (Failure "unbound")
  | Bind(w,t)::rest -> if v == w then t else get_rec rest
 in  get_rec 
;;

let apply_subst alist =
  let rec as_rec term =
  match term with
     Var v -> begin try get_binding v alist with Failure _ -> term end
   | Prop (head,argl) -> Prop (head, map as_rec argl)
  in as_rec
;;

(*|
Exception unify defined
|*)
exception Unify;;

(* only non linear pattern matching *)

(*|
Value unify : (term -> term -> (int & term) list)
Value unify1 : (term -> term -> (int & term) list -> (int & term) list)
Value unify1_lst
      : (term list -> term list -> (int & term) list ->
         (int & term) list)
 CAML_system{assq}
|*)
let rec unify (term1, term2) = unify1 (term1, term2, [])
and unify1 (term1, term2, unify_subst) =
 match term2 with
    Var v ->
      begin try
        if equal_term (get_binding v unify_subst)  term1
        then unify_subst
        else raise Unify
      with Failure _ ->
        Bind(v,term1)::unify_subst
      end
  | Prop (head2,argl2) ->
      match term1 with
         Var _ -> raise Unify
       | Prop (head1,argl1) ->
           if head1==head2 then unify1_lst (argl1, argl2, unify_subst)
            else raise Unify
and unify1_lst = function
    ([], [], unify_subst) -> unify_subst
  | (h1::r1, h2::r2, unify_subst) ->
      unify1_lst(r1, r2, unify1(h1, h2, unify_subst))
  | _ -> raise Unify
;;

let rec rewrite = function
    Var _ as term -> term
  | Prop (head, argl) ->
      rewrite_with_lemmas (Prop (head, map rewrite argl),  head.props)
and rewrite_with_lemmas = function
    (term, []) ->
      term
  | (term, (t1,t2)::rest) ->
      try
        rewrite (apply_subst (unify (term, t1)) t2)
      with unify ->
        rewrite_with_lemmas (term, rest)
;;


(* ******** *)

(*  #open "boyer/terms";; *)

type cterm = CVar of int | CProp of string * cterm list;;

let rec cterm_to_term = function
    CVar v -> Var v
  | CProp(p, l) -> Prop(get p, map cterm_to_term l)
;;

let add t = add_lemma (cterm_to_term t)
;;

print_string "Debut init constantes";;
print_newline();;

add (CProp
("equal",
 [CProp ("compile",[CVar 5]); 
  CProp
  ("reverse",
   [CProp ("codegen",[CProp ("optimize",[CVar 5]); CProp ("nil",[])])])]));;

add (CProp
("equal",
 [CProp ("eqp",[CVar 23; CVar 24]); 
  CProp ("equal",[CProp ("fix",[CVar 23]); CProp ("fix",[CVar 24])])]));;

add (CProp
("equal",
 [CProp ("gt",[CVar 23; CVar 24]); CProp ("lt",[CVar 24; CVar 23])]));;

add (CProp
("equal",
 [CProp ("le",[CVar 23; CVar 24]); CProp ("ge",[CVar 24; CVar 23])]));;

add (CProp
("equal",
 [CProp ("ge",[CVar 23; CVar 24]); CProp ("le",[CVar 24; CVar 23])]));;

add (CProp
("equal",
 [CProp ("boolean",[CVar 23]); 
  CProp
  ("or",
   [CProp ("equal",[CVar 23; CProp ("true",[])]); 
    CProp ("equal",[CVar 23; CProp ("false",[])])])]));;

add (CProp
("equal",
 [CProp ("iff",[CVar 23; CVar 24]); 
  CProp
  ("and",
   [CProp ("implies",[CVar 23; CVar 24]); 
    CProp ("implies",[CVar 24; CVar 23])])]));;

add (CProp
("equal",
 [CProp ("even1",[CVar 23]); 
  CProp
  ("if",
   [CProp ("zerop",[CVar 23]); CProp ("true",[]); 
    CProp ("odd",[CProp ("sub1",[CVar 23])])])]));;
add (CProp
("equal",
 [CProp ("countps_",[CVar 11; CVar 15]); 
  CProp ("countps_loop",[CVar 11; CVar 15; CProp ("zero",[])])]));;
add (CProp
("equal",
 [CProp ("fact_",[CVar 8]); 
  CProp ("fact_loop",[CVar 8; CProp ("one",[])])]));;
add (CProp
("equal",
 [CProp ("reverse_",[CVar 23]); 
  CProp ("reverse_loop",[CVar 23; CProp ("nil",[])])]));;
add (CProp
("equal",
 [CProp ("divides",[CVar 23; CVar 24]); 
  CProp ("zerop",[CProp ("remainder",[CVar 24; CVar 23])])]));;
add (CProp
("equal",
 [CProp ("assume_true",[CVar 21; CVar 0]); 
  CProp ("cons",[CProp ("cons",[CVar 21; CProp ("true",[])]); CVar 0])]));;
add (CProp
("equal",
 [CProp ("assume_false",[CVar 21; CVar 0]); 
  CProp ("cons",[CProp ("cons",[CVar 21; CProp ("false",[])]); CVar 0])]));;
add (CProp
("equal",
 [CProp ("tautology_checker",[CVar 23]); 
  CProp ("tautologyp",[CProp ("normalize",[CVar 23]); CProp ("nil",[])])]));;
add (CProp
("equal",
 [CProp ("falsify",[CVar 23]); 
  CProp ("falsify1",[CProp ("normalize",[CVar 23]); CProp ("nil",[])])]));;
add (CProp
("equal",
 [CProp ("prime",[CVar 23]); 
  CProp
  ("and",
   [CProp ("not",[CProp ("zerop",[CVar 23])]); 
    CProp
    ("not",
     [CProp ("equal",[CVar 23; CProp ("add1",[CProp ("zero",[])])])]); 
    CProp ("prime1",[CVar 23; CProp ("sub1",[CVar 23])])])]));;
add (CProp
("equal",
 [CProp ("and",[CVar 15; CVar 16]); 
  CProp
  ("if",
   [CVar 15; 
    CProp ("if",[CVar 16; CProp ("true",[]); CProp ("false",[])]); 
    CProp ("false",[])])]));;
add (CProp
("equal",
 [CProp ("or",[CVar 15; CVar 16]); 
  CProp
  ("if",
   [CVar 15; CProp ("true",[]); 
    CProp ("if",[CVar 16; CProp ("true",[]); CProp ("false",[])]); 
    CProp ("false",[])])]));;
add (CProp
("equal",
 [CProp ("not",[CVar 15]); 
  CProp ("if",[CVar 15; CProp ("false",[]); CProp ("true",[])])]));;
add (CProp
("equal",
 [CProp ("implies",[CVar 15; CVar 16]); 
  CProp
  ("if",
   [CVar 15; 
    CProp ("if",[CVar 16; CProp ("true",[]); CProp ("false",[])]); 
    CProp ("true",[])])]));;
add (CProp
("equal",
 [CProp ("fix",[CVar 23]); 
  CProp ("if",[CProp ("numberp",[CVar 23]); CVar 23; CProp ("zero",[])])]));;
add (CProp
("equal",
 [CProp ("if",[CProp ("if",[CVar 0; CVar 1; CVar 2]); CVar 3; CVar 4]); 
  CProp
  ("if",
   [CVar 0; CProp ("if",[CVar 1; CVar 3; CVar 4]); 
    CProp ("if",[CVar 2; CVar 3; CVar 4])])]));;
add (CProp
("equal",
 [CProp ("zerop",[CVar 23]); 
  CProp
  ("or",
   [CProp ("equal",[CVar 23; CProp ("zero",[])]); 
    CProp ("not",[CProp ("numberp",[CVar 23])])])]));;
add (CProp
("equal",
 [CProp ("plus",[CProp ("plus",[CVar 23; CVar 24]); CVar 25]); 
  CProp ("plus",[CVar 23; CProp ("plus",[CVar 24; CVar 25])])]));;
add (CProp
("equal",
 [CProp ("equal",[CProp ("plus",[CVar 0; CVar 1]); CProp ("zero",[])]); 
  CProp ("and",[CProp ("zerop",[CVar 0]); CProp ("zerop",[CVar 1])])]));;
add (CProp
("equal",[CProp ("difference",[CVar 23; CVar 23]); CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("plus",[CVar 0; CVar 1]); CProp ("plus",[CVar 0; CVar 2])]); 
  CProp ("equal",[CProp ("fix",[CVar 1]); CProp ("fix",[CVar 2])])]));;
add (CProp
("equal",
 [CProp
  ("equal",[CProp ("zero",[]); CProp ("difference",[CVar 23; CVar 24])]); 
  CProp ("not",[CProp ("gt",[CVar 24; CVar 23])])]));;
add (CProp
("equal",
 [CProp ("equal",[CVar 23; CProp ("difference",[CVar 23; CVar 24])]); 
  CProp
  ("and",
   [CProp ("numberp",[CVar 23]); 
    CProp
    ("or",
     [CProp ("equal",[CVar 23; CProp ("zero",[])]); 
      CProp ("zerop",[CVar 24])])])]));;
add (CProp
("equal",
 [CProp
  ("meaning",
   [CProp ("plus_tree",[CProp ("append",[CVar 23; CVar 24])]); CVar 0]); 
  CProp
  ("plus",
   [CProp ("meaning",[CProp ("plus_tree",[CVar 23]); CVar 0]); 
    CProp ("meaning",[CProp ("plus_tree",[CVar 24]); CVar 0])])]));;
add (CProp
("equal",
 [CProp
  ("meaning",
   [CProp ("plus_tree",[CProp ("plus_fringe",[CVar 23])]); CVar 0]); 
  CProp ("fix",[CProp ("meaning",[CVar 23; CVar 0])])]));;
add (CProp
("equal",
 [CProp ("append",[CProp ("append",[CVar 23; CVar 24]); CVar 25]); 
  CProp ("append",[CVar 23; CProp ("append",[CVar 24; CVar 25])])]));;
add (CProp
("equal",
 [CProp ("reverse",[CProp ("append",[CVar 0; CVar 1])]); 
  CProp
  ("append",[CProp ("reverse",[CVar 1]); CProp ("reverse",[CVar 0])])]));;
add (CProp
("equal",
 [CProp ("times",[CVar 23; CProp ("plus",[CVar 24; CVar 25])]); 
  CProp
  ("plus",
   [CProp ("times",[CVar 23; CVar 24]); 
    CProp ("times",[CVar 23; CVar 25])])]));;
add (CProp
("equal",
 [CProp ("times",[CProp ("times",[CVar 23; CVar 24]); CVar 25]); 
  CProp ("times",[CVar 23; CProp ("times",[CVar 24; CVar 25])])]));;
add (CProp
("equal",
 [CProp
  ("equal",[CProp ("times",[CVar 23; CVar 24]); CProp ("zero",[])]); 
  CProp ("or",[CProp ("zerop",[CVar 23]); CProp ("zerop",[CVar 24])])]));;
add (CProp
("equal",
 [CProp ("exec",[CProp ("append",[CVar 23; CVar 24]); CVar 15; CVar 4]); 
  CProp
  ("exec",[CVar 24; CProp ("exec",[CVar 23; CVar 15; CVar 4]); CVar 4])]));;
add (CProp
("equal",
 [CProp ("mc_flatten",[CVar 23; CVar 24]); 
  CProp ("append",[CProp ("flatten",[CVar 23]); CVar 24])]));;
add (CProp
("equal",
 [CProp ("member",[CVar 23; CProp ("append",[CVar 0; CVar 1])]); 
  CProp
  ("or",
   [CProp ("member",[CVar 23; CVar 0]); 
    CProp ("member",[CVar 23; CVar 1])])]));;
add (CProp
("equal",
 [CProp ("member",[CVar 23; CProp ("reverse",[CVar 24])]); 
  CProp ("member",[CVar 23; CVar 24])]));;
add (CProp
("equal",
 [CProp ("length",[CProp ("reverse",[CVar 23])]); 
  CProp ("length",[CVar 23])]));;
add (CProp
("equal",
 [CProp ("member",[CVar 0; CProp ("intersect",[CVar 1; CVar 2])]); 
  CProp
  ("and",
   [CProp ("member",[CVar 0; CVar 1]); CProp ("member",[CVar 0; CVar 2])])]));;
add (CProp
("equal",[CProp ("nth",[CProp ("zero",[]); CVar 8]); CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp ("exp",[CVar 8; CProp ("plus",[CVar 9; CVar 10])]); 
  CProp
  ("times",
   [CProp ("exp",[CVar 8; CVar 9]); CProp ("exp",[CVar 8; CVar 10])])]));;
add (CProp
("equal",
 [CProp ("exp",[CVar 8; CProp ("times",[CVar 9; CVar 10])]); 
  CProp ("exp",[CProp ("exp",[CVar 8; CVar 9]); CVar 10])]));;
add (CProp
("equal",
 [CProp ("reverse_loop",[CVar 23; CVar 24]); 
  CProp ("append",[CProp ("reverse",[CVar 23]); CVar 24])]));;
add (CProp
("equal",
 [CProp ("reverse_loop",[CVar 23; CProp ("nil",[])]); 
  CProp ("reverse",[CVar 23])]));;
add (CProp
("equal",
 [CProp ("count_list",[CVar 25; CProp ("sort_lp",[CVar 23; CVar 24])]); 
  CProp
  ("plus",
   [CProp ("count_list",[CVar 25; CVar 23]); 
    CProp ("count_list",[CVar 25; CVar 24])])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("append",[CVar 0; CVar 1]); CProp ("append",[CVar 0; CVar 2])]); 
  CProp ("equal",[CVar 1; CVar 2])]));;
add (CProp
("equal",
 [CProp
  ("plus",
   [CProp ("remainder",[CVar 23; CVar 24]); 
    CProp ("times",[CVar 24; CProp ("quotient",[CVar 23; CVar 24])])]); 
  CProp ("fix",[CVar 23])]));;
add (CProp
("equal",
 [CProp
  ("power_eval",[CProp ("big_plus",[CVar 11; CVar 8; CVar 1]); CVar 1]); 
  CProp ("plus",[CProp ("power_eval",[CVar 11; CVar 1]); CVar 8])]));;
add (CProp
("equal",
 [CProp
  ("power_eval",
   [CProp ("big_plus",[CVar 23; CVar 24; CVar 8; CVar 1]); CVar 1]); 
  CProp
  ("plus",
   [CVar 8; 
    CProp
    ("plus",
     [CProp ("power_eval",[CVar 23; CVar 1]); 
      CProp ("power_eval",[CVar 24; CVar 1])])])]));;
add (CProp
("equal",
 [CProp ("remainder",[CVar 24; CProp ("one",[])]); CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp ("lt",[CProp ("remainder",[CVar 23; CVar 24]); CVar 24]); 
  CProp ("not",[CProp ("zerop",[CVar 24])])]));;
add (CProp
("equal",[CProp ("remainder",[CVar 23; CVar 23]); CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp ("lt",[CProp ("quotient",[CVar 8; CVar 9]); CVar 8]); 
  CProp
  ("and",
   [CProp ("not",[CProp ("zerop",[CVar 8])]); 
    CProp
    ("or",
     [CProp ("zerop",[CVar 9]); 
      CProp ("not",[CProp ("equal",[CVar 9; CProp ("one",[])])])])])]));;
add (CProp
("equal",
 [CProp ("lt",[CProp ("remainder",[CVar 23; CVar 24]); CVar 23]); 
  CProp
  ("and",
   [CProp ("not",[CProp ("zerop",[CVar 24])]); 
    CProp ("not",[CProp ("zerop",[CVar 23])]); 
    CProp ("not",[CProp ("lt",[CVar 23; CVar 24])])])]));;
add (CProp
("equal",
 [CProp ("power_eval",[CProp ("power_rep",[CVar 8; CVar 1]); CVar 1]); 
  CProp ("fix",[CVar 8])]));;
add (CProp
("equal",
 [CProp
  ("power_eval",
   [CProp
    ("big_plus",
     [CProp ("power_rep",[CVar 8; CVar 1]); 
      CProp ("power_rep",[CVar 9; CVar 1]); CProp ("zero",[]); 
      CVar 1]); 
    CVar 1]); 
  CProp ("plus",[CVar 8; CVar 9])]));;
add (CProp
("equal",
 [CProp ("gcd",[CVar 23; CVar 24]); CProp ("gcd",[CVar 24; CVar 23])]));;
add (CProp
("equal",
 [CProp ("nth",[CProp ("append",[CVar 0; CVar 1]); CVar 8]); 
  CProp
  ("append",
   [CProp ("nth",[CVar 0; CVar 8]); 
    CProp
    ("nth",
     [CVar 1; CProp ("difference",[CVar 8; CProp ("length",[CVar 0])])])])]));;
add (CProp
("equal",
 [CProp ("difference",[CProp ("plus",[CVar 23; CVar 24]); CVar 23]); 
  CProp ("fix",[CVar 24])]));;
add (CProp
("equal",
 [CProp ("difference",[CProp ("plus",[CVar 24; CVar 23]); CVar 23]); 
  CProp ("fix",[CVar 24])]));;
add (CProp
("equal",
 [CProp
  ("difference",
   [CProp ("plus",[CVar 23; CVar 24]); CProp ("plus",[CVar 23; CVar 25])]); 
  CProp ("difference",[CVar 24; CVar 25])]));;
add (CProp
("equal",
 [CProp ("times",[CVar 23; CProp ("difference",[CVar 2; CVar 22])]); 
  CProp
  ("difference",
   [CProp ("times",[CVar 2; CVar 23]); 
    CProp ("times",[CVar 22; CVar 23])])]));;
add (CProp
("equal",
 [CProp ("remainder",[CProp ("times",[CVar 23; CVar 25]); CVar 25]); 
  CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp
  ("difference",
   [CProp ("plus",[CVar 1; CProp ("plus",[CVar 0; CVar 2])]); CVar 0]); 
  CProp ("plus",[CVar 1; CVar 2])]));;
add (CProp
("equal",
 [CProp
  ("difference",
   [CProp ("add1",[CProp ("plus",[CVar 24; CVar 25])]); CVar 25]); 
  CProp ("add1",[CVar 24])]));;
add (CProp
("equal",
 [CProp
  ("lt",
   [CProp ("plus",[CVar 23; CVar 24]); CProp ("plus",[CVar 23; CVar 25])]); 
  CProp ("lt",[CVar 24; CVar 25])]));;
add (CProp
("equal",
 [CProp
  ("lt",
   [CProp ("times",[CVar 23; CVar 25]); 
    CProp ("times",[CVar 24; CVar 25])]); 
  CProp
  ("and",
   [CProp ("not",[CProp ("zerop",[CVar 25])]); 
    CProp ("lt",[CVar 23; CVar 24])])]));;
add (CProp
("equal",
 [CProp ("lt",[CVar 24; CProp ("plus",[CVar 23; CVar 24])]); 
  CProp ("not",[CProp ("zerop",[CVar 23])])]));;
add (CProp
("equal",
 [CProp
  ("gcd",
   [CProp ("times",[CVar 23; CVar 25]); 
    CProp ("times",[CVar 24; CVar 25])]); 
  CProp ("times",[CVar 25; CProp ("gcd",[CVar 23; CVar 24])])]));;
add (CProp
("equal",
 [CProp ("value",[CProp ("normalize",[CVar 23]); CVar 0]); 
  CProp ("value",[CVar 23; CVar 0])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("flatten",[CVar 23]); 
    CProp ("cons",[CVar 24; CProp ("nil",[])])]); 
  CProp
  ("and",
   [CProp ("nlistp",[CVar 23]); CProp ("equal",[CVar 23; CVar 24])])]));;
add (CProp
("equal",
 [CProp ("listp",[CProp ("gother",[CVar 23])]); 
  CProp ("listp",[CVar 23])]));;
add (CProp
("equal",
 [CProp ("samefringe",[CVar 23; CVar 24]); 
  CProp
  ("equal",[CProp ("flatten",[CVar 23]); CProp ("flatten",[CVar 24])])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("greatest_factor",[CVar 23; CVar 24]); CProp ("zero",[])]); 
  CProp
  ("and",
   [CProp
    ("or",
     [CProp ("zerop",[CVar 24]); 
      CProp ("equal",[CVar 24; CProp ("one",[])])]); 
    CProp ("equal",[CVar 23; CProp ("zero",[])])])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("greatest_factor",[CVar 23; CVar 24]); CProp ("one",[])]); 
  CProp ("equal",[CVar 23; CProp ("one",[])])]));;
add (CProp
("equal",
 [CProp ("numberp",[CProp ("greatest_factor",[CVar 23; CVar 24])]); 
  CProp
  ("not",
   [CProp
    ("and",
     [CProp
      ("or",
       [CProp ("zerop",[CVar 24]); 
        CProp ("equal",[CVar 24; CProp ("one",[])])]); 
      CProp ("not",[CProp ("numberp",[CVar 23])])])])]));;
add (CProp
("equal",
 [CProp ("times_list",[CProp ("append",[CVar 23; CVar 24])]); 
  CProp
  ("times",
   [CProp ("times_list",[CVar 23]); CProp ("times_list",[CVar 24])])]));;
add (CProp
("equal",
 [CProp ("prime_list",[CProp ("append",[CVar 23; CVar 24])]); 
  CProp
  ("and",
   [CProp ("prime_list",[CVar 23]); CProp ("prime_list",[CVar 24])])]));;
add (CProp
("equal",
 [CProp ("equal",[CVar 25; CProp ("times",[CVar 22; CVar 25])]); 
  CProp
  ("and",
   [CProp ("numberp",[CVar 25]); 
    CProp
    ("or",
     [CProp ("equal",[CVar 25; CProp ("zero",[])]); 
      CProp ("equal",[CVar 22; CProp ("one",[])])])])]));;
add (CProp
("equal",
 [CProp ("ge",[CVar 23; CVar 24]); 
  CProp ("not",[CProp ("lt",[CVar 23; CVar 24])])]));;
add (CProp
("equal",
 [CProp ("equal",[CVar 23; CProp ("times",[CVar 23; CVar 24])]); 
  CProp
  ("or",
   [CProp ("equal",[CVar 23; CProp ("zero",[])]); 
    CProp
    ("and",
     [CProp ("numberp",[CVar 23]); 
      CProp ("equal",[CVar 24; CProp ("one",[])])])])]));;
add (CProp
("equal",
 [CProp ("remainder",[CProp ("times",[CVar 24; CVar 23]); CVar 24]); 
  CProp ("zero",[])]));;
add (CProp
("equal",
 [CProp ("equal",[CProp ("times",[CVar 0; CVar 1]); CProp ("one",[])]); 
  CProp
  ("and",
   [CProp ("not",[CProp ("equal",[CVar 0; CProp ("zero",[])])]); 
    CProp ("not",[CProp ("equal",[CVar 1; CProp ("zero",[])])]); 
    CProp ("numberp",[CVar 0]); CProp ("numberp",[CVar 1]); 
    CProp ("equal",[CProp ("sub1",[CVar 0]); CProp ("zero",[])]); 
    CProp ("equal",[CProp ("sub1",[CVar 1]); CProp ("zero",[])])])]));;
add (CProp
("equal",
 [CProp
  ("lt",
   [CProp ("length",[CProp ("delete",[CVar 23; CVar 11])]); 
    CProp ("length",[CVar 11])]); 
  CProp ("member",[CVar 23; CVar 11])]));;
add (CProp
("equal",
 [CProp ("sort2",[CProp ("delete",[CVar 23; CVar 11])]); 
  CProp ("delete",[CVar 23; CProp ("sort2",[CVar 11])])]));;
add (CProp ("equal",[CProp ("dsort",[CVar 23]); CProp ("sort2",[CVar 23])]));;
add (CProp
("equal",
 [CProp
  ("length",
   [CProp
    ("cons",
     [CVar 0; 
      CProp
      ("cons",
       [CVar 1; 
        CProp
        ("cons",
         [CVar 2; 
          CProp
          ("cons",
           [CVar 3; 
            CProp ("cons",[CVar 4; CProp ("cons",[CVar 5; CVar 6])])])])])])])
  ; CProp ("plus",[CProp ("six",[]); CProp ("length",[CVar 6])])]));;
add (CProp
("equal",
 [CProp
  ("difference",
   [CProp ("add1",[CProp ("add1",[CVar 23])]); CProp ("two",[])]); 
  CProp ("fix",[CVar 23])]));;
add (CProp
("equal",
 [CProp
  ("quotient",
   [CProp ("plus",[CVar 23; CProp ("plus",[CVar 23; CVar 24])]); 
    CProp ("two",[])]); 
  CProp
  ("plus",[CVar 23; CProp ("quotient",[CVar 24; CProp ("two",[])])])]));;
add (CProp
("equal",
 [CProp ("sigma",[CProp ("zero",[]); CVar 8]); 
  CProp
  ("quotient",
   [CProp ("times",[CVar 8; CProp ("add1",[CVar 8])]); CProp ("two",[])])]));;
add (CProp
("equal",
 [CProp ("plus",[CVar 23; CProp ("add1",[CVar 24])]); 
  CProp
  ("if",
   [CProp ("numberp",[CVar 24]); 
    CProp ("add1",[CProp ("plus",[CVar 23; CVar 24])]); 
    CProp ("add1",[CVar 23])])]));;
add (CProp
("equal",
 [CProp
  ("equal",
   [CProp ("difference",[CVar 23; CVar 24]); 
    CProp ("difference",[CVar 25; CVar 24])]); 
  CProp
  ("if",
   [CProp ("lt",[CVar 23; CVar 24]); 
    CProp ("not",[CProp ("lt",[CVar 24; CVar 25])]); 
    CProp
    ("if",
     [CProp ("lt",[CVar 25; CVar 24]); 
      CProp ("not",[CProp ("lt",[CVar 24; CVar 23])]); 
      CProp ("equal",[CProp ("fix",[CVar 23]); CProp ("fix",[CVar 25])])])])])
);;
add (CProp
("equal",
 [CProp
  ("meaning",
   [CProp ("plus_tree",[CProp ("delete",[CVar 23; CVar 24])]); CVar 0]); 
  CProp
  ("if",
   [CProp ("member",[CVar 23; CVar 24]); 
    CProp
    ("difference",
     [CProp ("meaning",[CProp ("plus_tree",[CVar 24]); CVar 0]); 
      CProp ("meaning",[CVar 23; CVar 0])]); 
    CProp ("meaning",[CProp ("plus_tree",[CVar 24]); CVar 0])])]));;
add (CProp
("equal",
 [CProp ("times",[CVar 23; CProp ("add1",[CVar 24])]); 
  CProp
  ("if",
   [CProp ("numberp",[CVar 24]); 
    CProp
    ("plus",
     [CVar 23; CProp ("times",[CVar 23; CVar 24]); 
      CProp ("fix",[CVar 23])])])]));;
add (CProp
("equal",
 [CProp ("nth",[CProp ("nil",[]); CVar 8]); 
  CProp
  ("if",[CProp ("zerop",[CVar 8]); CProp ("nil",[]); CProp ("zero",[])])]));;
add (CProp
("equal",
 [CProp ("last",[CProp ("append",[CVar 0; CVar 1])]); 
  CProp
  ("if",
   [CProp ("listp",[CVar 1]); CProp ("last",[CVar 1]); 
    CProp
    ("if",
     [CProp ("listp",[CVar 0]); 
      CProp ("cons",[CProp ("car",[CProp ("last",[CVar 0])]); CVar 1]); 
      CVar 1])])]));;
add (CProp
("equal",
 [CProp ("equal",[CProp ("lt",[CVar 23; CVar 24]); CVar 25]); 
  CProp
  ("if",
   [CProp ("lt",[CVar 23; CVar 24]); 
    CProp ("equal",[CProp ("true",[]); CVar 25]); 
    CProp ("equal",[CProp ("false",[]); CVar 25])])]));;
add (CProp
("equal",
 [CProp ("assignment",[CVar 23; CProp ("append",[CVar 0; CVar 1])]); 
  CProp
  ("if",
   [CProp ("assignedp",[CVar 23; CVar 0]); 
    CProp ("assignment",[CVar 23; CVar 0]); 
    CProp ("assignment",[CVar 23; CVar 1])])]));;
add (CProp
("equal",
 [CProp ("car",[CProp ("gother",[CVar 23])]); 
  CProp
  ("if",
   [CProp ("listp",[CVar 23]); 
    CProp ("car",[CProp ("flatten",[CVar 23])]); CProp ("zero",[])])]));;
add (CProp
("equal",
 [CProp ("flatten",[CProp ("cdr",[CProp ("gother",[CVar 23])])]); 
  CProp
  ("if",
   [CProp ("listp",[CVar 23]); 
    CProp ("cdr",[CProp ("flatten",[CVar 23])]); 
    CProp ("cons",[CProp ("zero",[]); CProp ("nil",[])])])]));;
add (CProp
("equal",
 [CProp ("quotient",[CProp ("times",[CVar 24; CVar 23]); CVar 24]); 
  CProp
  ("if",
   [CProp ("zerop",[CVar 24]); CProp ("zero",[]); 
    CProp ("fix",[CVar 23])])]));;
add (CProp
("equal",
 [CProp ("get",[CVar 9; CProp ("set",[CVar 8; CVar 21; CVar 12])]); 
  CProp
  ("if",
   [CProp ("eqp",[CVar 9; CVar 8]); CVar 21; 
    CProp ("get",[CVar 9; CVar 12])])]));;

print_string "Fin init constantes";;
print_newline();;

(* ******* *)


(*  #open "boyer/terms";; *)

(* Tautology checker *)



let truep (x, lst) =
  match x with
    Prop(head, _) ->
      (eq_string head.name  "true") or mem_term x lst
  | _ ->
      mem_term  x lst

and falsep (x, lst) =
  match x with
    Prop(head, _) ->
      (eq_string head.name  "false")  or mem_term x lst
  | _ ->
      mem_term  x lst
;;

let rec tautologyp (x, true_lst, false_lst) =
 if truep (x, true_lst) then true else
 if falsep (x, false_lst) then false else
 match x with
     Var _ -> false
   | Prop (head,[test; yes; no]) as p ->
(*         print_term p; print_string "\n";  *)
        if eq_string head.name  "if" then
          if truep (test, true_lst) then
            tautologyp (yes, true_lst, false_lst)
          else if falsep (test, false_lst) then
            tautologyp (no, true_lst, false_lst)
          else tautologyp (yes, test::true_lst, false_lst) & 
               tautologyp (no, true_lst, test::false_lst)
        else
          false
;;

let tautp x = 
(*   print_term x; print_string"\n";  *)
  let y = rewrite x in
(*     print_term y; print_string "\n";  *)
    tautologyp (y, [], []);;

(* the benchmark *)

let subst =
[Bind(23,
             Prop
              (get "f",
               [Prop
                (get "plus",
                 [Prop (get "plus",[Var 0; Var 1]);
                  Prop (get "plus",[Var 2; Prop (get "zero",[])])])]));
 Bind(24,
             Prop
              (get "f",
               [Prop
                (get "times",
                 [Prop (get "times",[Var 0; Var 1]);
                  Prop (get "plus",[Var 2; Var 3])])]));
 Bind(25,
             Prop
              (get "f",
               [Prop
                (get "reverse",
                 [Prop
                  (get "append",
                   [Prop (get "append",[Var 0; Var 1]);
                    Prop (get "nil",[])])])]));
 Bind(20,
             Prop
              (get "equal",
               [Prop (get "plus",[Var 0; Var 1]);
                Prop (get "difference",[Var 23; Var 24])]));
 Bind(22,
             Prop
              (get "lt",
               [Prop (get "remainder",[Var 0; Var 1]);
                Prop (get "member",[Var 0; Prop (get "length",[Var 1])])]))]
;;

let term =
           Prop
            (get "implies",
             [Prop
              (get "and",
               [Prop (get "implies",[Var 23; Var 24]);
                Prop
                (get "and",
                 [Prop (get "implies",[Var 24; Var 25]);
                  Prop
                  (get "and",
                   [Prop (get "implies",[Var 25; Var 20]);
                    Prop (get "implies",[Var 20; Var 22])])])]);
              Prop (get "implies",[Var 23; Var 22])])
;;

let go () =
if tautp (apply_subst subst term) then
  print_string "Proved!\n"
else
  print_string "Cannot prove!\n"
;;

print_string "GO";;
print_newline();;
go ();;
print_newline();;
print_int !count_lemma;;
print_newline();;
(* --------- DERIVATIVE    (R.P. Gabriel  p170)
   Appels de fonctions et filtrage *)

   (* Fichier deriv.ml, Pierre Weis *)
(*
Camlot
5.1u 3.6s 0:08.76 100.4% 0+7662k 0+0io 0pf+0w
Caml Light
45.9u 7.5s 0:53.53 100.0% 0+10579k 0+0io 0pf+0w
*)

let rec map f = function [] -> [] | h::t -> (f h)::(map f t);;

type operator = P | M | T | D;;

type dexpr = Numb of int
	| Symbole of string
	| Dexpr of operator * (dexpr list);;

let rec derive =
  let deriv_aux a = Dexpr (D,[derive a; a]) in
  function
    Numb _ -> Numb 0
  | Symbole "x" -> Numb 1
  | Symbole _ -> Numb 0
  | Dexpr (P, lexpr) -> Dexpr (P, map derive lexpr)
  | Dexpr (M, lexpr) -> Dexpr (M, map derive lexpr)
  | Dexpr (T, lexpr) as a -> Dexpr (T, [a ; Dexpr (P, map deriv_aux lexpr)])
  | Dexpr (D, [a1;a2])
           -> Dexpr (M, [Dexpr (D, [derive a1 ; a2]) ;
			Dexpr (D, [a1 ; Dexpr (T, [a2;a2;derive a2])])])
 	    (* FORMULA IS WRONG BUT NEVER USED IN TEST *)
| _ -> failwith "derive";;

let pol = Dexpr (P, [Dexpr (T, [Numb 3; Symbole "x"; Symbole "x"]) ;
                     Dexpr (T, [Symbole "a"; Symbole "x"; Symbole "x"]) ;
                     Dexpr (T, [Symbole "b"; Symbole "x"]) ;
                     Numb 5]);;
let res = ref pol;;

let main() =
	for i = 0 to 999 do		      
	      res := derive pol;
              res := derive pol;
	      res := derive pol;
	      res := derive pol;
	      res := derive pol
	done;;

main();;


type xXunit =  Xtt_C;;
type xXbool =  Xtrue_C |  Xfalse_C;;
type nat =  O_C |  S_C of nat;;
type ('b,'a) prod =  Xpair_C of ('a * 'b) ;;
type sumbool =  Xleft_C |  Xright_C;;
type 'a sumor =  Xinleft_C of 'a |  Xinright_C;;
let xXfst u = (fun (Xpair_C (xVAR3,xVAR4)) -> xVAR3) u;;
let xXsnd u = (fun (Xpair_C (xVAR3,xVAR4)) -> xVAR4) u;;

exception Failure of string;;
let fail () = raise (Failure "fail");;

let le_or_gt n =
 let rec xVAR1 xVAR2 =
  (match xVAR2 with
     O_C -> (fun m -> Xleft_C)
   | S_C xVAR3 ->
       (fun m ->
             (match m with
                O_C -> Xright_C
              | S_C xVAR3prime ->
                  (match xVAR1 xVAR3 xVAR3prime with
                     Xleft_C -> Xleft_C | Xright_C -> Xright_C ))))in
  xVAR1 n;;

let xO_or_S n =
 (match n with O_C -> Xinright_C | S_C xVAR3 -> Xinleft_C xVAR3);;


let le_or_s n =
 let rec xVAR1 xVAR2 =
  (match xVAR2 with
     O_C -> (fun m -> Xleft_C)
   | S_C xVAR3 ->
       (fun m ->
             (match m with
                O_C -> Xright_C
              | S_C xVAR3prime ->
                  (match xVAR1 xVAR3 xVAR3prime with
                     Xleft_C -> Xleft_C | Xright_C -> Xright_C ))))
in
  xVAR1 n
;;

let gt_S_s n m =
 (match le_or_gt n m with
    Xleft_C ->
      (match le_or_s m n with Xleft_C -> Xright_C | Xright_C -> fail ())
  | Xright_C -> Xleft_C);;

let division_extractible n d =
 let rec xVAR1 xVAR2 =
  (match xVAR2 with
     O_C -> Xpair_C (O_C,O_C)
   | S_C xVAR3 ->
       (match d with
          O_C ->
            (match fail () with
                Xleft_C -> Xpair_C (xXfst (xVAR1 xVAR3),S_C (xXsnd (xVAR1 xVAR3)))
              | Xright_C -> Xpair_C (S_C (xXfst (xVAR1 xVAR3)),O_C))
        | S_C xVAR3prime ->
            (match gt_S_s xVAR3prime (xXsnd (xVAR1 xVAR3)) with
               Xleft_C -> Xpair_C (xXfst (xVAR1 xVAR3),S_C (xXsnd (xVAR1 xVAR3))) 
             | Xright_C -> Xpair_C (S_C (xXfst (xVAR1 xVAR3)),O_C) ))) in
  xVAR1 n;;

let xUN = S_C O_C;;

let xDEUX = S_C xUN;;

let xTROIS = S_C xDEUX;;

let rec xPLUS n p = match p with O_C -> n | (S_C m) -> (S_C (xPLUS n m));;

let xSIX = xPLUS xTROIS xTROIS;;

let xDOUZE = xPLUS xSIX xSIX;;

let rec print_nat = function O_C -> print_int 0 | S_C n -> print_string "S_C ";print_nat n;;

let print_resultat = function Xpair_C (a,b) -> print_nat a; print_string "-->";print_nat b;;

print_resultat (division_extractible xDOUZE xDOUZE);;
print_newline();;
(* fac.ml *)

let rec fac = function
   0 -> 1
| n -> n*fac(n-1)
;;

(*print_int (fac 10); print_newline ()
;;*)
fac 10;;

(* fac.ml *)

let rec fac = function
   0 -> 1
| n -> n*fac(n-1)
;;

print_int (fac 10); print_newline ()
;;

let (>=.) a b = a >= b;;


let integrale f a b n =
  
  let h = (b -. a) /. (float_of_int n) in
  let rec integ x =
    if  x >=.  b then 0.0 else (f x) +. integ (x +. h) in 
  integ  a *. h
;;

let poly x = x *. x
;;


let rec repeat n =
  if n <= 0 then 0.0 else (repeat (n-1); integrale poly 0.0 1.0 10000)
;;

print_float (repeat 100);
print_string "\n"
;;
print_newline();;




let eq_string a b = a = b;;

(******* Quelques definitions du prelude CAML **************)

(* 0- les indispensables *)

exception Failure of string;;

let failwith s = raise(Failure s)
;;

(* 1- les paires *)

(* let fst (x,y) = x
and snd (x,y) = y
;;
*)

(* 2- Les listes *)

(*
let prefix
 @ L1 L2 = append_rec L1
  where rec append_rec = function
      []  -> L2
  |  a::L -> a :: append_rec L
;;
*)

let do_list f = let  rec do_rec = function
     []  -> ()
  | a::xL -> f a; do_rec xL in
do_rec  
;;

let map f = let  rec map_rec = function
     []  -> []
  | a::xL -> f a :: map_rec xL
in map_rec 	
;;

let it_list f = let rec it_rec a = function
       []  -> a
    | b::xL -> it_rec (f a b) xL
in it_rec
;;

let it_list2 f = let rec it_rec a l1 l2 = match (l1,l2) with 
     ([],[])    -> a
   | ((a1::q1),(a2::q2)) -> it_rec (f a (a1,a2)) q1 q2
   |     _     -> failwith "it_list2"
in it_rec	 
;;

let fold f = let rec fold_rec a1 = function
    [] -> (a1,[])
  | b1::bl ->
      let (a2,c2) = f a1 b1 in
      let (a,cl) = fold_rec a2 bl in
        (a, c2::cl)
in fold_rec	
;;

let exists p = let rec exists_rec = function
     []  -> false
  | a::xL -> (p a) or (exists_rec xL)
in exists_rec 
;;

let for_all p = let rec for_all_rec = function
     []  -> true
  | a::xL -> (p a) & (for_all_rec xL)
in for_all_rec 
;;

let rec rev_append l1 l2 = match l1 with 
   []  -> l2
   | (x::q1)  -> rev_append q1 (x::l2)
;;

let rev l = rev_append l []
;;

 
let rec length = function
     []  -> 0
  | a::xL -> succ(length xL)
;;

let try_find f = let rec try_find_rec = function
     []  -> failwith "try_find"
  | a::l -> try f a with Failure _ -> try_find_rec l
in try_find_rec;;

let partition p = let rec part_rec = function
     []  -> [],[]
  | a::xL -> let (pos,neg) = part_rec xL in
              if p a then  a::pos, neg else pos, a::neg
in part_rec
;;

(* 3- Les ensembles et les listes d'association *)


let mem eq a = let  rec mem_rec = function
     []  -> false
  | b::xL -> eq (a,b) or mem_rec xL
in mem_rec;;

let union eq xL1 xL2 = 
  let  rec union_rec = function
      []  -> xL2
   | a::xL -> if mem eq a xL2 then union_rec xL else a :: union_rec xL
  in union_rec xL1
;;


let mem_assoc eq a = let rec mem_rec = function
       []    -> false
  | (b,_)::xL -> eq(a,b) or mem_rec xL
in mem_rec
;;


let rec assoc eq a = 
function  [] -> failwith "find"
  | (b,d)::l -> if eq(a,b) then d else assoc eq a l
;;
(*

let mem a = let rec mem_rec = function
     []  -> false
  | b::xL -> a=b or mem_rec xL
in mem_rec;;

let union xL1 xL2 = let rec union_rec = function
      []  -> xL2
   | a::xL -> if mem a xL2 then union_rec xL else a :: union_rec xL
  in union_rec xL1
;;


let mem_assoc a = mem_rec where rec mem_rec = function
       []    -> false
  | (b,_)::L -> a=b or mem_rec L
;;

let assoc a = assoc_rec where rec assoc_rec = function
       []    -> failwith "find"
  | (b,d)::L -> if a=b then d else assoc_rec L
;;
*)
(* 4- Les sorties *)

(*
let print_newline () = print_string "\n"; flush std_out
;;
*)
let message s = print_string s; print_newline()
;;

let eq_int(a,b)=a==b;;
let eq2_string (a,b)= eq_string a b (*eq_string a b*);;

(* #open "prelude";;
*)

type term = Var of int
          | Term of string * term list;;

let rec eq_term (xM,xN) = 
   (* print_string "--->";pretty_term xN;print_string " =? ";pretty_term xM;print_newline();*)
   (match (xM,xN) with 
   (Var i),( Var j) -> eq_int(i,j)
  | (Term(s1,l1)), (Term(s2,l2)) -> eq2_string (s1,s2) & eq_term_list(l1,l2)
  | _ -> false)

and eq_term_list = function
    [], [] -> true
  | t1::l1, t2::l2 -> eq_term(t1,t2) & eq_term_list(l1,l2)
  | _ -> false
;;

let rec vars = function
    Var n -> [n]
  | Term(_,xL) -> vars_of_list xL
and vars_of_list = function
    [] -> []
  | t::r -> union eq_int (vars t) (vars_of_list r)
;;

let substitute subst = let rec subst_rec = function
    Term(oper,sons) -> Term(oper, map subst_rec sons)
  | Var(n) as t     -> try assoc eq_int n subst with Failure _ -> t
in subst_rec 
;;

let change f = let rec change_rec l n = match l with 
  (h::t) -> (* print_int n; print_string "\n"; *)
                  if n==1 then f h :: t else h :: change_rec t (n-1)
   |        _ -> failwith "change"
in change_rec 
;;

(* Term replacement replace xM u xN => xM[u<-xN] *)
let replace xM u xN = let rec reprec = function
    _, [] -> xN
  | Term(oper,sons), (n::u) ->
             Term(oper, change (fun xP -> reprec(xP,u)) sons n)
  | _ -> failwith "replace"
in reprec(xM,u)
;;

(* matching = - : (term -> term -> subst) *)
let matching term1 term2 =
  let rec match_rec subst = function
      Var v, xM ->
        if mem_assoc eq_int v subst then
          if eq_term (xM ,assoc eq_int v subst) then subst else failwith "matching"
        else
          (v,xM) :: subst
    | Term(op1,sons1), Term(op2,sons2) ->
	if eq2_string (op1,op2) then it_list2 match_rec subst sons1 sons2
                     else failwith "matching"
    | _ -> failwith "matching" in
  match_rec [] (term1,term2)
;;

(* A naive unification algorithm *)

let compsubst subst1 subst2 = 
  (map (fun (v,t) -> (v, substitute subst1 t)) subst2) @ subst1
;;

let occurs n = let rec occur_rec = function
    Var m -> m=n
  | Term(_,sons) -> exists occur_rec sons
in occur_rec 
;;

let rec unify = function
    (Var n1 as term1), term2 ->
      if eq_term(term1,term2) then []
      else if occurs n1 term2 then failwith "unify1"
      else [n1,term2]
  | term1, Var n2 ->
      if occurs n2 term1 then failwith "unify2"
      else [n2,term1]
  | Term(op1,sons1), Term(op2,sons2) ->
      if eq2_string (op1,op2) then 
	it_list2 (fun s (t1,t2) -> compsubst (unify(substitute s t1,
                                                    substitute s t2)) s)
                 [] sons1 sons2
      else failwith "unify3"
;;

(* We need to print terms with variables independently from input terms
  obtained by parsing. We give arbitrary names v1,v2,... to their variables. *)

let xINFIXES = ["+";"*"];;

let rec pretty_term = function
    Var n ->
      print_string "v"; print_int n
  | Term (oper,sons) ->
      if mem eq2_string oper xINFIXES then
        match sons with
            [s1;s2] ->
              pretty_close s1; print_string oper; pretty_close s2
          | _ ->
              failwith "pretty_term : infix arity <> 2"
      else
       (print_string oper;
        match sons with
	     []   -> ()
          | t::lt -> print_string "(";
                     pretty_term t;
                     do_list (fun t -> print_string ","; pretty_term t) lt;
                     print_string ")")
and pretty_close = function
    Term(oper, _) as m ->
      if mem eq2_string  oper xINFIXES then
        (print_string "("; pretty_term m; print_string ")")
      else pretty_term m
  | m -> pretty_term m
;;

(****************** Equation manipulations *************)

(* #open "prelude";;
#open "terms";;
*)

(* standardizes an equation so its variables are 1,2,... *)

let mk_rule xM xN =
  let all_vars = union eq_int (vars xM) (vars xN) in
  let (k,subst) =
    it_list (fun (i,sigma) v -> (i+1,(v,Var(i))::sigma)) (1,[]) all_vars in
  (k-1, (substitute subst xM, substitute subst xN))
;;

(* checks that rules are numbered in sequence and returns their number *)
let check_rules =
  it_list (fun n (k,_) -> if k==n+1 then k
                          else failwith "Rule numbers not in sequence") 0
;;

let pretty_rule (k,(n,(xM,xN))) =
  print_int k; print_string " : ";
  pretty_term xM; print_string " = "; pretty_term xN;
  print_newline()
;;

let pretty_rules = do_list pretty_rule
;; 

(****************** Rewriting **************************)

(* Top-level rewriting. Let eq:L=R be an equation, xM be a term such that L<=xM.
   With sigma = matching L xM, we define the image of xM by eq as sigma(R) *)
let reduce xL xM =
  substitute (matching xL xM)
;;

(* A more efficient version of can (rewrite1 (xL,R)) for R arbitrary *)
let reducible xL = let rec redrec xM =
    try
      matching xL xM; true
    with Failure _ ->
      match xM with Term(_,sons) -> exists redrec sons
                |         _     -> false
in redrec
;;

(* mreduce : rules -> term -> term *)
let mreduce rules xM =
  let redex (_,(_,(xL,xR))) = reduce xL xM xR in try_find redex rules
;;

(* One step of rewriting in leftmost-outermost strategy, with multiple rules *)
(* fails if no redex is found *)
(* mrewrite1 : rules -> term -> term *)
let mrewrite1 rules = let rec rewrec xM =
    try
      mreduce rules xM
    with Failure _ ->
      let rec tryrec = function
          [] -> failwith "mrewrite1"
        | son::rest ->
            try
              rewrec son :: rest
            with Failure _ ->
              son :: tryrec rest in
      match xM with
          Term(f, sons) -> Term(f, tryrec sons)
        | _ -> failwith "mrewrite1"
in rewrec
;;

(* Iterating rewrite1. Returns a normal form. xMay loop forever *)
(* mrewrite_all : rules -> term -> term *)
let mrewrite_all rules xM = let  rec rew_loop xM =
    try
      rew_loop(mrewrite1 rules xM)
    with Failure _ ->
      xM
in rew_loop xM
;;

(*
pretty_term (mrewrite_all Group_rules M where M,_=<<A*(I(B)*B)>>);;
==> A*U
*)


(*********************** Recursive Path Ordering ****************************)

(* #open "prelude";;
#open "terms";;
*)
type ordering = Greater | Equal | NotGE;;

let ge_ord order pair = match order pair with NotGE -> false | _ -> true
and gt_ord order pair = match order pair with Greater -> true | _ -> false
and eq_ord order pair = match order pair with Equal -> true | _ -> false
;;

let rem_eq equiv = let rec remrec x = function
     []  -> failwith "rem_eq"
  | y::l -> if equiv (x,y) then l else y :: remrec x l
in remrec
;;

let diff_eq equiv (x,y) =
  let rec diffrec = function
      ([],_) as p -> p
    | (h::t, y)   -> try diffrec (t,rem_eq equiv h y)
                     with Failure _ ->
                       let (x_prime,y_prime) = diffrec (t,y) in (h::x_prime,y_prime) in
  if length x > length y then diffrec(y,x) else diffrec(x,y)
;;

(* multiset extension of order *)
let mult_ext order = function
    Term(_,sons1), Term(_,sons2) ->
      (match diff_eq (eq_ord order) (sons1,sons2) with
           ([],[]) -> Equal
         | (l1,l2) ->
              if for_all (fun xN -> exists (fun xM -> order (xM,xN) = Greater) l1) l2
              then Greater else NotGE)
  | _ -> failwith "mult_ext"
;;

(* lexicographic extension of order *)
let lex_ext order = function
    ((Term(_,sons1) as xM), (Term(_,sons2) as xN)) ->
      let rec lexrec = function
        ([] , []) -> Equal
      | ([] , _ ) -> NotGE
      | ( _ , []) -> Greater
      | (x1::l1, x2::l2) ->
          match order (x1,x2) with
            Greater -> if for_all (fun xN_prime -> gt_ord order (xM,xN_prime)) l2 
                       then Greater else NotGE
          | Equal -> lexrec (l1,l2)
          | NotGE -> if exists (fun xM_prime -> ge_ord order (xM_prime,xN)) l1 
                     then Greater else NotGE in
      lexrec (sons1, sons2)
  | _ -> failwith "lex_ext"
;;

(* recursive path ordering *)
(* rpo : (string -> string -> ordering) -> (string -> extension) -> term_pair -> ordering *)
let rpo op_order ext = let rec rporec (xM,xN) =
    if eq_term(xM,xN) then Equal else 
      match xM with
          Var m -> NotGE
        | Term(op1,sons1) ->
            match xN with
                Var n ->
                  if occurs n xM then Greater else NotGE
              | Term(op2,sons2) ->
                  match (op_order op1 op2) with
                      Greater ->
                        if for_all (fun xN_prime -> gt_ord rporec (xM,xN_prime)) sons2
                        then Greater else NotGE
                    | Equal ->
                        ext rporec (xM,xN)
                    | NotGE ->
                        if exists (fun xM_prime -> ge_ord rporec (xM_prime,xN)) sons1
                        then Greater else NotGE
in rporec
;;


(*#open "prelude";;
#open "terms";;
#open "equations";;
*)
(****************** Critical pairs *********************)

(* All (u,sig) such that xN/u (&var) unifies with M,
   with principal unifier sig *)
(* super : term -> term -> (num list & subst) list *)
let super xM =
  let rec suprec xN = match xN with
    Term(_,sons) as xN ->
      let collate (pairs,n) son =
       ((pairs @
	   (map (function (u,xsig) ->
		    (n::u,xsig)) (suprec son))),
	    n+1) in
      let insides = fst (it_list collate ([],1) sons) in
       (try
          ([], unify(xM,xN)) :: insides
        with Failure _ -> insides)
  | _ -> []
in suprec
;;

(* Ex :
let (xM,_) = <<F(A,B)>> 
and (xN,_) = <<H(F(A,x),F(x,y))>> in super xM xN;;
==> [[1],[2,Term ("B",[])];                      x <- B
     [2],[2,Term ("A",[]); 1,Term ("B",[])]]     x <- A  y <- B
*)

(* All (u,sig), u&[], such that N/u unifies with xM *)
(* super_strict : term -> term -> (num list & subst) list *)
let super_strict xM = function
      Term(_,sons) ->
        let collate (pairs,n) son =
          (pairs @ map (function (u,xsig) -> (n::u,xsig)) (super xM son), n+1) in
        fst (it_list collate ([],1) sons)
    | _ -> []
;;

(* Critical pairs of L1=R1 with L2=R2 *)
(* critical_pairs : term_pair -> term_pair -> term_pair list *)
let critical_pairs (xL1,xR1) (xL2,xR2) =
  let mk_pair (u,xsig) =
     substitute xsig (replace xL2 u xR1), substitute xsig xR2 in
  map mk_pair (super xL1 xL2);;

(* Strict critical pairs of L1=R1 with L2=R2 *)
(* strict_critical_pairs : term_pair -> term_pair -> term_pair list *)
let strict_critical_pairs (xL1,xR1) (xL2,xR2) =
  let mk_pair (u,xsig) =
    substitute xsig (replace xL2 u xR1), substitute xsig xR2 in
  map mk_pair (super_strict xL1 xL2)
;;

(* All critical pairs of eq1 with eq2 *)
let mutual_critical_pairs eq1 eq2 =
  (strict_critical_pairs eq1 eq2) @ (critical_pairs eq2 eq1);;

(* Renaming of variables *)

let rename n (t1,t2) =
  let rec ren_rec = function
    Var k -> Var(k+n)
  | Term(op,sons) -> Term(op, map ren_rec sons) in
  (ren_rec t1, ren_rec t2)
;;

(************************ Completion ******************************)

let deletion_message (k,_) =
  print_string "Rule ";print_int k; message " deleted"
;;

(* Generate failure message *)
let non_orientable (xM,xN) =
    pretty_term xM; print_string " = "; pretty_term xN; print_newline()
;;

(* Improved Knuth-Bendix completion procedure *)
(* kb_completion : (term_pair -> bool) -> num -> rules -> term_pair list ->
     (num & num) -> term_pair list -> rules *)

let kb_completion greater =
  let  rec kbrec n rules =
    let normal_form = mrewrite_all rules 
    and get_rule k = assoc eq_int k rules in 
    let rec process failures = ( 
    let rec processf (k,l) = (
    let rec processkl eqs = (
(**
     print_string "***kb_completion "; print_int n; print_newline();
     pretty_rules rules;
     do_list non_orientable failures;
     print_int k; print_string " "; print_int l; print_newline();
     do_list non_orientable eqs;
**)
     match eqs with
     [] ->
      if k<l then next_criticals (k+1,l) else
      if l<n then next_criticals (1,l+1) else
       (match failures with
          [] -> rules (* successful completion *)
        | _  -> message "Non-orientable equations :";
                do_list non_orientable failures;
                failwith "kb_completion")
   | (xM,xN)::eqs ->
      let xM_prime = normal_form xM
      and xN_prime = normal_form xN
      and enter_rule(left,right) =
        let new_rule = (n+1, mk_rule left right) in
          pretty_rule new_rule;
          let left_reducible (_,(_,(xL,_))) = reducible left xL in
          let redl,irredl = partition left_reducible rules in
            do_list deletion_message redl;
            let irreds = let right_reduce (m,(_,(xL,xR))) = 
                       m,mk_rule xL (mrewrite_all (new_rule::rules) xR) in
               (map right_reduce irredl)
                 
            and eqs_prime = map (function (_,(_,pair)) -> pair) redl in
             kbrec (n+1) (new_rule::irreds) [] (k,l)
	       (eqs @ eqs_prime @ failures)
  in
      if eq_term(xM_prime,xN_prime) then processkl eqs else
      if greater(xM_prime,xN_prime) then enter_rule(xM_prime,xN_prime) else
      if greater(xN_prime,xM_prime) then enter_rule(xN_prime,xM_prime) else
        process ((xM_prime,xN_prime)::failures) (k,l) eqs
    ) and next_criticals (k,l) = (
(**
    print_string "***next_criticals ";
    print_int k; print_string " "; print_int l ; print_newline();
**)
    try
      let (v,el) = get_rule l in
        if k=l then
          processf (k,l) (strict_critical_pairs el (rename v el))
        else
          try
            let (_,ek) = get_rule k in 
              processf (k,l) (mutual_critical_pairs el (rename v ek))
	  with Failure "find" (*rule k deleted*) -> next_criticals (k+1,l)
    with Failure "find" (*rule l deleted*) -> next_criticals (1,l+1)
    ) in  processkl
    )  in processf
    ) in process  					     	          


    
  in   kbrec	
;;

(* complete_rules is assumed locally confluent, and checked Noetherian with
  ordering greater, rules is any list of rules *)

let kb_complete greater complete_rules rules =
    let n = check_rules complete_rules
    and eqs = map (fun (_,(_,pair)) -> pair) rules in
    let completed_rules =
      kb_completion greater n complete_rules [] (n,n) eqs in
    message "Canonical set found :";
    pretty_rules (rev completed_rules);()
;;


(*#open "prelude";;
#open "terms";;
#open "equations";;
#open "orderings";;
#open "kb";;
*)
let xGroup_rules = [
  1, (1, (Term("*", [Term("U",[]); Var 1]), Var 1));
  2, (1, (Term("*", [Term("I",[Var 1]); Var 1]), Term("U",[])));
  3, (3, (Term("*", [Term("*", [Var 1; Var 2]); Var 3]),
          Term("*", [Var 1; Term("*", [Var 2; Var 3])])))
];;

let xGroup_precedence op1 op2 =
  if eq_string op1  op2 then Equal else
  if (eq_string op1  "I") or (eq_string op2  "U") then Greater else NotGE
;;


(***
let xGeom_rules = [
 1,(1,(Term ("*",[(Term ("U",[])); (Var 1)]),(Var 1)));
 2,(1,(Term ("*",[(Term ("I",[(Var 1)])); (Var 1)]),(Term ("U",[]))));
 3,(3,(Term ("*",[(Term ("*",[(Var 1); (Var 2)])); (Var 3)]),
  (Term ("*",[(Var 1); (Term ("*",[(Var 2); (Var 3)]))]))));
 4,(0,(Term ("*",[(Term ("A",[])); (Term ("B",[]))]),
  (Term ("*",[(Term ("B",[])); (Term ("A",[]))]))));
 5,(0,(Term ("*",[(Term ("C",[])); (Term ("C",[]))]),(Term ("U",[]))));
 6,(0,
  (Term
   ("*",
    [(Term ("C",[]));
     (Term ("*",[(Term ("A",[])); (Term ("I",[(Term ("C",[]))]))]))]),
  (Term ("I",[(Term ("A",[]))]))));
 7,(0,
  (Term
   ("*",
    [(Term ("C",[]));
     (Term ("*",[(Term ("B",[])); (Term ("I",[(Term ("C",[]))]))]))]),
  (Term ("B",[]))))
];;

let xGeom_rank = function
    "U" -> 0
  | "*" -> 1
  | "I" -> 2
  | "B" -> 3
  | "C" -> 4
  | "A" -> 5
;;

let xGeom_precedence op1 op2 =
  let r1 = xGeom_rank op1
  and r2 = xGeom_rank op2 in
    if r1 = r2 then Equal else
    if r1 > r2 then Greater else NotGE
;;

***)

let xGroup_order = rpo xGroup_precedence lex_ext 
;;

let greater pair =
  match xGroup_order pair with Greater -> true | _ -> false
;;



kb_complete greater [] xGroup_rules
;;

kb_complete greater [] xGroup_rules
;;

kb_complete greater [] xGroup_rules
;;

kb_complete greater [] xGroup_rules
;;


let atan2 (a,b) = atan2 a b;;
let sub_int (a,b) =  a - b;;

type intg = int;;

(* -- MATH UTILITIES --------------------------------------------------------*)

let constant_pi        =  3.14159265358979323846;;
let constant_minus_pi  = -3.14159265358979323846;;
let constant_pi2       =  1.57079632679489661923;;
let constant_minus_pi2 = -1.57079632679489661923;;

(* -- POINTS ----------------------------------------------------------------*)

type pt = float * float * float;;

let
pt_sub ((x1,y1,z1):pt) ((x2,y2,z2):pt)
  = (x1 -. x2, y1 -. y2, z1 -. z2)
;;

let
pt_dist ((x1,y1,z1):pt) ((x2,y2,z2):pt)
  = let dx = x1 -. x2
    and dy = y1 -. y2
    and dz = z1 -. z2
    in
      sqrt ((dx *. dx) +. (dy *. dy) +. (dz *. dz))
;;

let
pt_phi ((x,y,z):pt)
  = let b = atan2 (x, z)
    in
      atan2 (((cos b) *. z +. (sin b) *. x), y)
;;

let
pt_theta ((x,y,z):pt)
  =  atan2(x, z)
;;

(* -.-. COORDINATE TRANSFORMATIONS -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

(*
   The notation for the transformations follows "Paul, R.P. (1981) Robot
   Manipulators.  MIT Press." with the exception that our transformation
   matrices don't have the perspective terms and are the transpose of
   Paul's one.  See also "M\"antyl\"a, M. (1985) An Introduction to
   Solid Modeling, Computer Science Press" Appendix A.
  
   The components of a transformation matrix are named like this:
  
    a  b  c
    d  e  f
    g  h  i
   tx ty tz
  
   The components tx, ty, and tz are the translation vector.
*)

type tfo =
  {a: float;
   b: float;
   c: float;
   d: float;
   e: float;
   f: float;
   g: float;
   h: float;
   i: float;
   tx: float;
   ty: float;
   tz: float}
;;

let tfo_id = {a=1.0; b=0.0; c=0.0; d=0.0; e=1.0; f=0.0; g=0.0; h=0.0; i=1.0; tx=0.0; ty=0.0; tz=0.0};;

(*
   The function "tfo-.apply" multiplies a transformation matrix, tfo, by a
   point vector, p.  The result is a new point.
*)

let
tfo_apply t ((x,y,z):pt)
  = (
      ((x *. t.a) +. (y *. t.d) +. (z *. t.g) +. t.tx)
      ,
      ((x *. t.b) +. (y *. t.e) +. (z *. t.h) +. t.ty)
      ,
      ((x *. t.c) +. (y *. t.f) +. (z *. t.i) +. t.tz)
    )
;;

(*
   The function "tfo-.combine" multiplies two transformation matrices A and B.
   The result is a new matrix which cumulates the transformations described
   by A and B.
*)

let
tfo_combine a b =
  let a_a = a.a  and a_b = a.b  and a_c = a.c  and a_d = a.d
  and a_e = a.e  and a_f = a.f  and a_g = a.g  and a_h = a.h
  and a_i = a.i  and a_tx = a.tx  and a_ty = a.ty  and a_tz = a.tz
  and b_a = b.a  and b_b = b.b  and b_c = b.c  and b_d = b.d
  and b_e = b.e  and b_f = b.f  and b_g = b.g  and b_h = b.h
  and b_i = b.i  and b_tx = b.tx  and b_ty = b.ty  and b_tz = b.tz in
    { a = ((a_a *. b_a) +. (a_b *. b_d) +. (a_c *. b_g));
      b = ((a_a *. b_b) +. (a_b *. b_e) +. (a_c *. b_h));
      c = ((a_a *. b_c) +. (a_b *. b_f) +. (a_c *. b_i));
      d = ((a_d *. b_a) +. (a_e *. b_d) +. (a_f *. b_g));
      e = ((a_d *. b_b) +. (a_e *. b_e) +. (a_f *. b_h));
      f = ((a_d *. b_c) +. (a_e *. b_f) +. (a_f *. b_i));
      g = ((a_g *. b_a) +. (a_h *. b_d) +. (a_i *. b_g));
      h = ((a_g *. b_b) +. (a_h *. b_e) +. (a_i *. b_h));
      i = ((a_g *. b_c) +. (a_h *. b_f) +. (a_i *. b_i));
      tx = ((a_tx *. b_a) +. (a_ty *. b_d) +. (a_tz *. b_g) +. b_tx);
      ty = ((a_tx *. b_b) +. (a_ty *. b_e) +. (a_tz *. b_h) +. b_ty);
      tz = ((a_tx *. b_c) +. (a_ty *. b_f) +. (a_tz *. b_i) +. b_tz)
    }
;;
(*
   The function "tfo-.inv-.ortho" computes the inverse of a homogeneous
   transformation matrix.
*)

let
tfo_inv_ortho t =
  { a = t.a; b = t.d; c = t.g;
    d = t.b; e = t.e; f = t.h;
    g = t.c; h = t.f; i = t.i;
    tx = (-.((t.a *. t.tx) +. (t.b *. t.ty) +. (t.c *. t.tz)));
    ty = (-.((t.d *. t.tx) +. (t.e *. t.ty) +. (t.f *. t.tz)));
    tz = (-.((t.g *. t.tx) +. (t.h *. t.ty) +. (t.i *. t.tz)))
  }
;;

(*
   Given three points p1, p2, and p3, the function "tfo-.align" computes
   a transformation matrix such that point p1 gets mapped to (0,0,0), p2 gets
   mapped to the Y axis and p3 gets mapped to the YZ plane.
*)

let
tfo_align ((x1,y1,z1):pt) ((x2,y2,z2):pt) ((x3,y3,z3):pt)
  = let x31 = x3 -. x1 in
    let y31 = y3 -. y1 in
    let z31 = z3 -. z1 in
    let rotpy = pt_sub (x2,y2,z2) (x1,y1,z1) in
    let phi = pt_phi rotpy in
    let theta = pt_theta rotpy in
    let sinp = sin phi in
    let sint = sin theta in
    let cosp = cos phi in
    let cost = cos theta in
    let sinpsint = sinp *. sint in
    let sinpcost = sinp *. cost in
    let cospsint = cosp *. sint in
    let cospcost = cosp *. cost in
    let rotpz = (
                    ((cost *. x31) -. (sint *. z31))
                    ,
                    ((sinpsint *. x31) +. (cosp *. y31) +. (sinpcost *. z31))
                    ,
                    ((cospsint *. x31) +. (-.(sinp *. y31)) +. (cospcost *. z31))
                  ) in
    let rho = pt_theta rotpz in
    let cosr = cos rho in
    let sinr = sin rho in
    let x = (-.(x1 *. cost)) +. (z1 *. sint) in
    let y = ((-.(x1 *. sinpsint)) -. (y1 *. cosp)) -. (z1 *. sinpcost) in
    let z = ((-.(x1 *. cospsint) +. (y1 *. sinp))) -. (z1 *. cospcost) in
      { a = ((cost *. cosr) -. (cospsint *. sinr));
        b = sinpsint;
        c = ((cost *. sinr) +. (cospsint *. cosr));
        d = (sinp *. sinr);
        e = cosp;
        f = (-.(sinp *. cosr));
        g = ((-.(sint *. cosr)) -. (cospcost *. sinr));
        h = sinpcost;
        i = ((-.(sint *. sinr) +. (cospcost *. cosr)));
        tx = ((x *. cosr) -. (z *. sinr));
        ty = y;
        tz = ((x *. sinr +. (z *. cosr)))
      }
;;

(* -.-. NUCLEIC ACID CONFORMATIONS DATA BASE -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

(*
   Numbering of atoms follows the paper:
  
   IUPAC-.IUB Joint Commission on Biochemical Nomenclature (JCBN)
   (1983) Abbreviations and Symbols for the Description of
   Conformations of Polynucleotide Chains.  Eur. J. Biochem 131,
   9-.15.
*)

(* Define remaining atoms for each nucleotide type. *)

type nuc_specific =
  A of pt*pt*pt*pt*pt*pt*pt*pt
| C of pt*pt*pt*pt*pt*pt
| G of pt*pt*pt*pt*pt*pt*pt*pt*pt
| U of pt*pt*pt*pt*pt
;;

(*
   A n6 n7 n9 c8 h2 h61 h62 h8
   C n4 o2 h41 h42 h5 h6
   G n2 n7 n9 c8 o6 h1 h21 h22 h8
   U o2 o4 h3 h5 h6
*)

(* Define part common to all 4 nucleotide types. *)

type nuc =
  N of tfo*tfo*tfo*tfo*
       pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*
       pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*pt*
       pt*nuc_specific
;;

(*
    dgf_base_tfo  ; defines the standard position for wc and wc_dumas
    p_o3'_275_tfo ; defines the standard position for the connect function
    p_o3'_180_tfo
    p_o3'_60_tfo
    p o1p o2p o5' c5' h5' h5'' c4' h4' o4' c1' h1' c2' h2'' o2' h2' c3'
    h3' o3' n1 n3 c2 c4 c5 c6
*)

let is_A = function
     N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
      p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
      c3',h3',o3',n1,n3,c2,c4,c5,c6,A(_,_,_,_,_,_,_,_)) -> true
   | _ -> false
;;

let is_C = function
     N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
      p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
      c3',h3',o3',n1,n3,c2,c4,c5,c6,C(_,_,_,_,_,_)) -> true
  | _ -> false
;;

let is_G = function
     N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
      p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
      c3',h3',o3',n1,n3,c2,c4,c5,c6,G(_,_,_,_,_,_,_,_,_)) -> true
  | _ -> false
;;

let
nuc_C1'
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = c1'
;;

let
nuc_C2 
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = c2
;;

let
nuc_C3'
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = c3'
;;

let
nuc_C4 
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = c4
;;

let
nuc_C4'
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = c4'
;;

let
nuc_N1 
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = n1
;;

let
nuc_O3'
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = o3'
;;

let
nuc_P
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = p
;;

let
nuc_dgf_base_tfo
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = dgf_base_tfo
;;

let
nuc_p_o3'_180_tfo
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = p_o3'_180_tfo
;;

let
nuc_p_o3'_275_tfo
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = p_o3'_275_tfo
;;

let
nuc_p_o3'_60_tfo
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,_))
  = p_o3'_60_tfo
;;

let
rA_N9  
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,A (n6,n7,n9,c8,h2,h61,h62,h8)))
  = n9
;;

let
rG_N9  
(N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,G (n2,n7,n9,c8,o6,h1,h21,h22,h8)))
  = n9
;;

(* Database of nucleotide conformations: *)

let rA
  = N(
      {    a= -.0.0018; b= -.0.8207; c=0.5714; (* dgf_base_tfo *)
           d=0.2679; e= -.0.5509; f= -.0.7904;
           g=0.9634; h=0.1517; i=0.2209;
           tx=0.0073; ty=8.4030; tz=0.6232 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4550),   (8.2120),  (-.2.8810)), (* C5'  *)
      (    (5.4546),   (8.8508),  (-.1.9978)), (* H5'  *)
      (    (5.7588),   (8.6625),  (-.3.8259)), (* H5'' *)
      (    (6.4970),   (7.1480),  (-.2.5980)), (* C4'  *)
      (    (7.4896),   (7.5919),  (-.2.5214)), (* H4'  *)
      (    (6.1630),   (6.4860),  (-.1.3440)), (* O4'  *)
      (    (6.5400),   (5.1200),  (-.1.4190)), (* C1'  *)
      (    (7.2763),   (4.9681),  (-.0.6297)), (* H1'  *)
      (    (7.1940),   (4.8830),  (-.2.7770)), (* C2'  *)
      (    (6.8667),   (3.9183),  (-.3.1647)), (* H2'' *)
      (    (8.5860),   (5.0910),  (-.2.6140)), (* O2'  *)
      (    (8.9510),   (4.7626),  (-.1.7890)), (* H2'  *)
      (    (6.5720),   (6.0040),  (-.3.6090)), (* C3'  *)
      (    (5.5636),   (5.7066),  (-.3.8966)), (* H3'  *)
      (    (7.3801),   (6.3562),  (-.4.7350)), (* O3'  *)
      (    (4.7150),   (0.4910),  (-.0.1360)), (* N1   *)
      (    (6.3490),   (2.1730),  (-.0.6020)), (* N3   *)
      (    (5.9530),   (0.9650),  (-.0.2670)), (* C2   *)
      (    (5.2900),   (2.9790),  (-.0.8260)), (* C4   *)
      (    (3.9720),   (2.6390),  (-.0.7330)), (* C5   *)
      (    (3.6770),   (1.3160),  (-.0.3660)), (* C6 *)
      (A (
      (    (2.4280),   (0.8450),  (-.0.2360)), (* N6   *)
      (    (3.1660),   (3.7290),  (-.1.0360)), (* N7   *)
      (    (5.3170),   (4.2990),  (-.1.1930)), (* N9   *)
      (    (4.0100),   (4.6780),  (-.1.2990)), (* C8   *)
      (    (6.6890),   (0.1903),  (-.0.0518)), (* H2   *)
      (    (1.6470),   (1.4460),  (-.0.4040)), (* H61  *)
      (    (2.2780),  (-.0.1080),  (-.0.0280)), (* H62  *)
      (    (3.4421),   (5.5744),  (-.1.5482))) (* H8   *)
      )
    )
;;

let rA01
  = N(
      {    a= -.0.0043; b= -.0.8175; c=0.5759; (* dgf_base_tfo *)
           d=0.2617; e= -.0.5567; f= -.0.7884;
           g=0.9651; h=0.1473; i=0.2164;
           tx=0.0359; ty=8.3929; tz=0.5532 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4352),   (8.2183),  (-.2.7757)), (* C5'  *)
      (    (5.3830),   (8.7883),  (-.1.8481)), (* H5'  *)
      (    (5.7729),   (8.7436),  (-.3.6691)), (* H5'' *)
      (    (6.4830),   (7.1518),  (-.2.5252)), (* C4'  *)
      (    (7.4749),   (7.5972),  (-.2.4482)), (* H4'  *)
      (    (6.1626),   (6.4620),  (-.1.2827)), (* O4'  *)
      (    (6.5431),   (5.0992),  (-.1.3905)), (* C1'  *)
      (    (7.2871),   (4.9328),  (-.0.6114)), (* H1'  *)
      (    (7.1852),   (4.8935),  (-.2.7592)), (* C2'  *)
      (    (6.8573),   (3.9363),  (-.3.1645)), (* H2'' *)
      (    (8.5780),   (5.1025),  (-.2.6046)), (* O2'  *)
      (    (8.9516),   (4.7577),  (-.1.7902)), (* H2'  *)
      (    (6.5522),   (6.0300),  (-.3.5612)), (* C3'  *)
      (    (5.5420),   (5.7356),  (-.3.8459)), (* H3'  *)
      (    (7.3487),   (6.4089),  (-.4.6867)), (* O3'  *)
      (    (4.7442),   (0.4514),  (-.0.1390)), (* N1   *)
      (    (6.3687),   (2.1459),  (-.0.5926)), (* N3   *)
      (    (5.9795),   (0.9335),  (-.0.2657)), (* C2   *)
      (    (5.3052),   (2.9471),  (-.0.8125)), (* C4   *)
      (    (3.9891),   (2.5987),  (-.0.7230)), (* C5   *)
      (    (3.7016),   (1.2717),  (-.0.3647)), (* C6 *)
      (A (
      (    (2.4553),   (0.7925),  (-.0.2390)), (* N6   *)
      (    (3.1770),   (3.6859),  (-.1.0198)), (* N7   *)
      (    (5.3247),   (4.2695),  (-.1.1710)), (* N9   *)
      (    (4.0156),   (4.6415),  (-.1.2759)), (* C8   *)
      (    (6.7198),   (0.1618),  (-.0.0547)), (* H2   *)
      (    (1.6709),   (1.3900),  (-.0.4039)), (* H61  *)
      (    (2.3107),  (-.0.1627),  (-.0.0373)), (* H62  *)
      (    (3.4426),   (5.5361),  (-.1.5199))) (* H8   *)
      )
    )
;;

let rA02
  = N(
      {    a=0.5566; b=0.0449; c=0.8296; (* dgf_base_tfo *)
           d=0.5125; e=0.7673; f= -.0.3854;
           g= -.0.6538; h=0.6397; i=0.4041;
           tx= -.9.1161; ty= -.3.7679; tz= -.2.9968 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.5778),   (6.6594),  (-.4.0364)), (* C5'  *)
      (    (4.9220),   (7.1963),  (-.4.9204)), (* H5'  *)
      (    (3.7996),   (5.9091),  (-.4.1764)), (* H5'' *)
      (    (5.7873),   (5.8869),  (-.3.5482)), (* C4'  *)
      (    (6.0405),   (5.0875),  (-.4.2446)), (* H4'  *)
      (    (6.9135),   (6.8036),  (-.3.4310)), (* O4'  *)
      (    (7.7293),   (6.4084),  (-.2.3392)), (* C1'  *)
      (    (8.7078),   (6.1815),  (-.2.7624)), (* H1'  *)
      (    (7.1305),   (5.1418),  (-.1.7347)), (* C2'  *)
      (    (7.2040),   (5.1982),  (-.0.6486)), (* H2'' *)
      (    (7.7417),   (4.0392),  (-.2.3813)), (* O2'  *)
      (    (8.6785),   (4.1443),  (-.2.5630)), (* H2'  *)
      (    (5.6666),   (5.2728),  (-.2.1536)), (* C3'  *)
      (    (5.1747),   (5.9805),  (-.1.4863)), (* H3'  *)
      (    (4.9997),   (4.0086),  (-.2.1973)), (* O3'  *)
      (   (10.3245),   (8.5459),   (1.5467)), (* N1   *)
      (    (9.8051),   (6.9432),  (-.0.1497)), (* N3   *)
      (   (10.5175),   (7.4328),   (0.8408)), (* C2   *)
      (    (8.7523),   (7.7422),  (-.0.4228)), (* C4   *)
      (    (8.4257),   (8.9060),   (0.2099)), (* C5   *)
      (    (9.2665),   (9.3242),   (1.2540)), (* C6 *)
      (A (
      (    (9.0664),  (10.4462),   (1.9610)), (* N6   *)
      (    (7.2750),   (9.4537),  (-.0.3428)), (* N7   *)
      (    (7.7962),   (7.5519),  (-.1.3859)), (* N9   *)
      (    (6.9479),   (8.6157),  (-.1.2771)), (* C8   *)
      (   (11.4063),   (6.9047),   (1.1859)), (* H2   *)
      (    (8.2845),  (11.0341),   (1.7552)), (* H61  *)
      (    (9.6584),  (10.6647),   (2.7198)), (* H62  *)
      (    (6.0430),   (8.9853),  (-.1.7594))) (* H8   *)
      )
    )
;;
let rA03
  = N(
      {    a= -.0.5021; b=0.0731; c=0.8617; (* dgf_base_tfo *)
           d= -.0.8112; e=0.3054; f= -.0.4986;
           g= -.0.2996; h= -.0.9494; i= -.0.0940;
           tx=6.4273; ty= -.5.1944; tz= -.3.7807 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.1214),   (6.7116),  (-.1.9049)), (* C5'  *)
      (    (3.3465),   (5.9610),  (-.2.0607)), (* H5'  *)
      (    (4.0789),   (7.2928),  (-.0.9837)), (* H5'' *)
      (    (5.4170),   (5.9293),  (-.1.8186)), (* C4'  *)
      (    (5.4506),   (5.3400),  (-.0.9023)), (* H4'  *)
      (    (5.5067),   (5.0417),  (-.2.9703)), (* O4'  *)
      (    (6.8650),   (4.9152),  (-.3.3612)), (* C1'  *)
      (    (7.1090),   (3.8577),  (-.3.2603)), (* H1'  *)
      (    (7.7152),   (5.7282),  (-.2.3894)), (* C2'  *)
      (    (8.5029),   (6.2356),  (-.2.9463)), (* H2'' *)
      (    (8.1036),   (4.8568),  (-.1.3419)), (* O2'  *)
      (    (8.3270),   (3.9651),  (-.1.6184)), (* H2'  *)
      (    (6.7003),   (6.7565),  (-.1.8911)), (* C3'  *)
      (    (6.5898),   (7.5329),  (-.2.6482)), (* H3'  *)
      (    (7.0505),   (7.2878),  (-.0.6105)), (* O3'  *)
      (    (9.6740),   (4.7656),  (-.7.6614)), (* N1   *)
      (    (9.0739),   (4.3013),  (-.5.3941)), (* N3   *)
      (    (9.8416),   (4.2192),  (-.6.4581)), (* C2   *)
      (    (7.9885),   (5.0632),  (-.5.6446)), (* C4   *)
      (    (7.6822),   (5.6856),  (-.6.8194)), (* C5   *)
      (    (8.5831),   (5.5215),  (-.7.8840)), (* C6 *)
      (A (
      (    (8.4084),   (6.0747),  (-.9.0933)), (* N6   *)
      (    (6.4857),   (6.3816),  (-.6.7035)), (* N7   *)
      (    (6.9740),   (5.3703),  (-.4.7760)), (* N9   *)
      (    (6.1133),   (6.1613),  (-.5.4808)), (* C8   *)
      (   (10.7627),   (3.6375),  (-.6.4220)), (* H2   *)
      (    (7.6031),   (6.6390),  (-.9.2733)), (* H61  *)
      (    (9.1004),   (5.9708),  (-.9.7893)), (* H62  *)
      (    (5.1705),   (6.6830),  (-.5.3167))) (* H8   *)
      )
    )
;;

let rA04
  = N(
      {    a= -.0.5426; b= -.0.8175; c=0.1929; (* dgf_base_tfo *)
           d=0.8304; e= -.0.5567; f= -.0.0237;
           g=0.1267; h=0.1473; i=0.9809;
           tx= -.0.5075; ty=8.3929; tz=0.2229 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4352),   (8.2183),  (-.2.7757)), (* C5'  *)
      (    (5.3830),   (8.7883),  (-.1.8481)), (* H5'  *)
      (    (5.7729),   (8.7436),  (-.3.6691)), (* H5'' *)
      (    (6.4830),   (7.1518),  (-.2.5252)), (* C4'  *)
      (    (7.4749),   (7.5972),  (-.2.4482)), (* H4'  *)
      (    (6.1626),   (6.4620),  (-.1.2827)), (* O4'  *)
      (    (6.5431),   (5.0992),  (-.1.3905)), (* C1'  *)
      (    (7.2871),   (4.9328),  (-.0.6114)), (* H1'  *)
      (    (7.1852),   (4.8935),  (-.2.7592)), (* C2'  *)
      (    (6.8573),   (3.9363),  (-.3.1645)), (* H2'' *)
      (    (8.5780),   (5.1025),  (-.2.6046)), (* O2'  *)
      (    (8.9516),   (4.7577),  (-.1.7902)), (* H2'  *)
      (    (6.5522),   (6.0300),  (-.3.5612)), (* C3'  *)
      (    (5.5420),   (5.7356),  (-.3.8459)), (* H3'  *)
      (    (7.3487),   (6.4089),  (-.4.6867)), (* O3'  *)
      (    (3.6343),   (2.6680),   (2.0783)), (* N1   *)
      (    (5.4505),   (3.9805),   (1.2446)), (* N3   *)
      (    (4.7540),   (3.3816),   (2.1851)), (* C2   *)
      (    (4.8805),   (3.7951),   (0.0354)), (* C4   *)
      (    (3.7416),   (3.0925),  (-.0.2305)), (* C5   *)
      (    (3.0873),   (2.4980),   (0.8606)), (* C6 *)
      (A (
      (    (1.9600),   (1.7805),   (0.7462)), (* N6   *)
      (    (3.4605),   (3.1184),  (-.1.5906)), (* N7   *)
      (    (5.3247),   (4.2695),  (-.1.1710)), (* N9   *)
      (    (4.4244),   (3.8244),  (-.2.0953)), (* C8   *)
      (    (5.0814),   (3.4352),   (3.2234)), (* H2   *)
      (    (1.5423),   (1.6454),  (-.0.1520)), (* H61  *)
      (    (1.5716),   (1.3398),   (1.5392)), (* H62  *)
      (    (4.2675),   (3.8876),  (-.3.1721))) (* H8   *)
      )
    )
;;

let rA05
  = N(
      {    a= -.0.5891; b=0.0449; c=0.8068; (* dgf_base_tfo *)
           d=0.5375; e=0.7673; f=0.3498;
           g= -.0.6034; h=0.6397; i= -.0.4762;
           tx= -.0.3019; ty= -.3.7679; tz= -.9.5913 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.5778),   (6.6594),  (-.4.0364)), (* C5'  *)
      (    (4.9220),   (7.1963),  (-.4.9204)), (* H5'  *)
      (    (3.7996),   (5.9091),  (-.4.1764)), (* H5'' *)
      (    (5.7873),   (5.8869),  (-.3.5482)), (* C4'  *)
      (    (6.0405),   (5.0875),  (-.4.2446)), (* H4'  *)
      (    (6.9135),   (6.8036),  (-.3.4310)), (* O4'  *)
      (    (7.7293),   (6.4084),  (-.2.3392)), (* C1'  *)
      (    (8.7078),   (6.1815),  (-.2.7624)), (* H1'  *)
      (    (7.1305),   (5.1418),  (-.1.7347)), (* C2'  *)
      (    (7.2040),   (5.1982),  (-.0.6486)), (* H2'' *)
      (    (7.7417),   (4.0392),  (-.2.3813)), (* O2'  *)
      (    (8.6785),   (4.1443),  (-.2.5630)), (* H2'  *)
      (    (5.6666),   (5.2728),  (-.2.1536)), (* C3'  *)
      (    (5.1747),   (5.9805),  (-.1.4863)), (* H3'  *)
      (    (4.9997),   (4.0086),  (-.2.1973)), (* O3'  *)
      (   (10.2594),  (10.6774),  (-.1.0056)), (* N1   *)
      (    (9.7528),   (8.7080),  (-.2.2631)), (* N3   *)
      (   (10.4471),   (9.7876),  (-.1.9791)), (* C2   *)
      (    (8.7271),   (8.5575),  (-.1.3991)), (* C4   *)
      (    (8.4100),   (9.3803),  (-.0.3580)), (* C5   *)
      (    (9.2294),  (10.5030),  (-.0.1574)), (* C6 *)
      (A (
      (    (9.0349),  (11.3951),   (0.8250)), (* N6   *)
      (    (7.2891),   (8.9068),   (0.3121)), (* N7   *)
      (    (7.7962),   (7.5519),  (-.1.3859)), (* N9   *)
      (    (6.9702),   (7.8292),  (-.0.3353)), (* C8   *)
      (   (11.3132),  (10.0537),  (-.2.5851)), (* H2   *)
      (    (8.2741),  (11.2784),   (1.4629)), (* H61  *)
      (    (9.6733),  (12.1368),   (0.9529)), (* H62  *)
      (    (6.0888),   (7.3990),   (0.1403))) (* H8   *)
      )
    )
;;

let rA06
  = N(
      {    a= -.0.9815; b=0.0731; c= -.0.1772; (* dgf_base_tfo *)
           d=0.1912; e=0.3054; f= -.0.9328;
           g= -.0.0141; h= -.0.9494; i= -.0.3137;
           tx=5.7506; ty= -.5.1944; tz=4.7470 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.1214),   (6.7116),  (-.1.9049)), (* C5'  *)
      (    (3.3465),   (5.9610),  (-.2.0607)), (* H5'  *)
      (    (4.0789),   (7.2928),  (-.0.9837)), (* H5'' *)
      (    (5.4170),   (5.9293),  (-.1.8186)), (* C4'  *)
      (    (5.4506),   (5.3400),  (-.0.9023)), (* H4'  *)
      (    (5.5067),   (5.0417),  (-.2.9703)), (* O4'  *)
      (    (6.8650),   (4.9152),  (-.3.3612)), (* C1'  *)
      (    (7.1090),   (3.8577),  (-.3.2603)), (* H1'  *)
      (    (7.7152),   (5.7282),  (-.2.3894)), (* C2'  *)
      (    (8.5029),   (6.2356),  (-.2.9463)), (* H2'' *)
      (    (8.1036),   (4.8568),  (-.1.3419)), (* O2'  *)
      (    (8.3270),   (3.9651),  (-.1.6184)), (* H2'  *)
      (    (6.7003),   (6.7565),  (-.1.8911)), (* C3'  *)
      (    (6.5898),   (7.5329),  (-.2.6482)), (* H3'  *)
      (    (7.0505),   (7.2878),  (-.0.6105)), (* O3'  *)
      (    (6.6624),   (3.5061),  (-.8.2986)), (* N1   *)
      (    (6.5810),   (3.2570),  (-.5.9221)), (* N3   *)
      (    (6.5151),   (2.8263),  (-.7.1625)), (* C2   *)
      (    (6.8364),   (4.5817),  (-.5.8882)), (* C4   *)
      (    (7.0116),   (5.4064),  (-.6.9609)), (* C5   *)
      (    (6.9173),   (4.8260),  (-.8.2361)), (* C6 *)
      (A (
      (    (7.0668),   (5.5163),  (-.9.3763)), (* N6   *)
      (    (7.2573),   (6.7070),  (-.6.5394)), (* N7   *)
      (    (6.9740),   (5.3703),  (-.4.7760)), (* N9   *)
      (    (7.2238),   (6.6275),  (-.5.2453)), (* C8   *)
      (    (6.3146),   (1.7741),  (-.7.3641)), (* H2   *)
      (    (7.2568),   (6.4972),  (-.9.3456)), (* H61  *)
      (    (7.0437),   (5.0478), (-.10.2446)), (* H62  *)
      (    (7.4108),   (7.6227),  (-.4.8418))) (* H8   *)
      )
    )
;;

let rA07
  = N(
      {    a=0.2379; b=0.1310; c= -.0.9624; (* dgf_base_tfo *)
           d= -.0.5876; e= -.0.7696; f= -.0.2499;
           g= -.0.7734; h=0.6249; i= -.0.1061;
           tx=30.9870; ty= -.26.9344; tz=42.6416 },
      {    a=0.7529; b=0.1548; c=0.6397; (* P_O3'_275_tfo *)
           d=0.2952; e= -.0.9481; f= -.0.1180;
           g=0.5882; h=0.2777; i= -.0.7595;
           tx= -.58.8919; ty= -.11.3095; tz=6.0866 },
      {    a= -.0.0239; b=0.9667; c= -.0.2546; (* P_O3'_180_tfo *)
           d=0.9731; e= -.0.0359; f= -.0.2275;
           g= -.0.2290; h= -.0.2532; i= -.0.9399;
           tx=3.5401; ty= -.29.7913; tz=52.2796 },
      {    a= -.0.8912; b= -.0.4531; c=0.0242; (* P_O3'_60_tfo *)
           d= -.0.1183; e=0.1805; f= -.0.9764;
           g=0.4380; h= -.0.8730; i= -.0.2145;
           tx=19.9023; ty=54.8054; tz=15.2799 },
      (   (41.8210),   (8.3880),  (43.5890)), (* P    *)
      (   (42.5400),   (8.0450),  (44.8330)), (* O1P  *)
      (   (42.2470),   (9.6920),  (42.9910)), (* O2P  *)
      (   (40.2550),   (8.2030),  (43.7340)), (* O5'  *)
      (   (39.3505),   (8.4697),  (42.6565)), (* C5'  *)
      (   (39.1377),   (7.5433),  (42.1230)), (* H5'  *)
      (   (39.7203),   (9.3119),  (42.0717)), (* H5'' *)
      (   (38.0405),   (8.9195),  (43.2869)), (* C4'  *)
      (   (37.3687),   (9.3036),  (42.5193)), (* H4'  *)
      (   (37.4319),   (7.8146),  (43.9387)), (* O4'  *)
      (   (37.1959),   (8.1354),  (45.3237)), (* C1'  *)
      (   (36.1788),   (8.5202),  (45.3970)), (* H1'  *)
      (   (38.1721),   (9.2328),  (45.6504)), (* C2'  *)
      (   (39.1555),   (8.7939),  (45.8188)), (* H2'' *)
      (   (37.7862),  (10.0617),  (46.7013)), (* O2'  *)
      (   (37.3087),   (9.6229),  (47.4092)), (* H2'  *)
      (   (38.1844),  (10.0268),  (44.3367)), (* C3'  *)
      (   (39.1578),  (10.5054),  (44.2289)), (* H3'  *)
      (   (37.0547),  (10.9127),  (44.3441)), (* O3'  *)
      (   (34.8811),   (4.2072),  (47.5784)), (* N1   *)
      (   (35.1084),   (6.1336),  (46.1818)), (* N3   *)
      (   (34.4108),   (5.1360),  (46.7207)), (* C2   *)
      (   (36.3908),   (6.1224),  (46.6053)), (* C4   *)
      (   (36.9819),   (5.2334),  (47.4697)), (* C5   *)
      (   (36.1786),   (4.1985),  (48.0035)), (* C6 *)
      (A (
      (   (36.6103),   (3.2749),  (48.8452)), (* N6   *)
      (   (38.3236),   (5.5522),  (47.6595)), (* N7   *)
      (   (37.3887),   (7.0024),  (46.2437)), (* N9   *)
      (   (38.5055),   (6.6096),  (46.9057)), (* C8   *)
      (   (33.3553),   (5.0152),  (46.4771)), (* H2   *)
      (   (37.5730),   (3.2804),  (49.1507)), (* H61  *)
      (   (35.9775),   (2.5638),  (49.1828)), (* H62  *)
      (   (39.5461),   (6.9184),  (47.0041))) (* H8   *)
      )
    )
;;

let rA08
  = N(
      {    a=0.1084; b= -.0.0895; c= -.0.9901; (* dgf_base_tfo *)
           d=0.9789; e= -.0.1638; f=0.1220;
           g= -.0.1731; h= -.0.9824; i=0.0698;
           tx= -.2.9039; ty=47.2655; tz=33.0094 },
      {    a=0.7529; b=0.1548; c=0.6397; (* P_O3'_275_tfo *)
           d=0.2952; e= -.0.9481; f= -.0.1180;
           g=0.5882; h=0.2777; i= -.0.7595;
           tx= -.58.8919; ty= -.11.3095; tz=6.0866 },
      {    a= -.0.0239; b=0.9667; c= -.0.2546; (* P_O3'_180_tfo *)
           d=0.9731; e= -.0.0359; f= -.0.2275;
           g= -.0.2290; h= -.0.2532; i= -.0.9399;
           tx=3.5401; ty= -.29.7913; tz=52.2796 },
      {    a= -.0.8912; b= -.0.4531; c=0.0242; (* P_O3'_60_tfo *)
           d= -.0.1183; e=0.1805; f= -.0.9764;
           g=0.4380; h= -.0.8730; i= -.0.2145;
           tx=19.9023; ty=54.8054; tz=15.2799 },
      (   (41.8210),   (8.3880),  (43.5890)), (* P    *)
      (   (42.5400),   (8.0450),  (44.8330)), (* O1P  *)
      (   (42.2470),   (9.6920),  (42.9910)), (* O2P  *)
      (   (40.2550),   (8.2030),  (43.7340)), (* O5'  *)
      (   (39.4850),   (8.9301),  (44.6977)), (* C5'  *)
      (   (39.0638),   (9.8199),  (44.2296)), (* H5'  *)
      (   (40.0757),   (9.0713),  (45.6029)), (* H5'' *)
      (   (38.3102),   (8.0414),  (45.0789)), (* C4'  *)
      (   (37.7842),   (8.4637),  (45.9351)), (* H4'  *)
      (   (37.4200),   (7.9453),  (43.9769)), (* O4'  *)
      (   (37.2249),   (6.5609),  (43.6273)), (* C1'  *)
      (   (36.3360),   (6.2168),  (44.1561)), (* H1'  *)
      (   (38.4347),   (5.8414),  (44.1590)), (* C2'  *)
      (   (39.2688),   (5.9974),  (43.4749)), (* H2'' *)
      (   (38.2344),   (4.4907),  (44.4348)), (* O2'  *)
      (   (37.6374),   (4.0386),  (43.8341)), (* H2'  *)
      (   (38.6926),   (6.6079),  (45.4637)), (* C3'  *)
      (   (39.7585),   (6.5640),  (45.6877)), (* H3'  *)
      (   (37.8238),   (6.0705),  (46.4723)), (* O3'  *)
      (   (33.9162),   (6.2598),  (39.7758)), (* N1   *)
      (   (34.6709),   (6.5759),  (42.0215)), (* N3   *)
      (   (33.7257),   (6.5186),  (41.0858)), (* C2   *)
      (   (35.8935),   (6.3324),  (41.5018)), (* C4   *)
      (   (36.2105),   (6.0601),  (40.1932)), (* C5   *)
      (   (35.1538),   (6.0151),  (39.2537)), (* C6 *)
      (A (
      (   (35.3088),   (5.7642),  (37.9649)), (* N6   *)
      (   (37.5818),   (5.8677),  (40.0507)), (* N7   *)
      (   (37.0932),   (6.3197),  (42.1810)), (* N9   *)
      (   (38.0509),   (6.0354),  (41.2635)), (* C8   *)
      (   (32.6830),   (6.6898),  (41.3532)), (* H2   *)
      (   (36.2305),   (5.5855),  (37.5925)), (* H61  *)
      (   (34.5056),   (5.7512),  (37.3528)), (* H62  *)
      (   (39.1318),   (5.8993),  (41.2285))) (* H8   *)
      )
    )
;;

let rA09
  = N(
      {    a=0.8467; b=0.4166; c= -.0.3311; (* dgf_base_tfo *)
           d= -.0.3962; e=0.9089; f=0.1303;
           g=0.3552; h=0.0209; i=0.9346;
           tx= -.42.7319; ty= -.26.6223; tz= -.29.8163 },
      {    a=0.7529; b=0.1548; c=0.6397; (* P_O3'_275_tfo *)
           d=0.2952; e= -.0.9481; f= -.0.1180;
           g=0.5882; h=0.2777; i= -.0.7595;
           tx= -.58.8919; ty= -.11.3095; tz=6.0866 },
      {    a= -.0.0239; b=0.9667; c= -.0.2546; (* P_O3'_180_tfo *)
           d=0.9731; e= -.0.0359; f= -.0.2275;
           g= -.0.2290; h= -.0.2532; i= -.0.9399;
           tx=3.5401; ty= -.29.7913; tz=52.2796 },
      {    a= -.0.8912; b= -.0.4531; c=0.0242; (* P_O3'_60_tfo *)
           d= -.0.1183; e=0.1805; f= -.0.9764;
           g=0.4380; h= -.0.8730; i= -.0.2145;
           tx=19.9023; ty=54.8054; tz=15.2799 },
      (   (41.8210),   (8.3880),  (43.5890)), (* P    *)
      (   (42.5400),   (8.0450),  (44.8330)), (* O1P  *)
      (   (42.2470),   (9.6920),  (42.9910)), (* O2P  *)
      (   (40.2550),   (8.2030),  (43.7340)), (* O5'  *)
      (   (39.3505),   (8.4697),  (42.6565)), (* C5'  *)
      (   (39.1377),   (7.5433),  (42.1230)), (* H5'  *)
      (   (39.7203),   (9.3119),  (42.0717)), (* H5'' *)
      (   (38.0405),   (8.9195),  (43.2869)), (* C4'  *)
      (   (37.6479),   (8.1347),  (43.9335)), (* H4'  *)
      (   (38.2691),  (10.0933),  (44.0524)), (* O4'  *)
      (   (37.3999),  (11.1488),  (43.5973)), (* C1'  *)
      (   (36.5061),  (11.1221),  (44.2206)), (* H1'  *)
      (   (37.0364),  (10.7838),  (42.1836)), (* C2'  *)
      (   (37.8636),  (11.0489),  (41.5252)), (* H2'' *)
      (   (35.8275),  (11.3133),  (41.7379)), (* O2'  *)
      (   (35.6214),  (12.1896),  (42.0714)), (* H2'  *)
      (   (36.9316),   (9.2556),  (42.2837)), (* C3'  *)
      (   (37.1778),   (8.8260),  (41.3127)), (* H3'  *)
      (   (35.6285),   (8.9334),  (42.7926)), (* O3'  *)
      (   (38.1482),  (15.2833),  (46.4641)), (* N1   *)
      (   (37.3641),  (13.0968),  (45.9007)), (* N3   *)
      (   (37.5032),  (14.1288),  (46.7300)), (* C2   *)
      (   (37.9570),  (13.3377),  (44.7113)), (* C4   *)
      (   (38.6397),  (14.4660),  (44.3267)), (* C5   *)
      (   (38.7473),  (15.5229),  (45.2609)), (* C6 *)
      (A (
      (   (39.3720),  (16.6649),  (45.0297)), (* N6   *)
      (   (39.1079),  (14.3351),  (43.0223)), (* N7   *)
      (   (38.0132),  (12.4868),  (43.6280)), (* N9   *)
      (   (38.7058),  (13.1402),  (42.6620)), (* C8   *)
      (   (37.0731),  (14.0857),  (47.7306)), (* H2   *)
      (   (39.8113),  (16.8281),  (44.1350)), (* H61  *)
      (   (39.4100),  (17.3741),  (45.7478)), (* H62  *)
      (   (39.0412),  (12.9660),  (41.6397))) (* H8   *)
      )
    )
;;

let rA10
  = N(
      {    a=0.7063; b=0.6317; c= -.0.3196; (* dgf_base_tfo *)
           d= -.0.0403; e= -.0.4149; f= -.0.9090;
           g= -.0.7068; h=0.6549; i= -.0.2676;
           tx=6.4402; ty= -.52.1496; tz=30.8246 },
      {    a=0.7529; b=0.1548; c=0.6397; (* P_O3'_275_tfo *)
           d=0.2952; e= -.0.9481; f= -.0.1180;
           g=0.5882; h=0.2777; i= -.0.7595;
           tx= -.58.8919; ty= -.11.3095; tz=6.0866 },
      {    a= -.0.0239; b=0.9667; c= -.0.2546; (* P_O3'_180_tfo *)
           d=0.9731; e= -.0.0359; f= -.0.2275;
           g= -.0.2290; h= -.0.2532; i= -.0.9399;
           tx=3.5401; ty= -.29.7913; tz=52.2796 },
      {    a= -.0.8912; b= -.0.4531; c=0.0242; (* P_O3'_60_tfo *)
           d= -.0.1183; e=0.1805; f= -.0.9764;
           g=0.4380; h= -.0.8730; i= -.0.2145;
           tx=19.9023; ty=54.8054; tz=15.2799 },
      (   (41.8210),   (8.3880),  (43.5890)), (* P    *)
      (   (42.5400),   (8.0450),  (44.8330)), (* O1P  *)
      (   (42.2470),   (9.6920),  (42.9910)), (* O2P  *)
      (   (40.2550),   (8.2030),  (43.7340)), (* O5'  *)
      (   (39.4850),   (8.9301),  (44.6977)), (* C5'  *)
      (   (39.0638),   (9.8199),  (44.2296)), (* H5'  *)
      (   (40.0757),   (9.0713),  (45.6029)), (* H5'' *)
      (   (38.3102),   (8.0414),  (45.0789)), (* C4'  *)
      (   (37.7099),   (7.8166),  (44.1973)), (* H4'  *)
      (   (38.8012),   (6.8321),  (45.6380)), (* O4'  *)
      (   (38.2431),   (6.6413),  (46.9529)), (* C1'  *)
      (   (37.3505),   (6.0262),  (46.8385)), (* H1'  *)
      (   (37.8484),   (8.0156),  (47.4214)), (* C2'  *)
      (   (38.7381),   (8.5406),  (47.7690)), (* H2'' *)
      (   (36.8286),   (8.0368),  (48.3701)), (* O2'  *)
      (   (36.8392),   (7.3063),  (48.9929)), (* H2'  *)
      (   (37.3576),   (8.6512),  (46.1132)), (* C3'  *)
      (   (37.5207),   (9.7275),  (46.1671)), (* H3'  *)
      (   (35.9985),   (8.2392),  (45.9032)), (* O3'  *)
      (   (39.9117),   (2.2278),  (48.8527)), (* N1   *)
      (   (38.6207),   (3.6941),  (47.4757)), (* N3   *)
      (   (38.9872),   (2.4888),  (47.9057)), (* C2   *)
      (   (39.2961),   (4.6720),  (48.1174)), (* C4   *)
      (   (40.2546),   (4.5307),  (49.0912)), (* C5   *)
      (   (40.5932),   (3.2189),  (49.4985)), (* C6 *)
      (A (
      (   (41.4938),   (2.9317),  (50.4229)), (* N6   *)
      (   (40.7195),   (5.7755),  (49.5060)), (* N7   *)
      (   (39.1730),   (6.0305),  (47.9170)), (* N9   *)
      (   (40.0413),   (6.6250),  (48.7728)), (* C8   *)
      (   (38.5257),   (1.5960),  (47.4838)), (* H2   *)
      (   (41.9907),   (3.6753),  (50.8921)), (* H61  *)
      (   (41.6848),   (1.9687),  (50.6599)), (* H62  *)
      (   (40.3571),   (7.6321),  (49.0452))) (* H8   *)
      )
    )
;;

let rAs = [rA01;rA02;rA03;rA04;rA05;rA06;rA07;rA08;rA09;rA10];;

let rC
  = N(
      {    a= -.0.0359; b= -.0.8071; c=0.5894; (* dgf_base_tfo *)
           d= -.0.2669; e=0.5761; f=0.7726;
           g= -.0.9631; h= -.0.1296; i= -.0.2361;
           tx=0.1584; ty=8.3434; tz=0.5434 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2430),  (-.8.2420),   (2.8260)), (* C5'  *)
      (    (5.1974),  (-.8.8497),   (1.9223)), (* H5'  *)
      (    (5.5548),  (-.8.7348),   (3.7469)), (* H5'' *)
      (    (6.3140),  (-.7.2060),   (2.5510)), (* C4'  *)
      (    (7.2954),  (-.7.6762),   (2.4898)), (* H4'  *)
      (    (6.0140),  (-.6.5420),   (1.2890)), (* O4'  *)
      (    (6.4190),  (-.5.1840),   (1.3620)), (* C1'  *)
      (    (7.1608),  (-.5.0495),   (0.5747)), (* H1'  *)
      (    (7.0760),  (-.4.9560),   (2.7270)), (* C2'  *)
      (    (6.7770),  (-.3.9803),   (3.1099)), (* H2'' *)
      (    (8.4500),  (-.5.1930),   (2.5810)), (* O2'  *)
      (    (8.8309),  (-.4.8755),   (1.7590)), (* H2'  *)
      (    (6.4060),  (-.6.0590),   (3.5580)), (* C3'  *)
      (    (5.4021),  (-.5.7313),   (3.8281)), (* H3'  *)
      (    (7.1570),  (-.6.4240),   (4.7070)), (* O3'  *)
      (    (5.2170),  (-.4.3260),   (1.1690)), (* N1   *)
      (    (4.2960),  (-.2.2560),   (0.6290)), (* N3   *)
      (    (5.4330),  (-.3.0200),   (0.7990)), (* C2   *)
      (    (2.9930),  (-.2.6780),   (0.7940)), (* C4   *)
      (    (2.8670),  (-.4.0630),   (1.1830)), (* C5   *)
      (    (3.9570),  (-.4.8300),   (1.3550)), (* C6 *)
      (C (
      (    (2.0187),  (-.1.8047),   (0.5874)), (* N4   *)
      (    (6.5470),  (-.2.5560),   (0.6290)), (* O2   *)
      (    (1.0684),  (-.2.1236),   (0.7109)), (* H41  *)
      (    (2.2344),  (-.0.8560),   (0.3162)), (* H42  *)
      (    (1.8797),  (-.4.4972),   (1.3404)), (* H5   *)
      (    (3.8479),  (-.5.8742),   (1.6480))) (* H6   *)
      )
    )
;;

let rC01
  = N(
      {    a= -.0.0137; b= -.0.8012; c=0.5983; (* dgf_base_tfo *)
           d= -.0.2523; e=0.5817; f=0.7733;
           g= -.0.9675; h= -.0.1404; i= -.0.2101;
           tx=0.2031; ty=8.3874; tz=0.4228 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2416),  (-.8.2422),   (2.8181)), (* C5'  *)
      (    (5.2050),  (-.8.8128),   (1.8901)), (* H5'  *)
      (    (5.5368),  (-.8.7738),   (3.7227)), (* H5'' *)
      (    (6.3232),  (-.7.2037),   (2.6002)), (* C4'  *)
      (    (7.3048),  (-.7.6757),   (2.5577)), (* H4'  *)
      (    (6.0635),  (-.6.5092),   (1.3456)), (* O4'  *)
      (    (6.4697),  (-.5.1547),   (1.4629)), (* C1'  *)
      (    (7.2354),  (-.5.0043),   (0.7018)), (* H1'  *)
      (    (7.0856),  (-.4.9610),   (2.8521)), (* C2'  *)
      (    (6.7777),  (-.3.9935),   (3.2487)), (* H2'' *)
      (    (8.4627),  (-.5.1992),   (2.7423)), (* O2'  *)
      (    (8.8693),  (-.4.8638),   (1.9399)), (* H2'  *)
      (    (6.3877),  (-.6.0809),   (3.6362)), (* C3'  *)
      (    (5.3770),  (-.5.7562),   (3.8834)), (* H3'  *)
      (    (7.1024),  (-.6.4754),   (4.7985)), (* O3'  *)
      (    (5.2764),  (-.4.2883),   (1.2538)), (* N1   *)
      (    (4.3777),  (-.2.2062),   (0.7229)), (* N3   *)
      (    (5.5069),  (-.2.9779),   (0.9088)), (* C2   *)
      (    (3.0693),  (-.2.6246),   (0.8500)), (* C4   *)
      (    (2.9279),  (-.4.0146),   (1.2149)), (* C5   *)
      (    (4.0101),  (-.4.7892),   (1.4017)), (* C6 *)
      (C (
      (    (2.1040),  (-.1.7437),   (0.6331)), (* N4   *)
      (    (6.6267),  (-.2.5166),   (0.7728)), (* O2   *)
      (    (1.1496),  (-.2.0600),   (0.7287)), (* H41  *)
      (    (2.3303),  (-.0.7921),   (0.3815)), (* H42  *)
      (    (1.9353),  (-.4.4465),   (1.3419)), (* H5   *)
      (    (3.8895),  (-.5.8371),   (1.6762))) (* H6   *)
      )
    )
;;

let rC02
  = N(
      {    a=0.5141; b=0.0246; c=0.8574; (* dgf_base_tfo *)
           d= -.0.5547; e= -.0.7529; f=0.3542;
           g=0.6542; h= -.0.6577; i= -.0.3734;
           tx= -.9.1111; ty= -.3.4598; tz= -.3.2939 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (4.3825),  (-.6.6585),   (4.0489)), (* C5'  *)
      (    (4.6841),  (-.7.2019),   (4.9443)), (* H5'  *)
      (    (3.6189),  (-.5.8889),   (4.1625)), (* H5'' *)
      (    (5.6255),  (-.5.9175),   (3.5998)), (* C4'  *)
      (    (5.8732),  (-.5.1228),   (4.3034)), (* H4'  *)
      (    (6.7337),  (-.6.8605),   (3.5222)), (* O4'  *)
      (    (7.5932),  (-.6.4923),   (2.4548)), (* C1'  *)
      (    (8.5661),  (-.6.2983),   (2.9064)), (* H1'  *)
      (    (7.0527),  (-.5.2012),   (1.8322)), (* C2'  *)
      (    (7.1627),  (-.5.2525),   (0.7490)), (* H2'' *)
      (    (7.6666),  (-.4.1249),   (2.4880)), (* O2'  *)
      (    (8.5944),  (-.4.2543),   (2.6981)), (* H2'  *)
      (    (5.5661),  (-.5.3029),   (2.2009)), (* C3'  *)
      (    (5.0841),  (-.6.0018),   (1.5172)), (* H3'  *)
      (    (4.9062),  (-.4.0452),   (2.2042)), (* O3'  *)
      (    (7.6298),  (-.7.6136),   (1.4752)), (* N1   *)
      (    (8.6945),  (-.8.7046),  (-.0.2857)), (* N3   *)
      (    (8.6943),  (-.7.6514),   (0.6066)), (* C2   *)
      (    (7.7426),  (-.9.6987),  (-.0.3801)), (* C4   *)
      (    (6.6642),  (-.9.5742),   (0.5722)), (* C5   *)
      (    (6.6391),  (-.8.5592),   (1.4526)), (* C6 *)
      (C (
      (    (7.9033), (-.10.6371),  (-.1.3010)), (* N4   *)
      (    (9.5840),  (-.6.8186),   (0.6136)), (* O2   *)
      (    (7.2009), (-.11.3604),  (-.1.3619)), (* H41  *)
      (    (8.7058), (-.10.6168),  (-.1.9140)), (* H42  *)
      (    (5.8585), (-.10.3083),   (0.5822)), (* H5   *)
      (    (5.8197),  (-.8.4773),   (2.1667))) (* H6   *)
      )
    )
;;

let rC03
  = N(
      {    a= -.0.4993; b=0.0476; c=0.8651; (* dgf_base_tfo *)
           d=0.8078; e= -.0.3353; f=0.4847;
           g=0.3132; h=0.9409; i=0.1290;
           tx=6.2989; ty= -.5.2303; tz= -.3.8577 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (3.9938),  (-.6.7042),   (1.9023)), (* C5'  *)
      (    (3.2332),  (-.5.9343),   (2.0319)), (* H5'  *)
      (    (3.9666),  (-.7.2863),   (0.9812)), (* H5'' *)
      (    (5.3098),  (-.5.9546),   (1.8564)), (* C4'  *)
      (    (5.3863),  (-.5.3702),   (0.9395)), (* H4'  *)
      (    (5.3851),  (-.5.0642),   (3.0076)), (* O4'  *)
      (    (6.7315),  (-.4.9724),   (3.4462)), (* C1'  *)
      (    (7.0033),  (-.3.9202),   (3.3619)), (* H1'  *)
      (    (7.5997),  (-.5.8018),   (2.4948)), (* C2'  *)
      (    (8.3627),  (-.6.3254),   (3.0707)), (* H2'' *)
      (    (8.0410),  (-.4.9501),   (1.4724)), (* O2'  *)
      (    (8.2781),  (-.4.0644),   (1.7570)), (* H2'  *)
      (    (6.5701),  (-.6.8129),   (1.9714)), (* C3'  *)
      (    (6.4186),  (-.7.5809),   (2.7299)), (* H3'  *)
      (    (6.9357),  (-.7.3841),   (0.7235)), (* O3'  *)
      (    (6.8024),  (-.5.4718),   (4.8475)), (* N1   *)
      (    (7.9218),  (-.5.5700),   (6.8877)), (* N3   *)
      (    (7.8908),  (-.5.0886),   (5.5944)), (* C2   *)
      (    (6.9789),  (-.6.3827),   (7.4823)), (* C4   *)
      (    (5.8742),  (-.6.7319),   (6.6202)), (* C5   *)
      (    (5.8182),  (-.6.2769),   (5.3570)), (* C6 *)
      (C (
      (    (7.1702),  (-.6.7511),   (8.7402)), (* N4   *)
      (    (8.7747),  (-.4.3728),   (5.1568)), (* O2   *)
      (    (6.4741),  (-.7.3461),   (9.1662)), (* H41  *)
      (    (7.9889),  (-.6.4396),   (9.2429)), (* H42  *)
      (    (5.0736),  (-.7.3713),   (6.9922)), (* H5   *)
      (    (4.9784),  (-.6.5473),   (4.7170))) (* H6   *)
      )
    )
;;

let rC04
  = N(
      {    a= -.0.5669; b= -.0.8012; c=0.1918; (* dgf_base_tfo *)
           d= -.0.8129; e=0.5817; f=0.0273;
           g= -.0.1334; h= -.0.1404; i= -.0.9811;
           tx= -.0.3279; ty=8.3874; tz=0.3355 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2416),  (-.8.2422),   (2.8181)), (* C5'  *)
      (    (5.2050),  (-.8.8128),   (1.8901)), (* H5'  *)
      (    (5.5368),  (-.8.7738),   (3.7227)), (* H5'' *)
      (    (6.3232),  (-.7.2037),   (2.6002)), (* C4'  *)
      (    (7.3048),  (-.7.6757),   (2.5577)), (* H4'  *)
      (    (6.0635),  (-.6.5092),   (1.3456)), (* O4'  *)
      (    (6.4697),  (-.5.1547),   (1.4629)), (* C1'  *)
      (    (7.2354),  (-.5.0043),   (0.7018)), (* H1'  *)
      (    (7.0856),  (-.4.9610),   (2.8521)), (* C2'  *)
      (    (6.7777),  (-.3.9935),   (3.2487)), (* H2'' *)
      (    (8.4627),  (-.5.1992),   (2.7423)), (* O2'  *)
      (    (8.8693),  (-.4.8638),   (1.9399)), (* H2'  *)
      (    (6.3877),  (-.6.0809),   (3.6362)), (* C3'  *)
      (    (5.3770),  (-.5.7562),   (3.8834)), (* H3'  *)
      (    (7.1024),  (-.6.4754),   (4.7985)), (* O3'  *)
      (    (5.2764),  (-.4.2883),   (1.2538)), (* N1   *)
      (    (3.8961),  (-.3.0896),  (-.0.1893)), (* N3   *)
      (    (5.0095),  (-.3.8907),  (-.0.0346)), (* C2   *)
      (    (3.0480),  (-.2.6632),   (0.8116)), (* C4   *)
      (    (3.4093),  (-.3.1310),   (2.1292)), (* C5   *)
      (    (4.4878),  (-.3.9124),   (2.3088)), (* C6 *)
      (C (
      (    (2.0216),  (-.1.8941),   (0.4804)), (* N4   *)
      (    (5.7005),  (-.4.2164),  (-.0.9842)), (* O2   *)
      (    (1.4067),  (-.1.5873),   (1.2205)), (* H41  *)
      (    (1.8721),  (-.1.6319),  (-.0.4835)), (* H42  *)
      (    (2.8048),  (-.2.8507),   (2.9918)), (* H5   *)
      (    (4.7491),  (-.4.2593),   (3.3085))) (* H6   *)
      )
    )
;;

let rC05
  = N(
      {    a= -.0.6298; b=0.0246; c=0.7763; (* dgf_base_tfo *)
           d= -.0.5226; e= -.0.7529; f= -.0.4001;
           g=0.5746; h= -.0.6577; i=0.4870;
           tx= -.0.0208; ty= -.3.4598; tz= -.9.6882 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (4.3825),  (-.6.6585),   (4.0489)), (* C5'  *)
      (    (4.6841),  (-.7.2019),   (4.9443)), (* H5'  *)
      (    (3.6189),  (-.5.8889),   (4.1625)), (* H5'' *)
      (    (5.6255),  (-.5.9175),   (3.5998)), (* C4'  *)
      (    (5.8732),  (-.5.1228),   (4.3034)), (* H4'  *)
      (    (6.7337),  (-.6.8605),   (3.5222)), (* O4'  *)
      (    (7.5932),  (-.6.4923),   (2.4548)), (* C1'  *)
      (    (8.5661),  (-.6.2983),   (2.9064)), (* H1'  *)
      (    (7.0527),  (-.5.2012),   (1.8322)), (* C2'  *)
      (    (7.1627),  (-.5.2525),   (0.7490)), (* H2'' *)
      (    (7.6666),  (-.4.1249),   (2.4880)), (* O2'  *)
      (    (8.5944),  (-.4.2543),   (2.6981)), (* H2'  *)
      (    (5.5661),  (-.5.3029),   (2.2009)), (* C3'  *)
      (    (5.0841),  (-.6.0018),   (1.5172)), (* H3'  *)
      (    (4.9062),  (-.4.0452),   (2.2042)), (* O3'  *)
      (    (7.6298),  (-.7.6136),   (1.4752)), (* N1   *)
      (    (8.5977),  (-.9.5977),   (0.7329)), (* N3   *)
      (    (8.5951),  (-.8.5745),   (1.6594)), (* C2   *)
      (    (7.7372),  (-.9.7371),  (-.0.3364)), (* C4   *)
      (    (6.7596),  (-.8.6801),  (-.0.4476)), (* C5   *)
      (    (6.7338),  (-.7.6721),   (0.4408)), (* C6 *)
      (C (
      (    (7.8849), (-.10.7881),  (-.1.1289)), (* N4   *)
      (    (9.3993),  (-.8.5377),   (2.5743)), (* O2   *)
      (    (7.2499), (-.10.8809),  (-.1.9088)), (* H41  *)
      (    (8.6122), (-.11.4649),  (-.0.9468)), (* H42  *)
      (    (6.0317),  (-.8.6941),  (-.1.2588)), (* H5   *)
      (    (5.9901),  (-.6.8809),   (0.3459))) (* H6   *)
      )
    )
;;

let rC06
  = N(
      {    a= -.0.9837; b=0.0476; c= -.0.1733; (* dgf_base_tfo *)
           d= -.0.1792; e= -.0.3353; f=0.9249;
           g= -.0.0141; h=0.9409; i=0.3384;
           tx=5.7793; ty= -.5.2303; tz=4.5997 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (3.9938),  (-.6.7042),   (1.9023)), (* C5'  *)
      (    (3.2332),  (-.5.9343),   (2.0319)), (* H5'  *)
      (    (3.9666),  (-.7.2863),   (0.9812)), (* H5'' *)
      (    (5.3098),  (-.5.9546),   (1.8564)), (* C4'  *)
      (    (5.3863),  (-.5.3702),   (0.9395)), (* H4'  *)
      (    (5.3851),  (-.5.0642),   (3.0076)), (* O4'  *)
      (    (6.7315),  (-.4.9724),   (3.4462)), (* C1'  *)
      (    (7.0033),  (-.3.9202),   (3.3619)), (* H1'  *)
      (    (7.5997),  (-.5.8018),   (2.4948)), (* C2'  *)
      (    (8.3627),  (-.6.3254),   (3.0707)), (* H2'' *)
      (    (8.0410),  (-.4.9501),   (1.4724)), (* O2'  *)
      (    (8.2781),  (-.4.0644),   (1.7570)), (* H2'  *)
      (    (6.5701),  (-.6.8129),   (1.9714)), (* C3'  *)
      (    (6.4186),  (-.7.5809),   (2.7299)), (* H3'  *)
      (    (6.9357),  (-.7.3841),   (0.7235)), (* O3'  *)
      (    (6.8024),  (-.5.4718),   (4.8475)), (* N1   *)
      (    (6.6920),  (-.5.0495),   (7.1354)), (* N3   *)
      (    (6.6201),  (-.4.5500),   (5.8506)), (* C2   *)
      (    (6.9254),  (-.6.3614),   (7.4926)), (* C4   *)
      (    (7.1046),  (-.7.2543),   (6.3718)), (* C5   *)
      (    (7.0391),  (-.6.7951),   (5.1106)), (* C6 *)
      (C (
      (    (6.9614),  (-.6.6648),   (8.7815)), (* N4   *)
      (    (6.4083),  (-.3.3696),   (5.6340)), (* O2   *)
      (    (7.1329),  (-.7.6280),   (9.0324)), (* H41  *)
      (    (6.8204),  (-.5.9469),   (9.4777)), (* H42  *)
      (    (7.2954),  (-.8.3135),   (6.5440)), (* H5   *)
      (    (7.1753),  (-.7.4798),   (4.2735))) (* H6   *)
      )
    )
;;

let rC07
  = N(
      {    a=0.0033; b=0.2720; c= -.0.9623; (* dgf_base_tfo *)
           d=0.3013; e= -.0.9179; f= -.0.2584;
           g= -.0.9535; h= -.0.2891; i= -.0.0850;
           tx=43.0403; ty=13.7233; tz=34.5710 },
      {    a=0.9187; b=0.2887; c=0.2694; (* P_O3'_275_tfo *)
           d=0.0302; e= -.0.7316; f=0.6811;
           g=0.3938; h= -.0.6176; i= -.0.6808;
           tx= -.48.4330; ty=26.3254; tz=13.6383 },
      {    a= -.0.1504; b=0.7744; c= -.0.6145; (* P_O3'_180_tfo *)
           d=0.7581; e=0.4893; f=0.4311;
           g=0.6345; h= -.0.4010; i= -.0.6607;
           tx= -.31.9784; ty= -.13.4285; tz=44.9650 },
      {    a= -.0.6236; b= -.0.7810; c= -.0.0337; (* P_O3'_60_tfo *)
           d= -.0.6890; e=0.5694; f= -.0.4484;
           g=0.3694; h= -.0.2564; i= -.0.8932;
           tx=12.1105; ty=30.8774; tz=46.0946 },
      (   (33.3400),  (11.0980),  (46.1750)), (* P    *)
      (   (34.5130),  (10.2320),  (46.4660)), (* O1P  *)
      (   (33.4130),  (12.3960),  (46.9340)), (* O2P  *)
      (   (31.9810),  (10.3390),  (46.4820)), (* O5'  *)
      (   (30.8152),  (11.1619),  (46.2003)), (* C5'  *)
      (   (30.4519),  (10.9454),  (45.1957)), (* H5'  *)
      (   (31.0379),  (12.2016),  (46.4400)), (* H5'' *)
      (   (29.7081),  (10.7448),  (47.1428)), (* C4'  *)
      (   (28.8710),  (11.4416),  (47.0982)), (* H4'  *)
      (   (29.2550),   (9.4394),  (46.8162)), (* O4'  *)
      (   (29.3907),   (8.5625),  (47.9460)), (* C1'  *)
      (   (28.4416),   (8.5669),  (48.4819)), (* H1'  *)
      (   (30.4468),   (9.2031),  (48.7952)), (* C2'  *)
      (   (31.4222),   (8.9651),  (48.3709)), (* H2'' *)
      (   (30.3701),   (8.9157),  (50.1624)), (* O2'  *)
      (   (30.0652),   (8.0304),  (50.3740)), (* H2'  *)
      (   (30.1622),  (10.6879),  (48.6120)), (* C3'  *)
      (   (31.0952),  (11.2399),  (48.7254)), (* H3'  *)
      (   (29.1076),  (11.1535),  (49.4702)), (* O3'  *)
      (   (29.7883),   (7.2209),  (47.5235)), (* N1   *)
      (   (29.1825),   (5.0438),  (46.8275)), (* N3   *)
      (   (28.8008),   (6.2912),  (47.2263)), (* C2   *)
      (   (30.4888),   (4.6890),  (46.7186)), (* C4   *)
      (   (31.5034),   (5.6405),  (47.0249)), (* C5   *)
      (   (31.1091),   (6.8691),  (47.4156)), (* C6 *)
      (C (
      (   (30.8109),   (3.4584),  (46.3336)), (* N4   *)
      (   (27.6171),   (6.5989),  (47.3189)), (* O2   *)
      (   (31.7923),   (3.2301),  (46.2638)), (* H41  *)
      (   (30.0880),   (2.7857),  (46.1215)), (* H42  *)
      (   (32.5542),   (5.3634),  (46.9395)), (* H5   *)
      (   (31.8523),   (7.6279),  (47.6603))) (* H6   *)
      )
    )
;;

let rC08
  = N(
      {    a=0.0797; b= -.0.6026; c= -.0.7941; (* dgf_base_tfo *)
           d=0.7939; e=0.5201; f= -.0.3150;
           g=0.6028; h= -.0.6054; i=0.5198;
           tx= -.36.8341; ty=41.5293; tz=1.6628 },
      {    a=0.9187; b=0.2887; c=0.2694; (* P_O3'_275_tfo *)
           d=0.0302; e= -.0.7316; f=0.6811;
           g=0.3938; h= -.0.6176; i= -.0.6808;
           tx= -.48.4330; ty=26.3254; tz=13.6383 },
      {    a= -.0.1504; b=0.7744; c= -.0.6145; (* P_O3'_180_tfo *)
           d=0.7581; e=0.4893; f=0.4311;
           g=0.6345; h= -.0.4010; i= -.0.6607;
           tx= -.31.9784; ty= -.13.4285; tz=44.9650 },
      {    a= -.0.6236; b= -.0.7810; c= -.0.0337; (* P_O3'_60_tfo *)
           d= -.0.6890; e=0.5694; f= -.0.4484;
           g=0.3694; h= -.0.2564; i= -.0.8932;
           tx=12.1105; ty=30.8774; tz=46.0946 },
      (   (33.3400),  (11.0980),  (46.1750)), (* P    *)
      (   (34.5130),  (10.2320),  (46.4660)), (* O1P  *)
      (   (33.4130),  (12.3960),  (46.9340)), (* O2P  *)
      (   (31.9810),  (10.3390),  (46.4820)), (* O5'  *)
      (   (31.8779),   (9.9369),  (47.8760)), (* C5'  *)
      (   (31.3239),  (10.6931),  (48.4322)), (* H5'  *)
      (   (32.8647),   (9.6624),  (48.2489)), (* H5'' *)
      (   (31.0429),   (8.6773),  (47.9401)), (* C4'  *)
      (   (31.0779),   (8.2331),  (48.9349)), (* H4'  *)
      (   (29.6956),   (8.9669),  (47.5983)), (* O4'  *)
      (   (29.2784),   (8.1700),  (46.4782)), (* C1'  *)
      (   (28.8006),   (7.2731),  (46.8722)), (* H1'  *)
      (   (30.5544),   (7.7940),  (45.7875)), (* C2'  *)
      (   (30.8837),   (8.6410),  (45.1856)), (* H2'' *)
      (   (30.5100),   (6.6007),  (45.0582)), (* O2'  *)
      (   (29.6694),   (6.4168),  (44.6326)), (* H2'  *)
      (   (31.5146),   (7.5954),  (46.9527)), (* C3'  *)
      (   (32.5255),   (7.8261),  (46.6166)), (* H3'  *)
      (   (31.3876),   (6.2951),  (47.5516)), (* O3'  *)
      (   (28.3976),   (8.9302),  (45.5933)), (* N1   *)
      (   (26.2155),   (9.6135),  (44.9910)), (* N3   *)
      (   (27.0281),   (8.8961),  (45.8192)), (* C2   *)
      (   (26.7044),  (10.3489),  (43.9595)), (* C4   *)
      (   (28.1088),  (10.3837),  (43.7247)), (* C5   *)
      (   (28.8978),   (9.6708),  (44.5535)), (* C6 *)
      (C (
      (   (25.8715),  (11.0249),  (43.1749)), (* N4   *)
      (   (26.5733),   (8.2371),  (46.7484)), (* O2   *)
      (   (26.2707),  (11.5609),  (42.4177)), (* H41  *)
      (   (24.8760),  (10.9939),  (43.3427)), (* H42  *)
      (   (28.5089),  (10.9722),  (42.8990)), (* H5   *)
      (   (29.9782),   (9.6687),  (44.4097))) (* H6   *)
      )
    )
;;

let rC09
  = N(
      {    a=0.8727; b=0.4760; c= -.0.1091; (* dgf_base_tfo *)
           d= -.0.4188; e=0.6148; f= -.0.6682;
           g= -.0.2510; h=0.6289; i=0.7359;
           tx= -.8.1687; ty= -.52.0761; tz= -.25.0726 },
      {    a=0.9187; b=0.2887; c=0.2694; (* P_O3'_275_tfo *)
           d=0.0302; e= -.0.7316; f=0.6811;
           g=0.3938; h= -.0.6176; i= -.0.6808;
           tx= -.48.4330; ty=26.3254; tz=13.6383 },
      {    a= -.0.1504; b=0.7744; c= -.0.6145; (* P_O3'_180_tfo *)
           d=0.7581; e=0.4893; f=0.4311;
           g=0.6345; h= -.0.4010; i= -.0.6607;
           tx= -.31.9784; ty= -.13.4285; tz=44.9650 },
      {    a= -.0.6236; b= -.0.7810; c= -.0.0337; (* P_O3'_60_tfo *)
           d= -.0.6890; e=0.5694; f= -.0.4484;
           g=0.3694; h= -.0.2564; i= -.0.8932;
           tx=12.1105; ty=30.8774; tz=46.0946 },
      (   (33.3400),  (11.0980),  (46.1750)), (* P    *)
      (   (34.5130),  (10.2320),  (46.4660)), (* O1P  *)
      (   (33.4130),  (12.3960),  (46.9340)), (* O2P  *)
      (   (31.9810),  (10.3390),  (46.4820)), (* O5'  *)
      (   (30.8152),  (11.1619),  (46.2003)), (* C5'  *)
      (   (30.4519),  (10.9454),  (45.1957)), (* H5'  *)
      (   (31.0379),  (12.2016),  (46.4400)), (* H5'' *)
      (   (29.7081),  (10.7448),  (47.1428)), (* C4'  *)
      (   (29.4506),   (9.6945),  (47.0059)), (* H4'  *)
      (   (30.1045),  (10.9634),  (48.4885)), (* O4'  *)
      (   (29.1794),  (11.8418),  (49.1490)), (* C1'  *)
      (   (28.4388),  (11.2210),  (49.6533)), (* H1'  *)
      (   (28.5211),  (12.6008),  (48.0367)), (* C2'  *)
      (   (29.1947),  (13.3949),  (47.7147)), (* H2'' *)
      (   (27.2316),  (13.0683),  (48.3134)), (* O2'  *)
      (   (27.0851),  (13.3391),  (49.2227)), (* H2'  *)
      (   (28.4131),  (11.5507),  (46.9391)), (* C3'  *)
      (   (28.4451),  (12.0512),  (45.9713)), (* H3'  *)
      (   (27.2707),  (10.6955),  (47.1097)), (* O3'  *)
      (   (29.8751),  (12.7405),  (50.0682)), (* N1   *)
      (   (30.7172),  (13.1841),  (52.2328)), (* N3   *)
      (   (30.0617),  (12.3404),  (51.3847)), (* C2   *)
      (   (31.1834),  (14.3941),  (51.8297)), (* C4   *)
      (   (30.9913),  (14.8074),  (50.4803)), (* C5   *)
      (   (30.3434),  (13.9610),  (49.6548)), (* C6 *)
      (C (
      (   (31.8090),  (15.1847),  (52.6957)), (* N4   *)
      (   (29.6470),  (11.2494),  (51.7616)), (* O2   *)
      (   (32.1422),  (16.0774),  (52.3606)), (* H41  *)
      (   (31.9392),  (14.8893),  (53.6527)), (* H42  *)
      (   (31.3632),  (15.7771),  (50.1491)), (* H5   *)
      (   (30.1742),  (14.2374),  (48.6141))) (* H6   *)
      )
    )
;;

let rC10
  = N(
      {    a=0.1549; b=0.8710; c= -.0.4663; (* dgf_base_tfo *)
           d=0.6768; e= -.0.4374; f= -.0.5921;
           g= -.0.7197; h= -.0.2239; i= -.0.6572;
           tx=25.2447; ty= -.14.1920; tz=50.3201 },
      {    a=0.9187; b=0.2887; c=0.2694; (* P_O3'_275_tfo *)
           d=0.0302; e= -.0.7316; f=0.6811;
           g=0.3938; h= -.0.6176; i= -.0.6808;
           tx= -.48.4330; ty=26.3254; tz=13.6383 },
      {    a= -.0.1504; b=0.7744; c= -.0.6145; (* P_O3'_180_tfo *)
           d=0.7581; e=0.4893; f=0.4311;
           g=0.6345; h= -.0.4010; i= -.0.6607;
           tx= -.31.9784; ty= -.13.4285; tz=44.9650 },
      {    a= -.0.6236; b= -.0.7810; c= -.0.0337; (* P_O3'_60_tfo *)
           d= -.0.6890; e=0.5694; f= -.0.4484;
           g=0.3694; h= -.0.2564; i= -.0.8932;
           tx=12.1105; ty=30.8774; tz=46.0946 },
      (   (33.3400),  (11.0980),  (46.1750)), (* P    *)
      (   (34.5130),  (10.2320),  (46.4660)), (* O1P  *)
      (   (33.4130),  (12.3960),  (46.9340)), (* O2P  *)
      (   (31.9810),  (10.3390),  (46.4820)), (* O5'  *)
      (   (31.8779),   (9.9369),  (47.8760)), (* C5'  *)
      (   (31.3239),  (10.6931),  (48.4322)), (* H5'  *)
      (   (32.8647),   (9.6624),  (48.2489)), (* H5'' *)
      (   (31.0429),   (8.6773),  (47.9401)), (* C4'  *)
      (   (30.0440),   (8.8473),  (47.5383)), (* H4'  *)
      (   (31.6749),   (7.6351),  (47.2119)), (* O4'  *)
      (   (31.9159),   (6.5022),  (48.0616)), (* C1'  *)
      (   (31.0691),   (5.8243),  (47.9544)), (* H1'  *)
      (   (31.9300),   (7.0685),  (49.4493)), (* C2'  *)
      (   (32.9024),   (7.5288),  (49.6245)), (* H2'' *)
      (   (31.5672),   (6.1750),  (50.4632)), (* O2'  *)
      (   (31.8416),   (5.2663),  (50.3200)), (* H2'  *)
      (   (30.8618),   (8.1514),  (49.3749)), (* C3'  *)
      (   (31.1122),   (8.9396),  (50.0850)), (* H3'  *)
      (   (29.5351),   (7.6245),  (49.5409)), (* O3'  *)
      (   (33.1890),   (5.8629),  (47.7343)), (* N1   *)
      (   (34.4004),   (4.2636),  (46.4828)), (* N3   *)
      (   (33.2062),   (4.8497),  (46.7851)), (* C2   *)
      (   (35.5600),   (4.6374),  (47.0822)), (* C4   *)
      (   (35.5444),   (5.6751),  (48.0577)), (* C5   *)
      (   (34.3565),   (6.2450),  (48.3432)), (* C6 *)
      (C (
      (   (36.6977),   (4.0305),  (46.7598)), (* N4   *)
      (   (32.1661),   (4.5034),  (46.2348)), (* O2   *)
      (   (37.5405),   (4.3347),  (47.2259)), (* H41  *)
      (   (36.7033),   (3.2923),  (46.0706)), (* H42  *)
      (   (36.4713),   (5.9811),  (48.5428)), (* H5   *)
      (   (34.2986),   (7.0426),  (49.0839))) (* H6   *)
      )
    )
;;

let rCs = [rC01;rC02;rC03;rC04;rC05;rC06;rC07;rC08;rC09;rC10]
;;

let rG
  = N(
      {    a= -.0.0018; b= -.0.8207; c=0.5714; (* dgf_base_tfo *)
           d=0.2679; e= -.0.5509; f= -.0.7904;
           g=0.9634; h=0.1517; i=0.2209;
           tx=0.0073; ty=8.4030; tz=0.6232 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4550),   (8.2120),  (-.2.8810)), (* C5'  *)
      (    (5.4546),   (8.8508),  (-.1.9978)), (* H5'  *)
      (    (5.7588),   (8.6625),  (-.3.8259)), (* H5'' *)
      (    (6.4970),   (7.1480),  (-.2.5980)), (* C4'  *)
      (    (7.4896),   (7.5919),  (-.2.5214)), (* H4'  *)
      (    (6.1630),   (6.4860),  (-.1.3440)), (* O4'  *)
      (    (6.5400),   (5.1200),  (-.1.4190)), (* C1'  *)
      (    (7.2763),   (4.9681),  (-.0.6297)), (* H1'  *)
      (    (7.1940),   (4.8830),  (-.2.7770)), (* C2'  *)
      (    (6.8667),   (3.9183),  (-.3.1647)), (* H2'' *)
      (    (8.5860),   (5.0910),  (-.2.6140)), (* O2'  *)
      (    (8.9510),   (4.7626),  (-.1.7890)), (* H2'  *)
      (    (6.5720),   (6.0040),  (-.3.6090)), (* C3'  *)
      (    (5.5636),   (5.7066),  (-.3.8966)), (* H3'  *)
      (    (7.3801),   (6.3562),  (-.4.7350)), (* O3'  *)
      (    (4.7150),   (0.4910),  (-.0.1360)), (* N1   *)
      (    (6.3490),   (2.1730),  (-.0.6020)), (* N3   *)
      (    (5.9530),   (0.9650),  (-.0.2670)), (* C2   *)
      (    (5.2900),   (2.9790),  (-.0.8260)), (* C4   *)
      (    (3.9720),   (2.6390),  (-.0.7330)), (* C5   *)
      (    (3.6770),   (1.3160),  (-.0.3660)), (* C6 *)
      (G (
      (    (6.8426),   (0.0056),  (-.0.0019)), (* N2   *)
      (    (3.1660),   (3.7290),  (-.1.0360)), (* N7   *)
      (    (5.3170),   (4.2990),  (-.1.1930)), (* N9   *)
      (    (4.0100),   (4.6780),  (-.1.2990)), (* C8   *)
      (    (2.4280),   (0.8450),  (-.0.2360)), (* O6   *)
      (    (4.6151),  (-.0.4677),   (0.1305)), (* H1   *)
      (    (6.6463),  (-.0.9463),   (0.2729)), (* H21  *)
      (    (7.8170),   (0.2642),  (-.0.0640)), (* H22  *)
      (    (3.4421),   (5.5744),  (-.1.5482))) (* H8   *)
      )
    )
;;

let rG01
  = N(
      {    a= -.0.0043; b= -.0.8175; c=0.5759; (* dgf_base_tfo *)
           d=0.2617; e= -.0.5567; f= -.0.7884;
           g=0.9651; h=0.1473; i=0.2164;
           tx=0.0359; ty=8.3929; tz=0.5532 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4352),   (8.2183),  (-.2.7757)), (* C5'  *)
      (    (5.3830),   (8.7883),  (-.1.8481)), (* H5'  *)
      (    (5.7729),   (8.7436),  (-.3.6691)), (* H5'' *)
      (    (6.4830),   (7.1518),  (-.2.5252)), (* C4'  *)
      (    (7.4749),   (7.5972),  (-.2.4482)), (* H4'  *)
      (    (6.1626),   (6.4620),  (-.1.2827)), (* O4'  *)
      (    (6.5431),   (5.0992),  (-.1.3905)), (* C1'  *)
      (    (7.2871),   (4.9328),  (-.0.6114)), (* H1'  *)
      (    (7.1852),   (4.8935),  (-.2.7592)), (* C2'  *)
      (    (6.8573),   (3.9363),  (-.3.1645)), (* H2'' *)
      (    (8.5780),   (5.1025),  (-.2.6046)), (* O2'  *)
      (    (8.9516),   (4.7577),  (-.1.7902)), (* H2'  *)
      (    (6.5522),   (6.0300),  (-.3.5612)), (* C3'  *)
      (    (5.5420),   (5.7356),  (-.3.8459)), (* H3'  *)
      (    (7.3487),   (6.4089),  (-.4.6867)), (* O3'  *)
      (    (4.7442),   (0.4514),  (-.0.1390)), (* N1   *)
      (    (6.3687),   (2.1459),  (-.0.5926)), (* N3   *)
      (    (5.9795),   (0.9335),  (-.0.2657)), (* C2   *)
      (    (5.3052),   (2.9471),  (-.0.8125)), (* C4   *)
      (    (3.9891),   (2.5987),  (-.0.7230)), (* C5   *)
      (    (3.7016),   (1.2717),  (-.0.3647)), (* C6 *)
      (G (
      (    (6.8745),  (-.0.0224),  (-.0.0058)), (* N2   *)
      (    (3.1770),   (3.6859),  (-.1.0198)), (* N7   *)
      (    (5.3247),   (4.2695),  (-.1.1710)), (* N9   *)
      (    (4.0156),   (4.6415),  (-.1.2759)), (* C8   *)
      (    (2.4553),   (0.7925),  (-.0.2390)), (* O6   *)
      (    (4.6497),  (-.0.5095),   (0.1212)), (* H1   *)
      (    (6.6836),  (-.0.9771),   (0.2627)), (* H21  *)
      (    (7.8474),   (0.2424),  (-.0.0653)), (* H22  *)
      (    (3.4426),   (5.5361),  (-.1.5199))) (* H8   *)
      )
    )
;;

let rG02
  = N(
      {    a=0.5566; b=0.0449; c=0.8296; (* dgf_base_tfo *)
           d=0.5125; e=0.7673; f= -.0.3854;
           g= -.0.6538; h=0.6397; i=0.4041;
           tx= -.9.1161; ty= -.3.7679; tz= -.2.9968 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.5778),   (6.6594),  (-.4.0364)), (* C5'  *)
      (    (4.9220),   (7.1963),  (-.4.9204)), (* H5'  *)
      (    (3.7996),   (5.9091),  (-.4.1764)), (* H5'' *)
      (    (5.7873),   (5.8869),  (-.3.5482)), (* C4'  *)
      (    (6.0405),   (5.0875),  (-.4.2446)), (* H4'  *)
      (    (6.9135),   (6.8036),  (-.3.4310)), (* O4'  *)
      (    (7.7293),   (6.4084),  (-.2.3392)), (* C1'  *)
      (    (8.7078),   (6.1815),  (-.2.7624)), (* H1'  *)
      (    (7.1305),   (5.1418),  (-.1.7347)), (* C2'  *)
      (    (7.2040),   (5.1982),  (-.0.6486)), (* H2'' *)
      (    (7.7417),   (4.0392),  (-.2.3813)), (* O2'  *)
      (    (8.6785),   (4.1443),  (-.2.5630)), (* H2'  *)
      (    (5.6666),   (5.2728),  (-.2.1536)), (* C3'  *)
      (    (5.1747),   (5.9805),  (-.1.4863)), (* H3'  *)
      (    (4.9997),   (4.0086),  (-.2.1973)), (* O3'  *)
      (   (10.3245),   (8.5459),   (1.5467)), (* N1   *)
      (    (9.8051),   (6.9432),  (-.0.1497)), (* N3   *)
      (   (10.5175),   (7.4328),   (0.8408)), (* C2   *)
      (    (8.7523),   (7.7422),  (-.0.4228)), (* C4   *)
      (    (8.4257),   (8.9060),   (0.2099)), (* C5   *)
      (    (9.2665),   (9.3242),   (1.2540)), (* C6 *)
      (G (
      (   (11.6077),   (6.7966),   (1.2752)), (* N2   *)
      (    (7.2750),   (9.4537),  (-.0.3428)), (* N7   *)
      (    (7.7962),   (7.5519),  (-.1.3859)), (* N9   *)
      (    (6.9479),   (8.6157),  (-.1.2771)), (* C8   *)
      (    (9.0664),  (10.4462),   (1.9610)), (* O6   *)
      (   (10.9838),   (8.7524),   (2.2697)), (* H1   *)
      (   (12.2274),   (7.0896),   (2.0170)), (* H21  *)
      (   (11.8502),   (5.9398),   (0.7984)), (* H22  *)
      (    (6.0430),   (8.9853),  (-.1.7594))) (* H8   *)
      )
    )
;;

let rG03
  = N(
      {    a= -.0.5021; b=0.0731; c=0.8617; (* dgf_base_tfo *)
           d= -.0.8112; e=0.3054; f= -.0.4986;
           g= -.0.2996; h= -.0.9494; i= -.0.0940;
           tx=6.4273; ty= -.5.1944; tz= -.3.7807 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.1214),   (6.7116),  (-.1.9049)), (* C5'  *)
      (    (3.3465),   (5.9610),  (-.2.0607)), (* H5'  *)
      (    (4.0789),   (7.2928),  (-.0.9837)), (* H5'' *)
      (    (5.4170),   (5.9293),  (-.1.8186)), (* C4'  *)
      (    (5.4506),   (5.3400),  (-.0.9023)), (* H4'  *)
      (    (5.5067),   (5.0417),  (-.2.9703)), (* O4'  *)
      (    (6.8650),   (4.9152),  (-.3.3612)), (* C1'  *)
      (    (7.1090),   (3.8577),  (-.3.2603)), (* H1'  *)
      (    (7.7152),   (5.7282),  (-.2.3894)), (* C2'  *)
      (    (8.5029),   (6.2356),  (-.2.9463)), (* H2'' *)
      (    (8.1036),   (4.8568),  (-.1.3419)), (* O2'  *)
      (    (8.3270),   (3.9651),  (-.1.6184)), (* H2'  *)
      (    (6.7003),   (6.7565),  (-.1.8911)), (* C3'  *)
      (    (6.5898),   (7.5329),  (-.2.6482)), (* H3'  *)
      (    (7.0505),   (7.2878),  (-.0.6105)), (* O3'  *)
      (    (9.6740),   (4.7656),  (-.7.6614)), (* N1   *)
      (    (9.0739),   (4.3013),  (-.5.3941)), (* N3   *)
      (    (9.8416),   (4.2192),  (-.6.4581)), (* C2   *)
      (    (7.9885),   (5.0632),  (-.5.6446)), (* C4   *)
      (    (7.6822),   (5.6856),  (-.6.8194)), (* C5   *)
      (    (8.5831),   (5.5215),  (-.7.8840)), (* C6 *)
      (G (
      (   (10.9733),   (3.5117),  (-.6.4286)), (* N2   *)
      (    (6.4857),   (6.3816),  (-.6.7035)), (* N7   *)
      (    (6.9740),   (5.3703),  (-.4.7760)), (* N9   *)
      (    (6.1133),   (6.1613),  (-.5.4808)), (* C8   *)
      (    (8.4084),   (6.0747),  (-.9.0933)), (* O6   *)
      (   (10.3759),   (4.5855),  (-.8.3504)), (* H1   *)
      (   (11.6254),   (3.3761),  (-.7.1879)), (* H21  *)
      (   (11.1917),   (3.0460),  (-.5.5593)), (* H22  *)
      (    (5.1705),   (6.6830),  (-.5.3167))) (* H8   *)
      )
    )
;;

let rG04
  = N(
      {    a= -.0.5426; b= -.0.8175; c=0.1929; (* dgf_base_tfo *)
           d=0.8304; e= -.0.5567; f= -.0.0237;
           g=0.1267; h=0.1473; i=0.9809;
           tx= -.0.5075; ty=8.3929; tz=0.2229 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (5.4352),   (8.2183),  (-.2.7757)), (* C5'  *)
      (    (5.3830),   (8.7883),  (-.1.8481)), (* H5'  *)
      (    (5.7729),   (8.7436),  (-.3.6691)), (* H5'' *)
      (    (6.4830),   (7.1518),  (-.2.5252)), (* C4'  *)
      (    (7.4749),   (7.5972),  (-.2.4482)), (* H4'  *)
      (    (6.1626),   (6.4620),  (-.1.2827)), (* O4'  *)
      (    (6.5431),   (5.0992),  (-.1.3905)), (* C1'  *)
      (    (7.2871),   (4.9328),  (-.0.6114)), (* H1'  *)
      (    (7.1852),   (4.8935),  (-.2.7592)), (* C2'  *)
      (    (6.8573),   (3.9363),  (-.3.1645)), (* H2'' *)
      (    (8.5780),   (5.1025),  (-.2.6046)), (* O2'  *)
      (    (8.9516),   (4.7577),  (-.1.7902)), (* H2'  *)
      (    (6.5522),   (6.0300),  (-.3.5612)), (* C3'  *)
      (    (5.5420),   (5.7356),  (-.3.8459)), (* H3'  *)
      (    (7.3487),   (6.4089),  (-.4.6867)), (* O3'  *)
      (    (3.6343),   (2.6680),   (2.0783)), (* N1   *)
      (    (5.4505),   (3.9805),   (1.2446)), (* N3   *)
      (    (4.7540),   (3.3816),   (2.1851)), (* C2   *)
      (    (4.8805),   (3.7951),   (0.0354)), (* C4   *)
      (    (3.7416),   (3.0925),  (-.0.2305)), (* C5   *)
      (    (3.0873),   (2.4980),   (0.8606)), (* C6 *)
      (G (
      (    (5.1433),   (3.4373),   (3.4609)), (* N2   *)
      (    (3.4605),   (3.1184),  (-.1.5906)), (* N7   *)
      (    (5.3247),   (4.2695),  (-.1.1710)), (* N9   *)
      (    (4.4244),   (3.8244),  (-.2.0953)), (* C8   *)
      (    (1.9600),   (1.7805),   (0.7462)), (* O6   *)
      (    (3.2489),   (2.2879),   (2.9191)), (* H1   *)
      (    (4.6785),   (3.0243),   (4.2568)), (* H21  *)
      (    (5.9823),   (3.9654),   (3.6539)), (* H22  *)
      (    (4.2675),   (3.8876),  (-.3.1721))) (* H8   *)
      )
    )
;;

let rG05
  = N(
      {    a= -.0.5891; b=0.0449; c=0.8068; (* dgf_base_tfo *)
           d=0.5375; e=0.7673; f=0.3498;
           g= -.0.6034; h=0.6397; i= -.0.4762;
           tx= -.0.3019; ty= -.3.7679; tz= -.9.5913 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.5778),   (6.6594),  (-.4.0364)), (* C5'  *)
      (    (4.9220),   (7.1963),  (-.4.9204)), (* H5'  *)
      (    (3.7996),   (5.9091),  (-.4.1764)), (* H5'' *)
      (    (5.7873),   (5.8869),  (-.3.5482)), (* C4'  *)
      (    (6.0405),   (5.0875),  (-.4.2446)), (* H4'  *)
      (    (6.9135),   (6.8036),  (-.3.4310)), (* O4'  *)
      (    (7.7293),   (6.4084),  (-.2.3392)), (* C1'  *)
      (    (8.7078),   (6.1815),  (-.2.7624)), (* H1'  *)
      (    (7.1305),   (5.1418),  (-.1.7347)), (* C2'  *)
      (    (7.2040),   (5.1982),  (-.0.6486)), (* H2'' *)
      (    (7.7417),   (4.0392),  (-.2.3813)), (* O2'  *)
      (    (8.6785),   (4.1443),  (-.2.5630)), (* H2'  *)
      (    (5.6666),   (5.2728),  (-.2.1536)), (* C3'  *)
      (    (5.1747),   (5.9805),  (-.1.4863)), (* H3'  *)
      (    (4.9997),   (4.0086),  (-.2.1973)), (* O3'  *)
      (   (10.2594),  (10.6774),  (-.1.0056)), (* N1   *)
      (    (9.7528),   (8.7080),  (-.2.2631)), (* N3   *)
      (   (10.4471),   (9.7876),  (-.1.9791)), (* C2   *)
      (    (8.7271),   (8.5575),  (-.1.3991)), (* C4   *)
      (    (8.4100),   (9.3803),  (-.0.3580)), (* C5   *)
      (    (9.2294),  (10.5030),  (-.0.1574)), (* C6 *)
      (G (
      (   (11.5110),  (10.1256),  (-.2.7114)), (* N2   *)
      (    (7.2891),   (8.9068),   (0.3121)), (* N7   *)
      (    (7.7962),   (7.5519),  (-.1.3859)), (* N9   *)
      (    (6.9702),   (7.8292),  (-.0.3353)), (* C8   *)
      (    (9.0349),  (11.3951),   (0.8250)), (* O6   *)
      (   (10.9013),  (11.4422),  (-.0.9512)), (* H1   *)
      (   (12.1031),  (10.9341),  (-.2.5861)), (* H21  *)
      (   (11.7369),   (9.5180),  (-.3.4859)), (* H22  *)
      (    (6.0888),   (7.3990),   (0.1403))) (* H8   *)
      )
    )
;;

let rG06
  = N(
      {    a= -.0.9815; b=0.0731; c= -.0.1772; (* dgf_base_tfo *)
           d=0.1912; e=0.3054; f= -.0.9328;
           g= -.0.0141; h= -.0.9494; i= -.0.3137;
           tx=5.7506; ty= -.5.1944; tz=4.7470 },
      {    a= -.0.8143; b= -.0.5091; c= -.0.2788; (* P_O3'_275_tfo *)
           d= -.0.0433; e= -.0.4257; f=0.9038;
           g= -.0.5788; h=0.7480; i=0.3246;
           tx=1.5227; ty=6.9114; tz= -.7.0765 },
      {    a=0.3822; b= -.0.7477; c=0.5430; (* P_O3'_180_tfo *)
           d=0.4552; e=0.6637; f=0.5935;
           g= -.0.8042; h=0.0203; i=0.5941;
           tx= -.6.9472; ty= -.4.1186; tz= -.5.9108 },
      {    a=0.5640; b=0.8007; c= -.0.2022; (* P_O3'_60_tfo *)
           d= -.0.8247; e=0.5587; f= -.0.0878;
           g=0.0426; h=0.2162; i=0.9754;
           tx=6.2694; ty= -.7.0540; tz=3.3316 },
      (    (2.8930),   (8.5380),  (-.3.3280)), (* P    *)
      (    (1.6980),   (7.6960),  (-.3.5570)), (* O1P  *)
      (    (3.2260),   (9.5010),  (-.4.4020)), (* O2P  *)
      (    (4.1590),   (7.6040),  (-.3.0340)), (* O5'  *)
      (    (4.1214),   (6.7116),  (-.1.9049)), (* C5'  *)
      (    (3.3465),   (5.9610),  (-.2.0607)), (* H5'  *)
      (    (4.0789),   (7.2928),  (-.0.9837)), (* H5'' *)
      (    (5.4170),   (5.9293),  (-.1.8186)), (* C4'  *)
      (    (5.4506),   (5.3400),  (-.0.9023)), (* H4'  *)
      (    (5.5067),   (5.0417),  (-.2.9703)), (* O4'  *)
      (    (6.8650),   (4.9152),  (-.3.3612)), (* C1'  *)
      (    (7.1090),   (3.8577),  (-.3.2603)), (* H1'  *)
      (    (7.7152),   (5.7282),  (-.2.3894)), (* C2'  *)
      (    (8.5029),   (6.2356),  (-.2.9463)), (* H2'' *)
      (    (8.1036),   (4.8568),  (-.1.3419)), (* O2'  *)
      (    (8.3270),   (3.9651),  (-.1.6184)), (* H2'  *)
      (    (6.7003),   (6.7565),  (-.1.8911)), (* C3'  *)
      (    (6.5898),   (7.5329),  (-.2.6482)), (* H3'  *)
      (    (7.0505),   (7.2878),  (-.0.6105)), (* O3'  *)
      (    (6.6624),   (3.5061),  (-.8.2986)), (* N1   *)
      (    (6.5810),   (3.2570),  (-.5.9221)), (* N3   *)
      (    (6.5151),   (2.8263),  (-.7.1625)), (* C2   *)
      (    (6.8364),   (4.5817),  (-.5.8882)), (* C4   *)
      (    (7.0116),   (5.4064),  (-.6.9609)), (* C5   *)
      (    (6.9173),   (4.8260),  (-.8.2361)), (* C6 *)
      (G (
      (    (6.2717),   (1.5402),  (-.7.4250)), (* N2   *)
      (    (7.2573),   (6.7070),  (-.6.5394)), (* N7   *)
      (    (6.9740),   (5.3703),  (-.4.7760)), (* N9   *)
      (    (7.2238),   (6.6275),  (-.5.2453)), (* C8   *)
      (    (7.0668),   (5.5163),  (-.9.3763)), (* O6   *)
      (    (6.5754),   (2.9964),  (-.9.1545)), (* H1   *)
      (    (6.1908),   (1.1105),  (-.8.3354)), (* H21  *)
      (    (6.1346),   (0.9352),  (-.6.6280)), (* H22  *)
      (    (7.4108),   (7.6227),  (-.4.8418))) (* H8   *)
      )
    )
;;

let rG07
  = N(
      {    a=0.0894; b= -.0.6059; c=0.7905; (* dgf_base_tfo *)
           d= -.0.6810; e=0.5420; f=0.4924;
           g= -.0.7268; h= -.0.5824; i= -.0.3642;
           tx=34.1424; ty=45.9610; tz= -.11.8600 },
      {    a= -.0.8644; b= -.0.4956; c= -.0.0851; (* P_O3'_275_tfo *)
           d= -.0.0427; e=0.2409; f= -.0.9696;
           g=0.5010; h= -.0.8345; i= -.0.2294;
           tx=4.0167; ty=54.5377; tz=12.4779 },
      {    a=0.3706; b= -.0.6167; c=0.6945; (* P_O3'_180_tfo *)
           d= -.0.2867; e= -.0.7872; f= -.0.5460;
           g=0.8834; h=0.0032; i= -.0.4686;
           tx= -.52.9020; ty=18.6313; tz= -.0.6709 },
      {    a=0.4155; b=0.9025; c= -.0.1137; (* P_O3'_60_tfo *)
           d=0.9040; e= -.0.4236; f= -.0.0582;
           g= -.0.1007; h= -.0.0786; i= -.0.9918;
           tx= -.7.6624; ty= -.25.2080; tz=49.5181 },
      (   (31.3810),   (0.1400),  (47.5810)), (* P    *)
      (   (29.9860),   (0.6630),  (47.6290)), (* O1P  *)
      (   (31.7210),  (-.0.6460),  (48.8090)), (* O2P  *)
      (   (32.4940),   (1.2540),  (47.2740)), (* O5'  *)
      (   (33.8709),   (0.7918),  (47.2113)), (* C5'  *)
      (   (34.1386),   (0.5870),  (46.1747)), (* H5'  *)
      (   (34.0186),  (-.0.0095),  (47.9353)), (* H5'' *)
      (   (34.7297),   (1.9687),  (47.6685)), (* C4'  *)
      (   (35.7723),   (1.6845),  (47.8113)), (* H4'  *)
      (   (34.6455),   (2.9768),  (46.6660)), (* O4'  *)
      (   (34.1690),   (4.1829),  (47.2627)), (* C1'  *)
      (   (35.0437),   (4.7633),  (47.5560)), (* H1'  *)
      (   (33.4145),   (3.7532),  (48.4954)), (* C2'  *)
      (   (32.4340),   (3.3797),  (48.2001)), (* H2'' *)
      (   (33.3209),   (4.6953),  (49.5217)), (* O2'  *)
      (   (33.2374),   (5.6059),  (49.2295)), (* H2'  *)
      (   (34.2724),   (2.5970),  (48.9773)), (* C3'  *)
      (   (33.6373),   (1.8935),  (49.5157)), (* H3'  *)
      (   (35.3453),   (3.1884),  (49.7285)), (* O3'  *)
      (   (34.0511),   (7.8930),  (43.7791)), (* N1   *)
      (   (34.9937),   (6.3369),  (45.3199)), (* N3   *)
      (   (35.0882),   (7.3126),  (44.4200)), (* C2   *)
      (   (33.7190),   (5.9650),  (45.5374)), (* C4   *)
      (   (32.5845),   (6.4770),  (44.9458)), (* C5   *)
      (   (32.7430),   (7.5179),  (43.9914)), (* C6 *)
      (G (
      (   (36.3030),   (7.7827),  (44.1036)), (* N2   *)
      (   (31.4499),   (5.8335),  (45.4368)), (* N7   *)
      (   (33.2760),   (4.9817),  (46.4043)), (* N9   *)
      (   (31.9235),   (4.9639),  (46.2934)), (* C8   *)
      (   (31.8602),   (8.1000),  (43.3695)), (* O6   *)
      (   (34.2623),   (8.6223),  (43.1283)), (* H1   *)
      (   (36.5188),   (8.5081),  (43.4347)), (* H21  *)
      (   (37.0888),   (7.3524),  (44.5699)), (* H22  *)
      (   (31.0815),   (4.4201),  (46.7218))) (* H8   *)
      )
    )
;;

let rG08
  = N(
      {    a=0.2224; b=0.6335; c=0.7411; (* dgf_base_tfo *)
           d= -.0.3644; e= -.0.6510; f=0.6659;
           g=0.9043; h= -.0.4181; i=0.0861;
           tx= -.47.6824; ty= -.0.5823; tz= -.31.7554 },
      {    a= -.0.8644; b= -.0.4956; c= -.0.0851; (* P_O3'_275_tfo *)
           d= -.0.0427; e=0.2409; f= -.0.9696;
           g=0.5010; h= -.0.8345; i= -.0.2294;
           tx=4.0167; ty=54.5377; tz=12.4779 },
      {    a=0.3706; b= -.0.6167; c=0.6945; (* P_O3'_180_tfo *)
           d= -.0.2867; e= -.0.7872; f= -.0.5460;
           g=0.8834; h=0.0032; i= -.0.4686;
           tx= -.52.9020; ty=18.6313; tz= -.0.6709 },
      {    a=0.4155; b=0.9025; c= -.0.1137; (* P_O3'_60_tfo *)
           d=0.9040; e= -.0.4236; f= -.0.0582;
           g= -.0.1007; h= -.0.0786; i= -.0.9918;
           tx= -.7.6624; ty= -.25.2080; tz=49.5181 },
      (   (31.3810),   (0.1400),  (47.5810)), (* P    *)
      (   (29.9860),   (0.6630),  (47.6290)), (* O1P  *)
      (   (31.7210),  (-.0.6460),  (48.8090)), (* O2P  *)
      (   (32.4940),   (1.2540),  (47.2740)), (* O5'  *)
      (   (32.5924),   (2.3488),  (48.2255)), (* C5'  *)
      (   (33.3674),   (2.1246),  (48.9584)), (* H5'  *)
      (   (31.5994),   (2.5917),  (48.6037)), (* H5'' *)
      (   (33.0722),   (3.5577),  (47.4258)), (* C4'  *)
      (   (33.0310),   (4.4778),  (48.0089)), (* H4'  *)
      (   (34.4173),   (3.3055),  (47.0316)), (* O4'  *)
      (   (34.5056),   (3.3910),  (45.6094)), (* C1'  *)
      (   (34.7881),   (4.4152),  (45.3663)), (* H1'  *)
      (   (33.1122),   (3.1198),  (45.1010)), (* C2'  *)
      (   (32.9230),   (2.0469),  (45.1369)), (* H2'' *)
      (   (32.7946),   (3.6590),  (43.8529)), (* O2'  *)
      (   (33.5170),   (3.6707),  (43.2207)), (* H2'  *)
      (   (32.2730),   (3.8173),  (46.1566)), (* C3'  *)
      (   (31.3094),   (3.3123),  (46.2244)), (* H3'  *)
      (   (32.2391),   (5.2039),  (45.7807)), (* O3'  *)
      (   (39.3337),   (2.7157),  (44.1441)), (* N1   *)
      (   (37.4430),   (3.8242),  (45.0824)), (* N3   *)
      (   (38.7276),   (3.7646),  (44.7403)), (* C2   *)
      (   (36.7791),   (2.6963),  (44.7704)), (* C4   *)
      (   (37.2860),   (1.5653),  (44.1678)), (* C5   *)
      (   (38.6647),   (1.5552),  (43.8235)), (* C6 *)
      (G (
      (   (39.5123),   (4.8216),  (44.9936)), (* N2   *)
      (   (36.2829),   (0.6110),  (44.0078)), (* N7   *)
      (   (35.4394),   (2.4314),  (44.9931)), (* N9   *)
      (   (35.2180),   (1.1815),  (44.5128)), (* C8   *)
      (   (39.2907),   (0.6514),  (43.2796)), (* O6   *)
      (   (40.3076),   (2.8048),  (43.9352)), (* H1   *)
      (   (40.4994),   (4.9066),  (44.7977)), (* H21  *)
      (   (39.0738),   (5.6108),  (45.4464)), (* H22  *)
      (   (34.3856),   (0.4842),  (44.4185))) (* H8   *)
      )
    )
;;

let rG09
  = N(
      {    a= -.0.9699; b= -.0.1688; c= -.0.1753; (* dgf_base_tfo *)
           d= -.0.1050; e= -.0.3598; f=0.9271;
           g= -.0.2196; h=0.9176; i=0.3312;
           tx=45.6217; ty= -.38.9484; tz= -.12.3208 },
      {    a= -.0.8644; b= -.0.4956; c= -.0.0851; (* P_O3'_275_tfo *)
           d= -.0.0427; e=0.2409; f= -.0.9696;
           g=0.5010; h= -.0.8345; i= -.0.2294;
           tx=4.0167; ty=54.5377; tz=12.4779 },
      {    a=0.3706; b= -.0.6167; c=0.6945; (* P_O3'_180_tfo *)
           d= -.0.2867; e= -.0.7872; f= -.0.5460;
           g=0.8834; h=0.0032; i= -.0.4686;
           tx= -.52.9020; ty=18.6313; tz= -.0.6709 },
      {    a=0.4155; b=0.9025; c= -.0.1137; (* P_O3'_60_tfo *)
           d=0.9040; e= -.0.4236; f= -.0.0582;
           g= -.0.1007; h= -.0.0786; i= -.0.9918;
           tx= -.7.6624; ty= -.25.2080; tz=49.5181 },
      (   (31.3810),   (0.1400),  (47.5810)), (* P    *)
      (   (29.9860),   (0.6630),  (47.6290)), (* O1P  *)
      (   (31.7210),  (-.0.6460),  (48.8090)), (* O2P  *)
      (   (32.4940),   (1.2540),  (47.2740)), (* O5'  *)
      (   (33.8709),   (0.7918),  (47.2113)), (* C5'  *)
      (   (34.1386),   (0.5870),  (46.1747)), (* H5'  *)
      (   (34.0186),  (-.0.0095),  (47.9353)), (* H5'' *)
      (   (34.7297),   (1.9687),  (47.6685)), (* C4'  *)
      (   (34.5880),   (2.8482),  (47.0404)), (* H4'  *)
      (   (34.3575),   (2.2770),  (49.0081)), (* O4'  *)
      (   (35.5157),   (2.1993),  (49.8389)), (* C1'  *)
      (   (35.9424),   (3.2010),  (49.8893)), (* H1'  *)
      (   (36.4701),   (1.2820),  (49.1169)), (* C2'  *)
      (   (36.1545),   (0.2498),  (49.2683)), (* H2'' *)
      (   (37.8262),   (1.4547),  (49.4008)), (* O2'  *)
      (   (38.0227),   (1.6945),  (50.3094)), (* H2'  *)
      (   (36.2242),   (1.6797),  (47.6725)), (* C3'  *)
      (   (36.4297),   (0.8197),  (47.0351)), (* H3'  *)
      (   (37.0289),   (2.8480),  (47.4426)), (* O3'  *)
      (   (34.3005),   (3.5042),  (54.6070)), (* N1   *)
      (   (34.7693),   (3.7936),  (52.2874)), (* N3   *)
      (   (34.4484),   (4.2541),  (53.4939)), (* C2   *)
      (   (34.9354),   (2.4584),  (52.2785)), (* C4   *)
      (   (34.8092),   (1.5915),  (53.3422)), (* C5   *)
      (   (34.4646),   (2.1367),  (54.6085)), (* C6 *)
      (G (
      (   (34.2514),   (5.5708),  (53.6503)), (* N2   *)
      (   (35.0641),   (0.2835),  (52.9337)), (* N7   *)
      (   (35.2669),   (1.6690),  (51.1915)), (* N9   *)
      (   (35.3288),   (0.3954),  (51.6563)), (* C8   *)
      (   (34.3151),   (1.5317),  (55.6650)), (* O6   *)
      (   (34.0623),   (3.9797),  (55.4539)), (* H1   *)
      (   (33.9950),   (6.0502),  (54.5016)), (* H21  *)
      (   (34.3512),   (6.1432),  (52.8242)), (* H22  *)
      (   (35.5414),  (-.0.6006),  (51.2679))) (* H8   *)
      )
    )
;;

let rG10
  = N(
      {    a= -.0.0980; b= -.0.9723; c=0.2122; (* dgf_base_tfo *)
           d= -.0.9731; e=0.1383; f=0.1841;
           g= -.0.2083; h= -.0.1885; i= -.0.9597;
           tx=17.8469; ty=38.8265; tz=37.0475 },
      {    a= -.0.8644; b= -.0.4956; c= -.0.0851; (* P_O3'_275_tfo *)
           d= -.0.0427; e=0.2409; f= -.0.9696;
           g=0.5010; h= -.0.8345; i= -.0.2294;
           tx=4.0167; ty=54.5377; tz=12.4779 },
      {    a=0.3706; b= -.0.6167; c=0.6945; (* P_O3'_180_tfo *)
           d= -.0.2867; e= -.0.7872; f= -.0.5460;
           g=0.8834; h=0.0032; i= -.0.4686;
           tx= -.52.9020; ty=18.6313; tz= -.0.6709 },
      {    a=0.4155; b=0.9025; c= -.0.1137; (* P_O3'_60_tfo *)
           d=0.9040; e= -.0.4236; f= -.0.0582;
           g= -.0.1007; h= -.0.0786; i= -.0.9918;
           tx= -.7.6624; ty= -.25.2080; tz=49.5181 },
      (   (31.3810),   (0.1400),  (47.5810)), (* P    *)
      (   (29.9860),   (0.6630),  (47.6290)), (* O1P  *)
      (   (31.7210),  (-.0.6460),  (48.8090)), (* O2P  *)
      (   (32.4940),   (1.2540),  (47.2740)), (* O5'  *)
      (   (32.5924),   (2.3488),  (48.2255)), (* C5'  *)
      (   (33.3674),   (2.1246),  (48.9584)), (* H5'  *)
      (   (31.5994),   (2.5917),  (48.6037)), (* H5'' *)
      (   (33.0722),   (3.5577),  (47.4258)), (* C4'  *)
      (   (34.0333),   (3.3761),  (46.9447)), (* H4'  *)
      (   (32.0890),   (3.8338),  (46.4332)), (* O4'  *)
      (   (31.6377),   (5.1787),  (46.5914)), (* C1'  *)
      (   (32.2499),   (5.8016),  (45.9392)), (* H1'  *)
      (   (31.9167),   (5.5319),  (48.0305)), (* C2'  *)
      (   (31.1507),   (5.0820),  (48.6621)), (* H2'' *)
      (   (32.0865),   (6.8890),  (48.3114)), (* O2'  *)
      (   (31.5363),   (7.4819),  (47.7942)), (* H2'  *)
      (   (33.2398),   (4.8224),  (48.2563)), (* C3'  *)
      (   (33.3166),   (4.5570),  (49.3108)), (* H3'  *)
      (   (34.2528),   (5.7056),  (47.7476)), (* O3'  *)
      (   (28.2782),   (6.3049),  (42.9364)), (* N1   *)
      (   (30.4001),   (5.8547),  (43.9258)), (* N3   *)
      (   (29.6195),   (6.1568),  (42.8913)), (* C2   *)
      (   (29.7005),   (5.7006),  (45.0649)), (* C4   *)
      (   (28.3383),   (5.8221),  (45.2343)), (* C5   *)
      (   (27.5519),   (6.1461),  (44.0958)), (* C6 *)
      (G (
      (   (30.1838),   (6.3385),  (41.6890)), (* N2   *)
      (   (27.9936),   (5.5926),  (46.5651)), (* N7   *)
      (   (30.2046),   (5.3825),  (46.3136)), (* N9   *)
      (   (29.1371),   (5.3398),  (47.1506)), (* C8   *)
      (   (26.3361),   (6.3024),  (44.0495)), (* O6   *)
      (   (27.8122),   (6.5394),  (42.0833)), (* H1   *)
      (   (29.7125),   (6.5595),  (40.8235)), (* H21  *)
      (   (31.1859),   (6.2231),  (41.6389)), (* H22  *)
      (   (28.9406),   (5.1504),  (48.2059))) (* H8   *)
      )
    )
;;

let rGs = [rG01;rG02;rG03;rG04;rG05;rG06;rG07;rG08;rG09;rG10]
;;

let rU
  = N(
      {    a= -.0.0359; b= -.0.8071; c=0.5894; (* dgf_base_tfo *)
           d= -.0.2669; e=0.5761; f=0.7726;
           g= -.0.9631; h= -.0.1296; i= -.0.2361;
           tx=0.1584; ty=8.3434; tz=0.5434 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2430),  (-.8.2420),   (2.8260)), (* C5'  *)
      (    (5.1974),  (-.8.8497),   (1.9223)), (* H5'  *)
      (    (5.5548),  (-.8.7348),   (3.7469)), (* H5'' *)
      (    (6.3140),  (-.7.2060),   (2.5510)), (* C4'  *)
      (    (7.2954),  (-.7.6762),   (2.4898)), (* H4'  *)
      (    (6.0140),  (-.6.5420),   (1.2890)), (* O4'  *)
      (    (6.4190),  (-.5.1840),   (1.3620)), (* C1'  *)
      (    (7.1608),  (-.5.0495),   (0.5747)), (* H1'  *)
      (    (7.0760),  (-.4.9560),   (2.7270)), (* C2'  *)
      (    (6.7770),  (-.3.9803),   (3.1099)), (* H2'' *)
      (    (8.4500),  (-.5.1930),   (2.5810)), (* O2'  *)
      (    (8.8309),  (-.4.8755),   (1.7590)), (* H2'  *)
      (    (6.4060),  (-.6.0590),   (3.5580)), (* C3'  *)
      (    (5.4021),  (-.5.7313),   (3.8281)), (* H3'  *)
      (    (7.1570),  (-.6.4240),   (4.7070)), (* O3'  *)
      (    (5.2170),  (-.4.3260),   (1.1690)), (* N1   *)
      (    (4.2960),  (-.2.2560),   (0.6290)), (* N3   *)
      (    (5.4330),  (-.3.0200),   (0.7990)), (* C2   *)
      (    (2.9930),  (-.2.6780),   (0.7940)), (* C4   *)
      (    (2.8670),  (-.4.0630),   (1.1830)), (* C5   *)
      (    (3.9570),  (-.4.8300),   (1.3550)), (* C6 *)
      (U (
      (    (6.5470),  (-.2.5560),   (0.6290)), (* O2   *)
      (    (2.0540),  (-.1.9000),   (0.6130)), (* O4   *)
      (    (4.4300),  (-.1.3020),   (0.3600)), (* H3   *)
      (    (1.9590),  (-.4.4570),   (1.3250)), (* H5   *)
      (    (3.8460),  (-.5.7860),   (1.6240))) (* H6   *)
      )
    )
;;

let rU01
  = N(
      {    a= -.0.0137; b= -.0.8012; c=0.5983; (* dgf_base_tfo *)
           d= -.0.2523; e=0.5817; f=0.7733;
           g= -.0.9675; h= -.0.1404; i= -.0.2101;
           tx=0.2031; ty=8.3874; tz=0.4228 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2416),  (-.8.2422),   (2.8181)), (* C5'  *)
      (    (5.2050),  (-.8.8128),   (1.8901)), (* H5'  *)
      (    (5.5368),  (-.8.7738),   (3.7227)), (* H5'' *)
      (    (6.3232),  (-.7.2037),   (2.6002)), (* C4'  *)
      (    (7.3048),  (-.7.6757),   (2.5577)), (* H4'  *)
      (    (6.0635),  (-.6.5092),   (1.3456)), (* O4'  *)
      (    (6.4697),  (-.5.1547),   (1.4629)), (* C1'  *)
      (    (7.2354),  (-.5.0043),   (0.7018)), (* H1'  *)
      (    (7.0856),  (-.4.9610),   (2.8521)), (* C2'  *)
      (    (6.7777),  (-.3.9935),   (3.2487)), (* H2'' *)
      (    (8.4627),  (-.5.1992),   (2.7423)), (* O2'  *)
      (    (8.8693),  (-.4.8638),   (1.9399)), (* H2'  *)
      (    (6.3877),  (-.6.0809),   (3.6362)), (* C3'  *)
      (    (5.3770),  (-.5.7562),   (3.8834)), (* H3'  *)
      (    (7.1024),  (-.6.4754),   (4.7985)), (* O3'  *)
      (    (5.2764),  (-.4.2883),   (1.2538)), (* N1   *)
      (    (4.3777),  (-.2.2062),   (0.7229)), (* N3   *)
      (    (5.5069),  (-.2.9779),   (0.9088)), (* C2   *)
      (    (3.0693),  (-.2.6246),   (0.8500)), (* C4   *)
      (    (2.9279),  (-.4.0146),   (1.2149)), (* C5   *)
      (    (4.0101),  (-.4.7892),   (1.4017)), (* C6 *)
      (U (
      (    (6.6267),  (-.2.5166),   (0.7728)), (* O2   *)
      (    (2.1383),  (-.1.8396),   (0.6581)), (* O4   *)
      (    (4.5223),  (-.1.2489),   (0.4716)), (* H3   *)
      (    (2.0151),  (-.4.4065),   (1.3290)), (* H5   *)
      (    (3.8886),  (-.5.7486),   (1.6535))) (* H6   *)
      )
    )
;;

let rU02
  = N(
      {    a=0.5141; b=0.0246; c=0.8574; (* dgf_base_tfo *)
           d= -.0.5547; e= -.0.7529; f=0.3542;
           g=0.6542; h= -.0.6577; i= -.0.3734;
           tx= -.9.1111; ty= -.3.4598; tz= -.3.2939 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (4.3825),  (-.6.6585),   (4.0489)), (* C5'  *)
      (    (4.6841),  (-.7.2019),   (4.9443)), (* H5'  *)
      (    (3.6189),  (-.5.8889),   (4.1625)), (* H5'' *)
      (    (5.6255),  (-.5.9175),   (3.5998)), (* C4'  *)
      (    (5.8732),  (-.5.1228),   (4.3034)), (* H4'  *)
      (    (6.7337),  (-.6.8605),   (3.5222)), (* O4'  *)
      (    (7.5932),  (-.6.4923),   (2.4548)), (* C1'  *)
      (    (8.5661),  (-.6.2983),   (2.9064)), (* H1'  *)
      (    (7.0527),  (-.5.2012),   (1.8322)), (* C2'  *)
      (    (7.1627),  (-.5.2525),   (0.7490)), (* H2'' *)
      (    (7.6666),  (-.4.1249),   (2.4880)), (* O2'  *)
      (    (8.5944),  (-.4.2543),   (2.6981)), (* H2'  *)
      (    (5.5661),  (-.5.3029),   (2.2009)), (* C3'  *)
      (    (5.0841),  (-.6.0018),   (1.5172)), (* H3'  *)
      (    (4.9062),  (-.4.0452),   (2.2042)), (* O3'  *)
      (    (7.6298),  (-.7.6136),   (1.4752)), (* N1   *)
      (    (8.6945),  (-.8.7046),  (-.0.2857)), (* N3   *)
      (    (8.6943),  (-.7.6514),   (0.6066)), (* C2   *)
      (    (7.7426),  (-.9.6987),  (-.0.3801)), (* C4   *)
      (    (6.6642),  (-.9.5742),   (0.5722)), (* C5   *)
      (    (6.6391),  (-.8.5592),   (1.4526)), (* C6 *)
      (U (
      (    (9.5840),  (-.6.8186),   (0.6136)), (* O2   *)
      (    (7.8505), (-.10.5925),  (-.1.2223)), (* O4   *)
      (    (9.4601),  (-.8.7514),  (-.0.9277)), (* H3   *)
      (    (5.9281), (-.10.2509),   (0.5782)), (* H5   *)
      (    (5.8831),  (-.8.4931),   (2.1028))) (* H6   *)
      )
    )
;;

let rU03
  = N(
      {    a= -.0.4993; b=0.0476; c=0.8651; (* dgf_base_tfo *)
           d=0.8078; e= -.0.3353; f=0.4847;
           g=0.3132; h=0.9409; i=0.1290;
           tx=6.2989; ty= -.5.2303; tz= -.3.8577 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (3.9938),  (-.6.7042),   (1.9023)), (* C5'  *)
      (    (3.2332),  (-.5.9343),   (2.0319)), (* H5'  *)
      (    (3.9666),  (-.7.2863),   (0.9812)), (* H5'' *)
      (    (5.3098),  (-.5.9546),   (1.8564)), (* C4'  *)
      (    (5.3863),  (-.5.3702),   (0.9395)), (* H4'  *)
      (    (5.3851),  (-.5.0642),   (3.0076)), (* O4'  *)
      (    (6.7315),  (-.4.9724),   (3.4462)), (* C1'  *)
      (    (7.0033),  (-.3.9202),   (3.3619)), (* H1'  *)
      (    (7.5997),  (-.5.8018),   (2.4948)), (* C2'  *)
      (    (8.3627),  (-.6.3254),   (3.0707)), (* H2'' *)
      (    (8.0410),  (-.4.9501),   (1.4724)), (* O2'  *)
      (    (8.2781),  (-.4.0644),   (1.7570)), (* H2'  *)
      (    (6.5701),  (-.6.8129),   (1.9714)), (* C3'  *)
      (    (6.4186),  (-.7.5809),   (2.7299)), (* H3'  *)
      (    (6.9357),  (-.7.3841),   (0.7235)), (* O3'  *)
      (    (6.8024),  (-.5.4718),   (4.8475)), (* N1   *)
      (    (7.9218),  (-.5.5700),   (6.8877)), (* N3   *)
      (    (7.8908),  (-.5.0886),   (5.5944)), (* C2   *)
      (    (6.9789),  (-.6.3827),   (7.4823)), (* C4   *)
      (    (5.8742),  (-.6.7319),   (6.6202)), (* C5   *)
      (    (5.8182),  (-.6.2769),   (5.3570)), (* C6 *)
      (U (
      (    (8.7747),  (-.4.3728),   (5.1568)), (* O2   *)
      (    (7.1154),  (-.6.7509),   (8.6509)), (* O4   *)
      (    (8.7055),  (-.5.3037),   (7.4491)), (* H3   *)
      (    (5.1416),  (-.7.3178),   (6.9665)), (* H5   *)
      (    (5.0441),  (-.6.5310),   (4.7784))) (* H6   *)
      )
    )
;;

let rU04
  = N(
      {    a= -.0.5669; b= -.0.8012; c=0.1918; (* dgf_base_tfo *)
           d= -.0.8129; e=0.5817; f=0.0273;
           g= -.0.1334; h= -.0.1404; i= -.0.9811;
           tx= -.0.3279; ty=8.3874; tz=0.3355 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2416),  (-.8.2422),   (2.8181)), (* C5'  *)
      (    (5.2050),  (-.8.8128),   (1.8901)), (* H5'  *)
      (    (5.5368),  (-.8.7738),   (3.7227)), (* H5'' *)
      (    (6.3232),  (-.7.2037),   (2.6002)), (* C4'  *)
      (    (7.3048),  (-.7.6757),   (2.5577)), (* H4'  *)
      (    (6.0635),  (-.6.5092),   (1.3456)), (* O4'  *)
      (    (6.4697),  (-.5.1547),   (1.4629)), (* C1'  *)
      (    (7.2354),  (-.5.0043),   (0.7018)), (* H1'  *)
      (    (7.0856),  (-.4.9610),   (2.8521)), (* C2'  *)
      (    (6.7777),  (-.3.9935),   (3.2487)), (* H2'' *)
      (    (8.4627),  (-.5.1992),   (2.7423)), (* O2'  *)
      (    (8.8693),  (-.4.8638),   (1.9399)), (* H2'  *)
      (    (6.3877),  (-.6.0809),   (3.6362)), (* C3'  *)
      (    (5.3770),  (-.5.7562),   (3.8834)), (* H3'  *)
      (    (7.1024),  (-.6.4754),   (4.7985)), (* O3'  *)
      (    (5.2764),  (-.4.2883),   (1.2538)), (* N1   *)
      (    (3.8961),  (-.3.0896),  (-.0.1893)), (* N3   *)
      (    (5.0095),  (-.3.8907),  (-.0.0346)), (* C2   *)
      (    (3.0480),  (-.2.6632),   (0.8116)), (* C4   *)
      (    (3.4093),  (-.3.1310),   (2.1292)), (* C5   *)
      (    (4.4878),  (-.3.9124),   (2.3088)), (* C6 *)
      (U (
      (    (5.7005),  (-.4.2164),  (-.0.9842)), (* O2   *)
      (    (2.0800),  (-.1.9458),   (0.5503)), (* O4   *)
      (    (3.6834),  (-.2.7882),  (-.1.1190)), (* H3   *)
      (    (2.8508),  (-.2.8721),   (2.9172)), (* H5   *)
      (    (4.7188),  (-.4.2247),   (3.2295))) (* H6   *)
      )
    )
;;

let rU05
  = N(
      {    a= -.0.6298; b=0.0246; c=0.7763; (* dgf_base_tfo *)
           d= -.0.5226; e= -.0.7529; f= -.0.4001;
           g=0.5746; h= -.0.6577; i=0.4870;
           tx= -.0.0208; ty= -.3.4598; tz= -.9.6882 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (4.3825),  (-.6.6585),   (4.0489)), (* C5'  *)
      (    (4.6841),  (-.7.2019),   (4.9443)), (* H5'  *)
      (    (3.6189),  (-.5.8889),   (4.1625)), (* H5'' *)
      (    (5.6255),  (-.5.9175),   (3.5998)), (* C4'  *)
      (    (5.8732),  (-.5.1228),   (4.3034)), (* H4'  *)
      (    (6.7337),  (-.6.8605),   (3.5222)), (* O4'  *)
      (    (7.5932),  (-.6.4923),   (2.4548)), (* C1'  *)
      (    (8.5661),  (-.6.2983),   (2.9064)), (* H1'  *)
      (    (7.0527),  (-.5.2012),   (1.8322)), (* C2'  *)
      (    (7.1627),  (-.5.2525),   (0.7490)), (* H2'' *)
      (    (7.6666),  (-.4.1249),   (2.4880)), (* O2'  *)
      (    (8.5944),  (-.4.2543),   (2.6981)), (* H2'  *)
      (    (5.5661),  (-.5.3029),   (2.2009)), (* C3'  *)
      (    (5.0841),  (-.6.0018),   (1.5172)), (* H3'  *)
      (    (4.9062),  (-.4.0452),   (2.2042)), (* O3'  *)
      (    (7.6298),  (-.7.6136),   (1.4752)), (* N1   *)
      (    (8.5977),  (-.9.5977),   (0.7329)), (* N3   *)
      (    (8.5951),  (-.8.5745),   (1.6594)), (* C2   *)
      (    (7.7372),  (-.9.7371),  (-.0.3364)), (* C4   *)
      (    (6.7596),  (-.8.6801),  (-.0.4476)), (* C5   *)
      (    (6.7338),  (-.7.6721),   (0.4408)), (* C6 *)
      (U (
      (    (9.3993),  (-.8.5377),   (2.5743)), (* O2   *)
      (    (7.8374), (-.10.6990),  (-.1.1008)), (* O4   *)
      (    (9.2924), (-.10.3081),   (0.8477)), (* H3   *)
      (    (6.0932),  (-.8.6982),  (-.1.1929)), (* H5   *)
      (    (6.0481),  (-.6.9515),   (0.3446))) (* H6   *)
      )
    )
;;

let rU06
  = N(
      {    a= -.0.9837; b=0.0476; c= -.0.1733; (* dgf_base_tfo *)
           d= -.0.1792; e= -.0.3353; f=0.9249;
           g= -.0.0141; h=0.9409; i=0.3384;
           tx=5.7793; ty= -.5.2303; tz=4.5997 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (3.9938),  (-.6.7042),   (1.9023)), (* C5'  *)
      (    (3.2332),  (-.5.9343),   (2.0319)), (* H5'  *)
      (    (3.9666),  (-.7.2863),   (0.9812)), (* H5'' *)
      (    (5.3098),  (-.5.9546),   (1.8564)), (* C4'  *)
      (    (5.3863),  (-.5.3702),   (0.9395)), (* H4'  *)
      (    (5.3851),  (-.5.0642),   (3.0076)), (* O4'  *)
      (    (6.7315),  (-.4.9724),   (3.4462)), (* C1'  *)
      (    (7.0033),  (-.3.9202),   (3.3619)), (* H1'  *)
      (    (7.5997),  (-.5.8018),   (2.4948)), (* C2'  *)
      (    (8.3627),  (-.6.3254),   (3.0707)), (* H2'' *)
      (    (8.0410),  (-.4.9501),   (1.4724)), (* O2'  *)
      (    (8.2781),  (-.4.0644),   (1.7570)), (* H2'  *)
      (    (6.5701),  (-.6.8129),   (1.9714)), (* C3'  *)
      (    (6.4186),  (-.7.5809),   (2.7299)), (* H3'  *)
      (    (6.9357),  (-.7.3841),   (0.7235)), (* O3'  *)
      (    (6.8024),  (-.5.4718),   (4.8475)), (* N1   *)
      (    (6.6920),  (-.5.0495),   (7.1354)), (* N3   *)
      (    (6.6201),  (-.4.5500),   (5.8506)), (* C2   *)
      (    (6.9254),  (-.6.3614),   (7.4926)), (* C4   *)
      (    (7.1046),  (-.7.2543),   (6.3718)), (* C5   *)
      (    (7.0391),  (-.6.7951),   (5.1106)), (* C6 *)
      (U (
      (    (6.4083),  (-.3.3696),   (5.6340)), (* O2   *)
      (    (6.9679),  (-.6.6901),   (8.6800)), (* O4   *)
      (    (6.5626),  (-.4.3957),   (7.8812)), (* H3   *)
      (    (7.2781),  (-.8.2254),   (6.5350)), (* H5   *)
      (    (7.1657),  (-.7.4312),   (4.3503))) (* H6   *)
      )
    )
;;

let rU07
  = N(
      {    a= -.0.9434; b=0.3172; c=0.0971; (* dgf_base_tfo *)
           d=0.2294; e=0.4125; f=0.8816;
           g=0.2396; h=0.8539; i= -.0.4619;
           tx=8.3625; ty= -.52.7147; tz=1.3745 },
      {    a=0.2765; b= -.0.1121; c= -.0.9545; (* P_O3'_275_tfo *)
           d= -.0.8297; e=0.4733; f= -.0.2959;
           g=0.4850; h=0.8737; i=0.0379;
           tx= -.14.7774; ty= -.45.2464; tz=21.9088 },
      {    a=0.1063; b= -.0.6334; c= -.0.7665; (* P_O3'_180_tfo *)
           d= -.0.5932; e= -.0.6591; f=0.4624;
           g= -.0.7980; h=0.4055; i= -.0.4458;
           tx=43.7634; ty=4.3296; tz=28.4890 },
      {    a=0.7136; b= -.0.5032; c= -.0.4873; (* P_O3'_60_tfo *)
           d=0.6803; e=0.3317; f=0.6536;
           g= -.0.1673; h= -.0.7979; i=0.5791;
           tx= -.17.1858; ty=41.4390; tz= -.27.0751 },
      (   (21.3880),  (15.0780),  (45.5770)), (* P    *)
      (   (21.9980),  (14.5500),  (46.8210)), (* O1P  *)
      (   (21.1450),  (14.0270),  (44.5420)), (* O2P  *)
      (   (22.1250),  (16.3600),  (44.9460)), (* O5'  *)
      (   (21.5037),  (16.8594),  (43.7323)), (* C5'  *)
      (   (20.8147),  (17.6663),  (43.9823)), (* H5'  *)
      (   (21.1086),  (16.0230),  (43.1557)), (* H5'' *)
      (   (22.5654),  (17.4874),  (42.8616)), (* C4'  *)
      (   (22.1584),  (17.7243),  (41.8785)), (* H4'  *)
      (   (23.0557),  (18.6826),  (43.4751)), (* O4'  *)
      (   (24.4788),  (18.6151),  (43.6455)), (* C1'  *)
      (   (24.9355),  (19.0840),  (42.7739)), (* H1'  *)
      (   (24.7958),  (17.1427),  (43.6474)), (* C2'  *)
      (   (24.5652),  (16.7400),  (44.6336)), (* H2'' *)
      (   (26.1041),  (16.8773),  (43.2455)), (* O2'  *)
      (   (26.7516),  (17.5328),  (43.5149)), (* H2'  *)
      (   (23.8109),  (16.5979),  (42.6377)), (* C3'  *)
      (   (23.5756),  (15.5686),  (42.9084)), (* H3'  *)
      (   (24.2890),  (16.7447),  (41.2729)), (* O3'  *)
      (   (24.9420),  (19.2174),  (44.8923)), (* N1   *)
      (   (25.2655),  (20.5636),  (44.8883)), (* N3   *)
      (   (25.1663),  (21.2219),  (43.8561)), (* C2   *)
      (   (25.6911),  (21.1219),  (46.0494)), (* C4   *)
      (   (25.8051),  (20.4068),  (47.2048)), (* C5   *)
      (   (26.2093),  (20.9962),  (48.2534)), (* C6 *)
      (U (
      (   (25.4692),  (19.0221),  (47.2053)), (* O2   *)
      (   (25.0502),  (18.4827),  (46.0370)), (* O4   *)
      (   (25.9599),  (22.1772),  (46.0966)), (* H3   *)
      (   (25.5545),  (18.4409),  (48.1234)), (* H5   *)
      (   (24.7854),  (17.4265),  (45.9883))) (* H6   *)
      )
    )
;;

let rU08
  = N(
      {    a= -.0.0080; b= -.0.7928; c=0.6094; (* dgf_base_tfo *)
           d= -.0.7512; e=0.4071; f=0.5197;
           g= -.0.6601; h= -.0.4536; i= -.0.5988;
           tx=44.1482; ty=30.7036; tz=2.1088 },
      {    a=0.2765; b= -.0.1121; c= -.0.9545; (* P_O3'_275_tfo *)
           d= -.0.8297; e=0.4733; f= -.0.2959;
           g=0.4850; h=0.8737; i=0.0379;
           tx= -.14.7774; ty= -.45.2464; tz=21.9088 },
      {    a=0.1063; b= -.0.6334; c= -.0.7665; (* P_O3'_180_tfo *)
           d= -.0.5932; e= -.0.6591; f=0.4624;
           g= -.0.7980; h=0.4055; i= -.0.4458;
           tx=43.7634; ty=4.3296; tz=28.4890 },
      {    a=0.7136; b= -.0.5032; c= -.0.4873; (* P_O3'_60_tfo *)
           d=0.6803; e=0.3317; f=0.6536;
           g= -.0.1673; h= -.0.7979; i=0.5791;
           tx= -.17.1858; ty=41.4390; tz= -.27.0751 },
      (   (21.3880),  (15.0780),  (45.5770)), (* P    *)
      (   (21.9980),  (14.5500),  (46.8210)), (* O1P  *)
      (   (21.1450),  (14.0270),  (44.5420)), (* O2P  *)
      (   (22.1250),  (16.3600),  (44.9460)), (* O5'  *)
      (   (23.5096),  (16.1227),  (44.5783)), (* C5'  *)
      (   (23.5649),  (15.8588),  (43.5222)), (* H5'  *)
      (   (23.9621),  (15.4341),  (45.2919)), (* H5'' *)
      (   (24.2805),  (17.4138),  (44.7151)), (* C4'  *)
      (   (25.3492),  (17.2309),  (44.6030)), (* H4'  *)
      (   (23.8497),  (18.3471),  (43.7208)), (* O4'  *)
      (   (23.4090),  (19.5681),  (44.3321)), (* C1'  *)
      (   (24.2595),  (20.2496),  (44.3524)), (* H1'  *)
      (   (23.0418),  (19.1813),  (45.7407)), (* C2'  *)
      (   (22.0532),  (18.7224),  (45.7273)), (* H2'' *)
      (   (23.1307),  (20.2521),  (46.6291)), (* O2'  *)
      (   (22.8888),  (21.1051),  (46.2611)), (* H2'  *)
      (   (24.0799),  (18.1326),  (46.0700)), (* C3'  *)
      (   (23.6490),  (17.4370),  (46.7900)), (* H3'  *)
      (   (25.3329),  (18.7227),  (46.5109)), (* O3'  *)
      (   (22.2515),  (20.1624),  (43.6698)), (* N1   *)
      (   (22.4760),  (21.0609),  (42.6406)), (* N3   *)
      (   (23.6229),  (21.3462),  (42.3061)), (* C2   *)
      (   (21.3986),  (21.6081),  (42.0236)), (* C4   *)
      (   (20.1189),  (21.3012),  (42.3804)), (* C5   *)
      (   (19.1599),  (21.8516),  (41.7578)), (* C6 *)
      (U (
      (   (19.8919),  (20.3745),  (43.4387)), (* O2   *)
      (   (20.9790),  (19.8423),  (44.0440)), (* O4   *)
      (   (21.5235),  (22.3222),  (41.2097)), (* H3   *)
      (   (18.8732),  (20.1200),  (43.7312)), (* H5   *)
      (   (20.8545),  (19.1313),  (44.8608))) (* H6   *)
      )
    )
;;

let rU09
  = N(
      {    a= -.0.0317; b=0.1374; c=0.9900; (* dgf_base_tfo *)
           d= -.0.3422; e= -.0.9321; f=0.1184;
           g=0.9391; h= -.0.3351; i=0.0765;
           tx= -.32.1929; ty=25.8198; tz= -.28.5088 },
      {    a=0.2765; b= -.0.1121; c= -.0.9545; (* P_O3'_275_tfo *)
           d= -.0.8297; e=0.4733; f= -.0.2959;
           g=0.4850; h=0.8737; i=0.0379;
           tx= -.14.7774; ty= -.45.2464; tz=21.9088 },
      {    a=0.1063; b= -.0.6334; c= -.0.7665; (* P_O3'_180_tfo *)
           d= -.0.5932; e= -.0.6591; f=0.4624;
           g= -.0.7980; h=0.4055; i= -.0.4458;
           tx=43.7634; ty=4.3296; tz=28.4890 },
      {    a=0.7136; b= -.0.5032; c= -.0.4873; (* P_O3'_60_tfo *)
           d=0.6803; e=0.3317; f=0.6536;
           g= -.0.1673; h= -.0.7979; i=0.5791;
           tx= -.17.1858; ty=41.4390; tz= -.27.0751 },
      (   (21.3880),  (15.0780),  (45.5770)), (* P    *)
      (   (21.9980),  (14.5500),  (46.8210)), (* O1P  *)
      (   (21.1450),  (14.0270),  (44.5420)), (* O2P  *)
      (   (22.1250),  (16.3600),  (44.9460)), (* O5'  *)
      (   (21.5037),  (16.8594),  (43.7323)), (* C5'  *)
      (   (20.8147),  (17.6663),  (43.9823)), (* H5'  *)
      (   (21.1086),  (16.0230),  (43.1557)), (* H5'' *)
      (   (22.5654),  (17.4874),  (42.8616)), (* C4'  *)
      (   (23.0565),  (18.3036),  (43.3915)), (* H4'  *)
      (   (23.5375),  (16.5054),  (42.4925)), (* O4'  *)
      (   (23.6574),  (16.4257),  (41.0649)), (* C1'  *)
      (   (24.4701),  (17.0882),  (40.7671)), (* H1'  *)
      (   (22.3525),  (16.9643),  (40.5396)), (* C2'  *)
      (   (21.5993),  (16.1799),  (40.6133)), (* H2'' *)
      (   (22.4693),  (17.4849),  (39.2515)), (* O2'  *)
      (   (23.0899),  (17.0235),  (38.6827)), (* H2'  *)
      (   (22.0341),  (18.0633),  (41.5279)), (* C3'  *)
      (   (20.9509),  (18.1709),  (41.5846)), (* H3'  *)
      (   (22.7249),  (19.3020),  (41.2100)), (* O3'  *)
      (   (23.8580),  (15.0648),  (40.5757)), (* N1   *)
      (   (25.1556),  (14.5982),  (40.4523)), (* N3   *)
      (   (26.1047),  (15.3210),  (40.7448)), (* C2   *)
      (   (25.3391),  (13.3315),  (40.0020)), (* C4   *)
      (   (24.2974),  (12.5148),  (39.6749)), (* C5   *)
      (   (24.5450),  (11.3410),  (39.2610)), (* C6 *)
      (U (
      (   (22.9633),  (12.9979),  (39.8053)), (* O2   *)
      (   (22.8009),  (14.2648),  (40.2524)), (* O4   *)
      (   (26.3414),  (12.9194),  (39.8855)), (* H3   *)
      (   (22.1227),  (12.3533),  (39.5486)), (* H5   *)
      (   (21.7989),  (14.6788),  (40.3650))) (* H6   *)
      )
    )
;;

let rU10
  = N(
      {    a= -.0.9674; b=0.1021; c= -.0.2318; (* dgf_base_tfo *)
           d= -.0.2514; e= -.0.2766; f=0.9275;
           g=0.0306; h=0.9555; i=0.2933;
           tx=27.8571; ty= -.42.1305; tz= -.24.4563 },
      {    a=0.2765; b= -.0.1121; c= -.0.9545; (* P_O3'_275_tfo *)
           d= -.0.8297; e=0.4733; f= -.0.2959;
           g=0.4850; h=0.8737; i=0.0379;
           tx= -.14.7774; ty= -.45.2464; tz=21.9088 },
      {    a=0.1063; b= -.0.6334; c= -.0.7665; (* P_O3'_180_tfo *)
           d= -.0.5932; e= -.0.6591; f=0.4624;
           g= -.0.7980; h=0.4055; i= -.0.4458;
           tx=43.7634; ty=4.3296; tz=28.4890 },
      {    a=0.7136; b= -.0.5032; c= -.0.4873; (* P_O3'_60_tfo *)
           d=0.6803; e=0.3317; f=0.6536;
           g= -.0.1673; h= -.0.7979; i=0.5791;
           tx= -.17.1858; ty=41.4390; tz= -.27.0751 },
      (   (21.3880),  (15.0780),  (45.5770)), (* P    *)
      (   (21.9980),  (14.5500),  (46.8210)), (* O1P  *)
      (   (21.1450),  (14.0270),  (44.5420)), (* O2P  *)
      (   (22.1250),  (16.3600),  (44.9460)), (* O5'  *)
      (   (23.5096),  (16.1227),  (44.5783)), (* C5'  *)
      (   (23.5649),  (15.8588),  (43.5222)), (* H5'  *)
      (   (23.9621),  (15.4341),  (45.2919)), (* H5'' *)
      (   (24.2805),  (17.4138),  (44.7151)), (* C4'  *)
      (   (23.8509),  (18.1819),  (44.0720)), (* H4'  *)
      (   (24.2506),  (17.8583),  (46.0741)), (* O4'  *)
      (   (25.5830),  (18.0320),  (46.5775)), (* C1'  *)
      (   (25.8569),  (19.0761),  (46.4256)), (* H1'  *)
      (   (26.4410),  (17.1555),  (45.7033)), (* C2'  *)
      (   (26.3459),  (16.1253),  (46.0462)), (* H2'' *)
      (   (27.7649),  (17.5888),  (45.6478)), (* O2'  *)
      (   (28.1004),  (17.9719),  (46.4616)), (* H2'  *)
      (   (25.7796),  (17.2997),  (44.3513)), (* C3'  *)
      (   (25.9478),  (16.3824),  (43.7871)), (* H3'  *)
      (   (26.2154),  (18.4984),  (43.6541)), (* O3'  *)
      (   (25.7321),  (17.6281),  (47.9726)), (* N1   *)
      (   (25.5136),  (18.5779),  (48.9560)), (* N3   *)
      (   (25.2079),  (19.7276),  (48.6503)), (* C2   *)
      (   (25.6482),  (18.1987),  (50.2518)), (* C4   *)
      (   (25.9847),  (16.9266),  (50.6092)), (* C5   *)
      (   (26.0918),  (16.6439),  (51.8416)), (* C6 *)
      (U (
      (   (26.2067),  (15.9515),  (49.5943)), (* O2   *)
      (   (26.0713),  (16.3497),  (48.3080)), (* O4   *)
      (   (25.4890),  (18.9105),  (51.0618)), (* H3   *)
      (   (26.4742),  (14.9310),  (49.8682)), (* H5   *)
      (   (26.2346),  (15.6394),  (47.4975))) (* H6   *)
      )
    )
;;

let rUs = [rU01;rU02;rU03;rU04;rU05;rU06;rU07;rU08;rU09;rU10]
;;

let rG'
  = N(
      {    a= -.0.2067; b= -.0.0264; c=0.9780; (* dgf_base_tfo *)
           d=0.9770; e= -.0.0586; f=0.2049;
           g=0.0519; h=0.9979; i=0.0379;
           tx=1.0331; ty= -.46.8078; tz= -.36.4742 },
      {    a= -.0.8644; b= -.0.4956; c= -.0.0851; (* P_O3'_275_tfo *)
           d= -.0.0427; e=0.2409; f= -.0.9696;
           g=0.5010; h= -.0.8345; i= -.0.2294;
           tx=4.0167; ty=54.5377; tz=12.4779 },
      {    a=0.3706; b= -.0.6167; c=0.6945; (* P_O3'_180_tfo *)
           d= -.0.2867; e= -.0.7872; f= -.0.5460;
           g=0.8834; h=0.0032; i= -.0.4686;
           tx= -.52.9020; ty=18.6313; tz= -.0.6709 },
      {    a=0.4155; b=0.9025; c= -.0.1137; (* P_O3'_60_tfo *)
           d=0.9040; e= -.0.4236; f= -.0.0582;
           g= -.0.1007; h= -.0.0786; i= -.0.9918;
           tx= -.7.6624; ty= -.25.2080; tz=49.5181 },
      (   (31.3810),   (0.1400),  (47.5810)), (* P    *)
      (   (29.9860),   (0.6630),  (47.6290)), (* O1P  *)
      (   (31.7210),  (-.0.6460),  (48.8090)), (* O2P  *)
      (   (32.4940),   (1.2540),  (47.2740)), (* O5'  *)
      (   (32.1610),   (2.2370),  (46.2560)), (* C5'  *)
      (   (31.2986),   (2.8190),  (46.5812)), (* H5'  *)
      (   (32.0980),   (1.7468),  (45.2845)), (* H5'' *)
      (   (33.3476),   (3.1959),  (46.1947)), (* C4'  *)
      (   (33.2668),   (3.8958),  (45.3630)), (* H4'  *)
      (   (33.3799),   (3.9183),  (47.4216)), (* O4'  *)
      (   (34.6515),   (3.7222),  (48.0398)), (* C1'  *)
      (   (35.2947),   (4.5412),  (47.7180)), (* H1'  *)
      (   (35.1756),   (2.4228),  (47.4827)), (* C2'  *)
      (   (34.6778),   (1.5937),  (47.9856)), (* H2'' *)
      (   (36.5631),   (2.2672),  (47.4798)), (* O2'  *)
      (   (37.0163),   (2.6579),  (48.2305)), (* H2'  *)
      (   (34.6953),   (2.5043),  (46.0448)), (* C3'  *)
      (   (34.5444),   (1.4917),  (45.6706)), (* H3'  *)
      (   (35.6679),   (3.3009),  (45.3487)), (* O3'  *)
      (   (37.4804),   (4.0914),  (52.2559)), (* N1   *)
      (   (36.9670),   (4.1312),  (49.9281)), (* N3   *)
      (   (37.8045),   (4.2519),  (50.9550)), (* C2   *)
      (   (35.7171),   (3.8264),  (50.3222)), (* C4   *)
      (   (35.2668),   (3.6420),  (51.6115)), (* C5   *)
      (   (36.2037),   (3.7829),  (52.6706)), (* C6 *)
      (G (
      (   (39.0869),   (4.5552),  (50.7092)), (* N2   *)
      (   (33.9075),   (3.3338),  (51.6102)), (* N7   *)
      (   (34.6126),   (3.6358),  (49.5108)), (* N9   *)
      (   (33.5805),   (3.3442),  (50.3425)), (* C8   *)
      (   (35.9958),   (3.6512),  (53.8724)), (* O6   *)
      (   (38.2106),   (4.2053),  (52.9295)), (* H1   *)
      (   (39.8218),   (4.6863),  (51.3896)), (* H21  *)
      (   (39.3420),   (4.6857),  (49.7407)), (* H22  *)
      (   (32.5194),   (3.1070),  (50.2664))) (* H8   *)
      )
    )
;;

let rU'
  = N(
      {    a= -.0.0109; b=0.5907; c=0.8068; (* dgf_base_tfo *)
           d=0.2217; e= -.0.7853; f=0.5780;
           g=0.9751; h=0.1852; i= -.0.1224;
           tx= -.1.4225; ty= -.11.0956; tz= -.2.5217 },
      {    a= -.0.8313; b= -.0.4738; c= -.0.2906; (* P_O3'_275_tfo *)
           d=0.0649; e=0.4366; f= -.0.8973;
           g=0.5521; h= -.0.7648; i= -.0.3322;
           tx=1.6833; ty=6.8060; tz= -.7.0011 },
      {    a=0.3445; b= -.0.7630; c=0.5470; (* P_O3'_180_tfo *)
           d= -.0.4628; e= -.0.6450; f= -.0.6082;
           g=0.8168; h= -.0.0436; i= -.0.5753;
           tx= -.6.8179; ty= -.3.9778; tz= -.5.9887 },
      {    a=0.5855; b=0.7931; c= -.0.1682; (* P_O3'_60_tfo *)
           d=0.8103; e= -.0.5790; f=0.0906;
           g= -.0.0255; h= -.0.1894; i= -.0.9816;
           tx=6.1203; ty= -.7.1051; tz=3.1984 },
      (    (2.6760),  (-.8.4960),   (3.2880)), (* P    *)
      (    (1.4950),  (-.7.6230),   (3.4770)), (* O1P  *)
      (    (2.9490),  (-.9.4640),   (4.3740)), (* O2P  *)
      (    (3.9730),  (-.7.5950),   (3.0340)), (* O5'  *)
      (    (5.2430),  (-.8.2420),   (2.8260)), (* C5'  *)
      (    (5.1974),  (-.8.8497),   (1.9223)), (* H5'  *)
      (    (5.5548),  (-.8.7348),   (3.7469)), (* H5'' *)
      (    (6.3140),  (-.7.2060),   (2.5510)), (* C4'  *)
      (    (5.8744),  (-.6.2116),   (2.4731)), (* H4'  *)
      (    (7.2798),  (-.7.2260),   (3.6420)), (* O4'  *)
      (    (8.5733),  (-.6.9410),   (3.1329)), (* C1'  *)
      (    (8.9047),  (-.6.0374),   (3.6446)), (* H1'  *)
      (    (8.4429),  (-.6.6596),   (1.6327)), (* C2'  *)
      (    (9.2880),  (-.7.1071),   (1.1096)), (* H2'' *)
      (    (8.2502),  (-.5.2799),   (1.4754)), (* O2'  *)
      (    (8.7676),  (-.4.7284),   (2.0667)), (* H2'  *)
      (    (7.1642),  (-.7.4416),   (1.3021)), (* C3'  *)
      (    (7.4125),  (-.8.5002),   (1.2260)), (* H3'  *)
      (    (6.5160),  (-.6.9772),   (0.1267)), (* O3'  *)
      (    (9.4531),  (-.8.1107),   (3.4087)), (* N1   *)
      (   (11.5931),  (-.9.0015),   (3.6357)), (* N3   *)
      (   (10.8101),  (-.7.8950),   (3.3748)), (* C2   *)
      (   (11.1439), (-.10.2744),   (3.9206)), (* C4   *)
      (    (9.7056), (-.10.4026),   (3.9332)), (* C5   *)
      (    (8.9192),  (-.9.3419),   (3.6833)), (* C6 *)
      (U (
      (   (11.3013),  (-.6.8063),   (3.1326)), (* O2   *)
      (   (11.9431), (-.11.1876),   (4.1375)), (* O4   *)
      (   (12.5840),  (-.8.8673),   (3.6158)), (* H3   *)
      (    (9.2891), (-.11.2898),   (4.1313)), (* H5   *)
      (    (7.9263),  (-.9.4537),   (3.6977))) (* H6   *)
      )
    )
;;

(* -.-. PARTIAL INSTANTIATIONS -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

type variable =
  { id : intg;
    t : tfo;
    n : nuc };;

let mk_var i t n = { id = i; t = t; n = n };;

let absolute_pos v p = tfo_apply v.t p;;

let atom_pos atom v = absolute_pos v (atom v.n);;

let rec get_var id (v::lst) =
  if id = v.id then v else get_var id lst;;

(* -.-. SEARCH -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

(* Sequential backtracking algorithm *)

(*+.ex_seq+.*)
let rec search (partial_inst : variable list) 
               l constr =
  match l with
    [] -> [partial_inst]
  | (h::t) ->
      let rec try_assignments = function
        [] -> []
      | v::vs ->
          if constr v partial_inst 
          then
            (search (v::partial_inst) 
                    t constr) 
            @ (try_assignments vs)
          else
            try_assignments vs
      in
        try_assignments (h partial_inst)
;;
(*+.ex_seq+.*)

let rec first_n l n = match l with 
  [] -> []
| h::t -> if  n > 0 then h::(first_n t (sub_int (n, 1))) else []
;;
 
let search2 pi l c = 
print_int (List.length l);print_newline();
let r = search pi (first_n l 23) c in 
print_int (List.length r);print_newline(); r;;

(* -.-. DOMAINS -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

(* Primary structure:   strand A CUGCCACGUCUG, strand B CAGACGUGGCAG
  
   Secondary structure: strand A CUGCCACGUCUG
                                 ||||||||||||
                                 GACGGUGCAGAC strand B
  
   Tertiary structure:
  
      5' end of strand A C1-.-.-.-.G12 3' end of strand B
                       U2-.-.-.-.-.-.-.A11
                      G3-.-.-.-.-.-.-.C10
                      C4-.-.-.-.-.G9
                       C5-.-.-.G8
                          A6
                        G6-.C7
                       C5-.-.-.-.G8
                      A4-.-.-.-.-.-.-.U9
                      G3-.-.-.-.-.-.-.-.C10
                       A2-.-.-.-.-.-.-.U11
     5' end of strand B C1-.-.-.-.G12 3' end of strand A
  
   "helix", "stacked" and "connected" describe the spatial relationship
   between two consecutive nucleotides. E.g. the nucleotides C1 and U2
   from the strand A.
  
   "wc" (stands for Watson-.Crick and is a type of base-.pairing),
   and "wc-.dumas" describe the spatial relationship between 
   nucleotides from two chains that are growing in opposite directions.
   E.g. the nucleotides C1 from strand A and G12 from strand B.
*)

(* Dynamic Domains *)

(* Given,
     "refnuc" a nucleotide which is already positioned,
     "nucl" the nucleotide to be placed,
     and "tfo" a transformation matrix which expresses the desired
     relationship between "refnuc" and "nucl",
   the function "dgf-.base" computes the transformation matrix that
   places the nucleotide "nucl" in the given relationship to "refnuc".
*)

let
dgf_base tfo v nucl
  = let x = if is_A v.n then
                tfo_align (atom_pos nuc_C1' v)
                          (atom_pos rA_N9   v)
                          (atom_pos nuc_C4  v)
              else if is_C v.n then
                tfo_align (atom_pos nuc_C1' v)
                          (atom_pos nuc_N1  v)
                          (atom_pos nuc_C2  v)
              else if is_G v.n then
                tfo_align (atom_pos nuc_C1' v)
                          (atom_pos rG_N9   v)
                          (atom_pos nuc_C4  v)
              else
                tfo_align (atom_pos nuc_C1' v)
                          (atom_pos nuc_N1  v)
                          (atom_pos nuc_C2  v)
    in
      tfo_combine (nuc_dgf_base_tfo nucl)
                  (tfo_combine tfo (tfo_inv_ortho x))
;;

(* Placement of first nucleotide. *)

let
reference n i partial_inst = [ mk_var i tfo_id n ]
;;

(* The transformation matrix for wc is from:
  
   Chandrasekaran R. et al (1989) A Re-.Examination of the Crystal
   Structure of A-.DNA Using Fiber Diffraction Data. J. Biomol.
   Struct. & Dynamics 6(6):1189-.1202.
*)

let wc_tfo
  = (
      {    a= -.1.0000; b=0.0028; c= -.0.0019;
           d=0.0028; e=0.3468; f= -.0.9379;
           g= -.0.0019; h= -.0.9379; i= -.0.3468;
           tx= -.0.0080; ty=6.0730; tz=8.7208 }
    )
;;

let
wc nucl i j partial_inst
  = [ mk_var i (dgf_base wc_tfo (get_var j partial_inst) nucl) nucl ]
;;

let wc_dumas_tfo
  = (
      {    a= -.0.9737; b= -.0.1834; c=0.1352;
           d= -.0.1779; e=0.2417; f= -.0.9539;
           g=0.1422; h= -.0.9529; i= -.0.2679;
           tx=0.4837; ty=6.2649; tz=8.0285 }
    )
;;

let
wc_dumas nucl i j partial_inst
  = [ mk_var i (dgf_base wc_dumas_tfo (get_var j partial_inst) nucl) nucl ]
;;

let helix5'_tfo
  = (
      {    a=0.9886; b= -.0.0961; c=0.1156;
           d=0.1424; e=0.8452; f= -.0.5152;
           g= -.0.0482; h=0.5258; i=0.8492;
           tx= -.3.8737; ty=0.5480; tz=3.8024 }
    )
;;

let
helix5' nucl i j partial_inst
  = [ mk_var i (dgf_base helix5'_tfo (get_var j partial_inst) nucl) nucl ]
;;

let helix3'_tfo
  = (
      {    a=0.9886; b=0.1424; c= -.0.0482;
           d= -.0.0961; e=0.8452; f=0.5258;
           g=0.1156; h= -.0.5152; i=0.8492;
           tx=3.4426; ty=2.0474; tz= -.3.7042 }
    )
;;

let
helix3' nucl i j partial_inst
  = [ mk_var i (dgf_base helix3'_tfo (get_var j partial_inst) nucl) nucl ]
;;

let g37_a38_tfo
  = (
      {    a=0.9991; b=0.0164; c= -.0.0387;
           d= -.0.0375; e=0.7616; f= -.0.6470;
           g=0.0189; h=0.6478; i=0.7615;
           tx= -.3.3018; ty=0.9975; tz=2.5585 }
    )
;;

let
g37_a38 nucl i j partial_inst
  = mk_var i (dgf_base g37_a38_tfo (get_var j partial_inst) nucl) nucl
;;

let
stacked5' nucl i j partial_inst
  = (g37_a38 nucl i j partial_inst) :: (helix5' nucl i j partial_inst)
;;

let a38_g37_tfo
  = (
      {    a=0.9991; b= -.0.0375; c=0.0189;
           d=0.0164; e=0.7616; f=0.6478;
           g= -.0.0387; h= -.0.6470; i=0.7615;
           tx=3.3819; ty=0.7718; tz= -.2.5321 }
    )
;;

let
a38_g37 nucl i j partial_inst
  = mk_var i (dgf_base a38_g37_tfo (get_var j partial_inst) nucl) nucl
;;

let   
stacked3' nucl i j partial_inst
  = (a38_g37 nucl i j partial_inst) :: (helix3' nucl i j partial_inst)
;;

let
p_o3' nucls i j partial_inst
  = let refnuc = get_var j partial_inst in
    let align = tfo_inv_ortho
                    (tfo_align (atom_pos nuc_O3' refnuc)
                               (atom_pos nuc_C3' refnuc)
                               (atom_pos nuc_C4' refnuc)) in
    let rec generate domains = function
      [] -> domains
    | n::ns ->
         generate
           ((mk_var i (tfo_combine (nuc_p_o3'_60_tfo n) align) n)::
            (mk_var i (tfo_combine (nuc_p_o3'_180_tfo n) align) n)::
            (mk_var i (tfo_combine (nuc_p_o3'_275_tfo n) align) n)::domains)
           ns
    in
      generate [] nucls
;;

(* -.-. PROBLEM STATEMENT -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

(* Define anticodon problem -.-. Science 253:1255 Figure 3a, 3b and 3c *)

let
anticodon_domains
  = [
     reference rC  27;
     helix5'   rC  28 27;
     helix5'   rA  29 28;
     helix5'   rG  30 29;
     helix5'   rA  31 30;
     wc        rU  39 31;
     helix5'   rC  40 39;
     helix5'   rU  41 40;
     helix5'   rG  42 41;
     helix5'   rG  43 42;
     stacked3' rA  38 39;
     stacked3' rG  37 38;
     stacked3' rA  36 37;
     stacked3' rA  35 36;
     stacked3' rG  34 35; (* <-. Distance      *)
     p_o3'     rCs 32 31; (*   | Constraint    *)
     p_o3'     rUs 33 32  (* <-' 3.0 Angstroms *)
    ]
;;

(* Anticodon constraint *)

let
anticodon_constraint v partial_inst =
  let rec dist j = let p = atom_pos nuc_P (get_var j partial_inst) in
                   let o3' = atom_pos nuc_O3' v in
                     pt_dist p o3'
  in
      if v.id = 33 then
        (dist 34) <= 3.0
      else
        true
;;

let
anticodon () = search2 [] anticodon_domains anticodon_constraint
;;

(* Define pseudoknot problem -.-. Science 253:1255 Figure 4a and 4b *)

let
pseudoknot_domains
  = [
     reference rA  23;
     wc_dumas  rU   8 23;
     helix3'   rG  22 23;
     wc_dumas  rC   9 22;
     helix3'   rG  21 22;
     wc_dumas  rC  10 21;
     helix3'   rC  20 21;
     wc_dumas  rG  11 20;
     helix3'   rU' 19 20; (* <-.               *)
     wc_dumas  rA  12 19; (*   | Distance      *)
(*                             | Constraint    *)
(*  Helix 1                    | 4.0 Angstroms *)
     helix3'   rC   3 19; (*   |               *)
     wc_dumas  rG  13  3; (*   |               *)
     helix3'   rC   2  3; (*   |               *)
     wc_dumas  rG  14  2; (*   |               *)
     helix3'   rC   1  2; (*   |               *)
     wc_dumas  rG' 15  1; (*   |               *)
(*                             |               *)
(*  L2 LOOP                    |               *)
     p_o3'     rUs 16 15; (*   |               *)
     p_o3'     rCs 17 16; (*   |               *)
     p_o3'     rAs 18 17; (* <-'               *)
(*                                             *)
(*  L1 LOOP                                    *)
     helix3'   rU   7  8; (* <-.               *)
     p_o3'     rCs  4  3; (*   | Constraint    *)
     stacked5' rU   5  4; (*   | 4.5 Angstroms *)
     stacked5' rC   6  5  (* <-'               *)
    ]
;;
  
(* Pseudoknot constraint *)

let
pseudoknot_constraint v partial_inst =
    let rec dist j =
        let p = atom_pos nuc_P (get_var j partial_inst) in
        let o3' = atom_pos nuc_O3' v in
        pt_dist p o3'
    in
      if v.id = 18 then
        (dist 19) <= 4.0
      else if v.id = 6 then
        (dist 7) <= 4.5
      else
        true
;;

let
pseudoknot () = search2 [] pseudoknot_domains pseudoknot_constraint
;;

(* -.-. TESTING -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*)

let list_of_atoms = function
  (N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,
   A (n6,n7,n9,c8,h2,h61,h62,h8)))
  -> [|p;o1p;o2p;o5';c5';h5';h5'';c4';h4';o4';c1';h1';c2';h2'';o2';h2';c3';
     h3';o3';n1;n3;c2;c4;c5;c6;n6;n7;n9;c8;h2;h61;h62;h8|]

| (N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,
   C (n4,o2,h41,h42,h5,h6)))
  -> [|p;o1p;o2p;o5';c5';h5';h5'';c4';h4';o4';c1';h1';c2';h2'';o2';h2';c3';
     h3';o3';n1;n3;c2;c4;c5;c6;n4;o2;h41;h42;h5;h6|]

| (N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,
   G (n2,n7,n9,c8,o6,h1,h21,h22,h8)))
  -> [|p;o1p;o2p;o5';c5';h5';h5'';c4';h4';o4';c1';h1';c2';h2'';o2';h2';c3';
     h3';o3';n1;n3;c2;c4;c5;c6;n2;n7;n9;c8;o6;h1;h21;h22;h8|]

| (N(dgf_base_tfo,p_o3'_275_tfo,p_o3'_180_tfo,p_o3'_60_tfo,
   p,o1p,o2p,o5',c5',h5',h5'',c4',h4',o4',c1',h1',c2',h2'',o2',h2',
   c3',h3',o3',n1,n3,c2,c4,c5,c6,
   U (o2,o4,h3,h5,h6)))
  -> [|p;o1p;o2p;o5';c5';h5';h5'';c4';h4';o4';c1';h1';c2';h2'';o2';h2';c3';
     h3';o3';n1;n3;c2;c4;c5;c6;o2;o4;h3;h5;h6|]
;;

let maximum (x::xs) =
  let rec iter m = function
    [] -> m
  | (a::b) -> iter (if a > m then a else m) b
  in
    iter x xs
;;

let
var_most_distant_atom v =
  let atoms = list_of_atoms v.n in
  let max_dist = ref 0.0 in
  for i = 0 to sub_int (Array.length atoms, 1) do
    let p = atoms.(i) in
    let distance = let (x,y,z) = absolute_pos v p
                   in sqrt ((x *. x) +. (y *. y) +. (z *. z)) in
    if distance > !max_dist then max_dist := distance
  done;
  !max_dist
;;

let
sol_most_distant_atom s = maximum (List.map var_most_distant_atom s)
;;

let
most_distant_atom sols = maximum (List.map sol_most_distant_atom sols)
;;

let
check () = List.length (pseudoknot ())
;;

let
run () = most_distant_atom (pseudoknot ())
;;

let main () = (print_float (run ()); print_newline());;

main ();;

(*

pgcd.ml : calcul du pgcd de 2 entiers par la me'thode d'Euclide

             pgcd (a,b) =  si a mod b = 0, -> b
                           sinon  -> pgcd(b, a mod b)

traits teste's : codage et ope'rations des entiers (mod)
                 re'cursivite' terminale
                 fonction curryfie'e


*)

let rec pgcd a b = if a mod b = 0 then b else pgcd b (a mod b);;


for i = 1 to 1000 do 
  for j = 1 to i do 
    pgcd i j
  done
done

;;



(* Benchmark on list allocation and manipulation

fichier queens.ml Pierre Weis

*)

(*let succ x = x + 1;;
*)
let rec map f l = match l with [] -> [] | h::t -> (f h)::(map f t);;

let rec interval n m =
    if n > m then [] else (n :: interval (succ n) m);;

let rec concmap f = function
    [] -> []
  | x :: l -> f x @ concmap f l;;

let rec list_length = function
    [] -> 0
  | _::l -> 1 + list_length l;;

let rec safe d x = function
    [] -> true
  | q::l -> (not (x = q)) & ((not (x = q+d)) & ((not (x = q-d)) &
            safe (d+1) x l));;

let ok = function [] -> true | x::l -> safe 1 x l;;

let rec filter p = function
   [] -> []
 | x::l -> if p x then x::filter p l else filter p l;;
let range = interval 1;;
let queens n =
 let qs = range n in
 let testcol = function b -> filter ok (map (fun q -> q::b) qs) in
 let rec gen = function
    0 -> [[]]
  | n -> print_int n;print_newline();concmap testcol (gen (n - 1)) in
 list_length (gen n);;

queens 9 ;;

let succ x = x + 1;;
(* Eratosthene's sieve *)

(* interval min max = [min; min+1; ...; max-1; max] *)

let rec interval min max =
  if min > max then [] else min :: interval (succ min) max
;;

(* filter p L returns the list of the elements in list L
   that satisfy predicate p *)

let rec filter p l = match l with
    []   -> []
  | (a::r) -> if p a then a :: filter p r else filter p r
;;

(* Application: removing all numbers multiple of n from a list of integers *)

let remove_multiples_of n =
  filter (fun m -> if (m mod n) = 0 then false else true)
;;

(* The sieve itself *)

let sieve max =
  let rec filter_again = function
     [] -> []
  | n::r as l ->
      if n*n > max then l else n :: filter_again (remove_multiples_of n r)
  in
    filter_again (interval 2 max)
;;

let rec do_list f l = match l with 
       []   -> ()
  |  (a::q) -> f a; do_list f q
;;

do_list (fun n -> print_int n; print_string " ") (sieve 20000);
print_string "\n";;
let make_vect = Array.create;;
type 'a vect = 'a array;;
let sigma p n =
let v = make_vect  (n+1)   0.0 
in
  for j=1 to p do
    for i=1 to n do v.(i)<-float_of_int(i) done;
    for i=1 to n do 
	  v.(i)<-((v.(i-1))+.(v.(i)))
	  done
  done;
  v.(n) ;;

print_float (sigma 100 10000);;
print_newline();;
let r = 50005000.0;;
print_float r;;
print_newline();;

let incr x = x:=!x+1;;
let print_endline s = print_string s;print_newline();;

type peg = Out | Empty | Peg;;

print_string "board";;print_newline();;
let board = [|
 [| Out; Out; Out; Out; Out; Out; Out; Out; Out|];
 [| Out; Out; Out; Peg; Peg; Peg; Out; Out; Out|];
 [| Out; Out; Out; Peg; Peg; Peg; Out; Out; Out|];
 [| Out; Peg; Peg; Peg; Peg; Peg; Peg; Peg; Out|];
 [| Out; Peg; Peg; Peg; Empty; Peg; Peg; Peg; Out|];
 [| Out; Peg; Peg; Peg; Peg; Peg; Peg; Peg; Out|];
 [| Out; Out; Out; Peg; Peg; Peg; Out; Out; Out|];
 [| Out; Out; Out; Peg; Peg; Peg; Out; Out; Out|];
 [| Out; Out; Out; Out; Out; Out; Out; Out; Out|]
|]
;;
print_string "apres board ";;print_newline();;
(*let moves = make_vect 31 ([||] : int vect vect);;*)
let moves = Array.create 31 ([||] : int array array);;

let dir = [| [|0;1|]; [|1;0|];[|0;-1|];[|-1;0|] |];;

let counter = ref 0;;

exception Found;;

let rec solve m =

  incr counter;
  if m = 31 then
    begin match board.(4).(4) with Peg -> true | _ -> false end
  else
    try
      if !counter mod 500 = 0 then begin
        print_int !counter; print_newline ()
      end;
      for i=1 to 7 do
      for j=1 to 7 do
        match board.(i).(j) with
          Peg ->
            for k=0 to 3 do
              let d1 = dir.(k).(0) in
              let d2 = dir.(k).(1) in
              let i1 = i+d1 in
              let i2 = i1+d1 in
              let j1 = j+d2 in
              let j2 = j1+d2 in
              match board.(i1).(j1) with
                Peg ->
                  begin match board.(i2).(j2) with
                    Empty ->
                      board.(i).(j) <- Empty;
                      board.(i1).(j1) <- Empty;
                      board.(i2).(j2) <- Peg;
                      if solve(m+1) then begin
                        moves.(m) <- [| [| i; j |]; [| i2; j2 |] |];
                        raise Found
                      end;
                      board.(i).(j) <- Peg;
                      board.(i1).(j1) <- Peg;
                      board.(i2).(j2) <- Empty;
                      ()
                    | _ -> ()
                  end
              | _ -> ()
            done
        | _ -> ()
      done
      done;
      false
    with Found ->
      true
;;

let print_peg = function
    Out -> print_string "."
  | Empty -> print_string " "
  | Peg -> print_string "$"
;;

let print_board board =
 for i=0 to 8 do
 for j=0 to 8 do
    print_peg board.(i).(j)
 done;
 print_newline ()
 done
;;

if solve 0 then (print_string "\n"; print_board board)
else print_endline "Pas trouve"
;; 

(*
.........
...   ...
...   ...
.       .
.   $   .
.       .
...   ...
...   ...
.........
*)
(*

syrac.ml : ve'rification de la conjecture de syracuse 

             { u_n = 1    :  u_n+1 ->  1
             { u_n pair   :  u_n+1 -> u_n/2
             { u_n impair :  u_n+1 -> 3*u_n + 1  

           cette suite converge toujours vers 1 (conjecture)
           pour 23529 il y a 282 etapes avant convergence.

traits teste's : codage et ope'rations des entiers (mod, /, *, +)
                 re'cursivite' terminale


*)


let rec f x = 
  if x = 1 then 1
  else if x mod 2 = 0 then f(x/2)
	   else f(3*x+1)
	   ;;

for i = 1 to 10000 do f (23529) done;;   (* 2 820 000 appels *)

if (f 23529) = 1 then print_string "OK" else print_string "PB";;
print_newline();;



exception N of int;;

let rec ctak_aux x y z =
  if x>y
  then ctak_aux (try ctak_aux (x-1) y z with N r -> r)
                (try ctak_aux (y-1) z x with N r -> r)
                (try ctak_aux (z-1) x y with N r -> r)
  else raise (N z)
;;

let rec ctak x y z =
  try ctak_aux x y z with N r -> r
;;

let rec repeat n =
  if n <= 0 then 0 else (ctak 18 12 6) + repeat (n-1)
;;

print_int (repeat 5); print_newline()
;;
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: quicksort.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

(* Good test for loops. Best compiled with -unsafe. *)

let rec qsort lo hi (a : int array) =
  if lo < hi then begin
    let i = ref lo in
    let j = ref hi in
    let pivot = a.(hi) in
    while !i < !j do
      while !i < hi && a.(!i) <= pivot do incr i done;
      while !j > lo && a.(!j) >= pivot do decr j done;
      if !i < !j then begin
        let temp = a.(!i) in a.(!i) <- a.(!j); a.(!j) <- temp
      end
    done;
    let temp = a.(!i) in a.(!i) <- a.(hi); a.(hi) <- temp;
    qsort lo (!i-1) a;
    qsort (!i+1) hi a
  end


(* Same but abstract over the comparison to force spilling *)

let cmp i j = i - j

let rec qsort2 lo hi (a : int array) =
  if lo < hi then begin
    let i = ref lo in
    let j = ref hi in
    let pivot = a.(hi) in
    while !i < !j do
      while !i < hi && cmp a.(!i) pivot <= 0 do incr i done;
      while !j > lo && cmp a.(!j) pivot >= 0 do decr j done;
      if !i < !j then begin
        let temp = a.(!i) in a.(!i) <- a.(!j); a.(!j) <- temp
      end
    done;
    let temp = a.(!i) in a.(!i) <- a.(hi); a.(hi) <- temp;
    qsort2 lo (!i-1) a;
    qsort2 (!i+1) hi a
  end


(* Test *)

let seed = ref 0

let random() =
  seed := !seed * 25173 + 17431; !seed land 0xFFF


exception Failed

let test_sort sort_fun size =
  let a = Array.create size 0 in
  let check = Array.create 4096 0 in
  for i = 0 to size-1 do
    let n = random() in a.(i) <- n; check.(n) <- check.(n)+1
  done;
  sort_fun 0 (size-1) a;
  try
    check.(a.(0)) <- check.(a.(0)) - 1;
    for i = 1 to size-1 do
      if a.(i-1) > a.(i) then raise Failed;
      check.(a.(i)) <- check.(a.(i)) - 1
    done;
    for i = 0 to 4095 do
      if check.(i) <> 0 then raise Failed
    done;
    print_string "OK";  print_newline()
  with Failed ->
    print_string "failed"; print_newline()


let main () =
  test_sort qsort 50000;
  test_sort qsort2 50000

let _ = main(); exit 0
let rec f x =
  if x land 0xFFFF <> 0
  then 1 + f (x + 1)
  else
    try
      1 + f (x + 1)
    with Stack_overflow ->
      print_string "x = "; print_int x; print_newline();
      raise Stack_overflow

let _ =
  try
    ignore(f 0)
  with Stack_overflow ->
    print_string "Stack overflow caught"; print_newline()
let rec tailcall4 a b c d =
  if a < 0
  then b
  else tailcall4 (a-1) (b+1) (c+2) (d+3)

let rec tailcall8 a b c d e f g h =
  if a < 0
  then b
  else tailcall8 (a-1) (b+1) (c+2) (d+3) (e+4) (f+5) (g+6) (h+7)

let rec tailcall16 a b c d e f g h i j k l m n o p =
  if a < 0
  then b
  else tailcall16 (a-1) (b+1) (c+2) (d+3) (e+4) (f+5) (g+6) (h+7)
                  (i+8) (j+9) (k+10) (l+11) (m+12) (n+13) (o+14) (p+15)

let indtailcall8 fn a b c d e f g h =
  fn a b c d e f g h

let indtailcall16 fn a b c d e f g h i j k l m n o p =
  fn a b c d e f g h i j k l m n o p 

let _ =
  print_int (tailcall4 10000000 0 0 0); print_newline();
  print_int (tailcall8 10000000 0 0 0 0 0 0 0); print_newline();
  print_int (tailcall16 10000000 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0); print_newline();
  print_int (indtailcall8 tailcall8 10 0 0 0 0 0 0 0); print_newline();
  print_int (indtailcall16 tailcall16 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0); print_newline()
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: takc.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

let rec tak x y z =
  if x > y then tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)
           else z

let rec repeat n =
  if n <= 0 then 0 else tak 18 12 6 + repeat(n-1)

let _ = print_int (repeat 50); print_newline(); exit 0

(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* $Id: taku.ml,v 1.1 2003/07/21 12:38:16 montela Exp $ *)

let rec tak (x, y, z) =
  if x > y then tak(tak (x-1, y, z), tak (y-1, z, x), tak (z-1, x, y))
           else z

let rec repeat n =
  if n <= 0 then 0 else tak(18,12,6) + repeat(n-1)

let _ = print_int (repeat 50); print_newline(); exit 0

open Eval;;

(* f1 = (true v false) *)
let f1 = [ ParenG ; Vrai ; Ou ; Faux ; ParenD ];;

let r1 = eval [] f1;;


(* f2 = (true v false) ^ true  *)
let f2 = [ ParenG; Vrai; Ou; Faux; ParenD; Et; Vrai ];;
let r2 = eval [] f2;;

(* f3 = x v f2 *)
let f3 = Var 'x' :: Ou :: f2;;
let r3 = eval ['x',Faux] f3;;

(* f4 = x ^ f2 *)
let f4 = Var 'x' :: Et :: f2;;
let r4 = eval ['x',Faux] f4;;

(* f5 = ! f3 *)
let f5 = Non :: f3;;
let r5 = eval ['x',Faux] f5;;

(* f6 = ! f4 *)
let f6 = Non :: f4;;
let r6 = eval ['x',Faux] f6;;

(* f7 = Faux ^ Faux *)
let f7 = [Faux; Et; Faux ];;
let r7 =  eval ['x',Faux] f7;;


(* f8 = ) ) ) *)
let f8 = [ParenD; ParenD ];;
let r8 =  eval ['x',Faux] f8;;
open Random

let _ = 
  for i = 0 to 20 do
    print_float (float 1000.); print_char ' '
  done;
  print_newline ();  print_newline ();
  for i = 0 to 20 do
    print_int (int 1000); print_char ' '
  done

let _ = exit 0


(* C *)

let foo = ( *);;


(* F *)

let f x y = x;;
f 1; f 1;;


(* M *)

(* duh *)


(* P *)

let 1 = 1;;


(* S *)

1; 1;;


(* U *)

match 1 with
| 1 -> ()
| 1 -> ()
| _ -> ()
;;


(* V *)

(* re-duh *)


(* X *)

(* re-re *)
